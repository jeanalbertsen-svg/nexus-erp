import {
  require_libbase64,
  require_libmime,
  require_libqp,
  require_src
} from "./chunk-74YWIFDJ.js";
import {
  require_build,
  require_dns,
  require_events,
  require_net,
  require_tls,
  require_zlib
} from "./chunk-RAKSFSZT.js";
import {
  require_path,
  require_safer,
  require_string_decoder
} from "./chunk-XW7GAX5F.js";
import {
  require_url,
  require_util
} from "./chunk-5VLPNJBJ.js";
import {
  require_crypto,
  require_stream
} from "./chunk-GAM2TRJG.js";
import {
  __commonJS,
  __publicField
} from "./chunk-LK32TJAX.js";

// ../node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "../node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f === "object" && f !== null) {
        var len = args.length + offset;
        if (len === 1) return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f !== "string") {
        return f;
      }
      var argLen = args.length;
      if (argLen === 0) return f;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f && f.length || 0;
      for (var i = 0; i < flen; ) {
        if (f.charCodeAt(i) === 37 && i + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f.charCodeAt(i + 1)) {
            case 100:
            case 102:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Number(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Math.floor(Number(args[a]));
              lastPos = i + 2;
              i++;
              break;
            case 79:
            case 111:
            case 106:
              if (a >= argLen)
                break;
              if (args[a] === void 0) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i + 2;
                i++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i + 2;
                i++;
                break;
              }
              str += ss(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += String(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 37:
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += "%";
              lastPos = i + 2;
              i++;
              a--;
              break;
          }
          ++a;
        }
        ++i;
      }
      if (lastPos === -1)
        return f;
      else if (lastPos < flen) {
        str += f.slice(lastPos);
      }
      return str;
    }
  }
});

// ../node_modules/pino/browser.js
var require_browser = __commonJS({
  "../node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue,
      errWithCause: asErrValue
    };
    function levelToValue(level, logger) {
      return level === "silent" ? Infinity : logger.levels.values[level];
    }
    var baseLogFunctionSymbol = Symbol("pino.logFuncs");
    var hierarchySymbol = Symbol("pino.hierarchy");
    var logFallbackMap = {
      error: "log",
      fatal: "error",
      warn: "error",
      info: "log",
      debug: "log",
      trace: "log"
    };
    function appendChildLogger(parentLogger, childLogger) {
      const newEntry = {
        logger: childLogger,
        parent: parentLogger[hierarchySymbol]
      };
      childLogger[hierarchySymbol] = newEntry;
    }
    function setupBaseLogFunctions(logger, levels, proto) {
      const logFunctions = {};
      levels.forEach((level) => {
        logFunctions[level] = proto[level] ? proto[level] : _console[level] || _console[logFallbackMap[level] || "log"] || noop;
      });
      logger[baseLogFunctionSymbol] = logFunctions;
    }
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k) {
          return k !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write) opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
      const customLevels = Object.keys(opts.customLevels || {});
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"].concat(customLevels);
      if (typeof proto === "function") {
        levels.forEach(function(level2) {
          proto[level2] = proto;
        });
      }
      if (opts.enabled === false || opts.browser.disabled) opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log) logger.log = noop;
      setupBaseLogFunctions(logger, levels, proto);
      appendChildLogger({}, logger);
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        asObjectBindingsOnly: opts.browser.asObjectBindingsOnly,
        formatters: opts.browser.formatters,
        levels,
        timestamp: getTimeFunction(opts),
        messageKey: opts.messageKey || "msg",
        onChild: opts.onChild || noop
      };
      logger.levels = getLevels(opts);
      logger.level = level;
      logger.isLevelEnabled = function(level2) {
        if (!this.levels.values[level2]) {
          return false;
        }
        return this.levels.values[level2] >= this.levels.values[this.level];
      };
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
      logger.serializers = serializers;
      logger._serialize = serialize;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = function(...args) {
        return child.call(this, setOpts, ...args);
      };
      if (transmit2) logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return levelToValue(this.level, this);
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set(this, setOpts, logger, "error");
        set(this, setOpts, logger, "fatal");
        set(this, setOpts, logger, "warn");
        set(this, setOpts, logger, "info");
        set(this, setOpts, logger, "debug");
        set(this, setOpts, logger, "trace");
        customLevels.forEach((level3) => {
          set(this, setOpts, logger, level3);
        });
      }
      function child(setOpts2, bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.bindings = bindings;
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        const newLogger = new Child(this);
        appendChildLogger(this, newLogger);
        newLogger.child = function(...args) {
          return child.call(this, setOpts2, ...args);
        };
        newLogger.level = childOptions.level || this.level;
        setOpts2.onChild(newLogger);
        return newLogger;
      }
      return logger;
    }
    function getLevels(opts) {
      const customLevels = opts.customLevels || {};
      const values = Object.assign({}, pino.levels.values, customLevels);
      const labels = Object.assign({}, pino.levels.labels, invertObject(customLevels));
      return {
        values,
        labels
      };
    }
    function invertObject(obj) {
      const inverted = {};
      Object.keys(obj).forEach(function(key) {
        inverted[obj[key]] = key;
      });
      return inverted;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function getBindingChain(logger) {
      const bindings = [];
      if (logger.bindings) {
        bindings.push(logger.bindings);
      }
      let hierarchy = logger[hierarchySymbol];
      while (hierarchy.parent) {
        hierarchy = hierarchy.parent;
        if (hierarchy.logger.bindings) {
          bindings.push(hierarchy.logger.bindings);
        }
      }
      return bindings.reverse();
    }
    function set(self2, opts, rootLogger, level) {
      Object.defineProperty(self2, level, {
        value: levelToValue(self2.level, rootLogger) > levelToValue(level, rootLogger) ? noop : rootLogger[baseLogFunctionSymbol][level],
        writable: true,
        enumerable: true,
        configurable: true
      });
      if (self2[level] === noop) {
        if (!opts.transmit) return;
        const transmitLevel = opts.transmit.level || self2.level;
        const transmitValue = levelToValue(transmitLevel, rootLogger);
        const methodValue = levelToValue(level, rootLogger);
        if (methodValue < transmitValue) return;
      }
      self2[level] = createWrap(self2, opts, rootLogger, level);
      const bindings = getBindingChain(self2);
      if (bindings.length === 0) {
        return;
      }
      self2[level] = prependBindingsInArguments(bindings, self2[level]);
    }
    function prependBindingsInArguments(bindings, logFunc) {
      return function() {
        return logFunc.apply(this, [...bindings, ...arguments]);
      };
    }
    function createWrap(self2, opts, rootLogger, level) {
      return /* @__PURE__ */ function(write) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i = 0; i < args.length; i++) args[i] = arguments[i];
          var argsIsSerialized = false;
          if (opts.serialize) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
            argsIsSerialized = true;
          }
          if (opts.asObject || opts.formatters) {
            write.call(proto, ...asObject(this, level, args, ts, opts));
          } else write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || self2._level;
            const transmitValue = levelToValue(transmitLevel, rootLogger);
            const methodValue = levelToValue(level, rootLogger);
            if (methodValue < transmitValue) return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: rootLogger.levels.values[opts.transmit.level || self2._level],
              send: opts.transmit.send,
              val: levelToValue(self2._level, rootLogger)
            }, args, argsIsSerialized);
          }
        };
      }(self2[baseLogFunctionSymbol][level]);
    }
    function asObject(logger, level, args, ts, opts) {
      const {
        level: levelFormatter,
        log: logObjectFormatter = (obj) => obj
      } = opts.formatters || {};
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const logObject = {};
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1) lvl = 1;
      if (ts) {
        logObject.time = ts;
      }
      if (levelFormatter) {
        const formattedLevel = levelFormatter(level, logger.levels.values[level]);
        Object.assign(logObject, formattedLevel);
      } else {
        logObject.level = logger.levels.values[level];
      }
      if (opts.asObjectBindingsOnly) {
        if (msg !== null && typeof msg === "object") {
          while (lvl-- && typeof argsCloned[0] === "object") {
            Object.assign(logObject, argsCloned.shift());
          }
        }
        const formattedLogObject = logObjectFormatter(logObject);
        return [formattedLogObject, ...argsCloned];
      } else {
        if (msg !== null && typeof msg === "object") {
          while (lvl-- && typeof argsCloned[0] === "object") {
            Object.assign(logObject, argsCloned.shift());
          }
          msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
        } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
        if (msg !== void 0) logObject[opts.messageKey] = msg;
        const formattedLogObject = logObjectFormatter(logObject);
        return [formattedLogObject];
      }
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i in args) {
        if (stdErrSerialize && args[i] instanceof Error) {
          args[i] = pino.stdSerializers.err(args[i]);
        } else if (typeof args[i] === "object" && !Array.isArray(args[i]) && serialize) {
          for (const k in args[i]) {
            if (serialize.indexOf(k) > -1 && k in serializers) {
              args[i][k] = serializers[k](args[i][k]);
            }
          }
        }
      }
    }
    function transmit(logger, opts, args, argsIsSerialized = false) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      if (!argsIsSerialized) {
        applySerializers(
          args,
          logger._serialize || Object.keys(logger.serializers),
          logger.serializers,
          logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
        );
      }
      logger._logEvent.ts = ts;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a) {
      return a;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o) {
        return typeof o !== "undefined" && o;
      }
      try {
        if (typeof globalThis !== "undefined") return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
    module.exports.default = pino;
    module.exports.pino = pino;
  }
});

// ../node_modules/imapflow/lib/logger.js
var require_logger = __commonJS({
  "../node_modules/imapflow/lib/logger.js"(exports, module) {
    "use strict";
    var logger = require_browser()();
    logger.level = "trace";
    module.exports = logger;
  }
});

// ../node_modules/@zone-eu/mailsplit/lib/headers.js
var require_headers = __commonJS({
  "../node_modules/@zone-eu/mailsplit/lib/headers.js"(exports, module) {
    "use strict";
    var libmime = require_libmime();
    var Headers = class {
      constructor(headers, config) {
        config = config || {};
        if (Array.isArray(headers)) {
          this.changed = true;
          this.headers = false;
          this.parsed = true;
          this.lines = headers;
        } else {
          this.changed = false;
          this.headers = headers;
          this.parsed = false;
          this.lines = false;
        }
        this.mbox = false;
        this.http = false;
        this.libmime = new libmime.Libmime({ Iconv: config.Iconv });
      }
      hasHeader(key) {
        if (!this.parsed) {
          this._parseHeaders();
        }
        key = this._normalizeHeader(key);
        return typeof this.lines.find((line) => line.key === key) === "object";
      }
      get(key) {
        if (!this.parsed) {
          this._parseHeaders();
        }
        key = this._normalizeHeader(key);
        let lines = this.lines.filter((line) => line.key === key).map((line) => line.line);
        return lines;
      }
      getDecoded(key) {
        return this.get(key).map((line) => this.libmime.decodeHeader(line)).filter((line) => line && line.value);
      }
      getFirst(key) {
        if (!this.parsed) {
          this._parseHeaders();
        }
        key = this._normalizeHeader(key);
        let header = this.lines.find((line) => line.key === key);
        if (!header) {
          return "";
        }
        return ((this.libmime.decodeHeader(header.line) || {}).value || "").toString().trim();
      }
      getList() {
        if (!this.parsed) {
          this._parseHeaders();
        }
        return this.lines;
      }
      add(key, value, index) {
        if (typeof value === "undefined") {
          return;
        }
        if (typeof value === "number") {
          value = value.toString();
        }
        if (typeof value === "string") {
          value = Buffer.from(value);
        }
        value = value.toString("binary");
        this.addFormatted(key, this.libmime.foldLines(key + ": " + value.replace(/\r?\n/g, ""), 76, false), index);
      }
      addFormatted(key, line, index) {
        if (!this.parsed) {
          this._parseHeaders();
        }
        index = index || 0;
        this.changed = true;
        if (!line) {
          return;
        }
        if (typeof line !== "string") {
          line = line.toString("binary");
        }
        let header = {
          key: this._normalizeHeader(key),
          line
        };
        if (index < 1) {
          this.lines.unshift(header);
        } else if (index >= this.lines.length) {
          this.lines.push(header);
        } else {
          this.lines.splice(index, 0, header);
        }
      }
      remove(key) {
        if (!this.parsed) {
          this._parseHeaders();
        }
        key = this._normalizeHeader(key);
        for (let i = this.lines.length - 1; i >= 0; i--) {
          if (this.lines[i].key === key) {
            this.changed = true;
            this.lines.splice(i, 1);
          }
        }
      }
      update(key, value, relativeIndex) {
        if (!this.parsed) {
          this._parseHeaders();
        }
        let keyName = key;
        let index = 0;
        key = this._normalizeHeader(key);
        let relativeIndexCount = 0;
        let relativeMatchFound = false;
        for (let i = this.lines.length - 1; i >= 0; i--) {
          if (this.lines[i].key === key) {
            if (relativeIndex && relativeIndex !== relativeIndexCount) {
              relativeIndexCount++;
              continue;
            }
            index = i;
            this.changed = true;
            this.lines.splice(i, 1);
            if (relativeIndex) {
              relativeMatchFound = true;
              break;
            }
          }
        }
        if (relativeIndex && !relativeMatchFound) {
          return;
        }
        this.add(keyName, value, index);
      }
      build(lineEnd) {
        if (!this.changed && !lineEnd) {
          return typeof this.headers === "string" ? Buffer.from(this.headers, "binary") : this.headers;
        }
        if (!this.parsed) {
          this._parseHeaders();
        }
        lineEnd = lineEnd || "\r\n";
        let headers = this.lines.map((line) => line.line.replace(/\r?\n/g, lineEnd)).join(lineEnd) + `${lineEnd}${lineEnd}`;
        if (this.mbox) {
          headers = this.mbox + lineEnd + headers;
        }
        if (this.http) {
          headers = this.http + lineEnd + headers;
        }
        return Buffer.from(headers, "binary");
      }
      _normalizeHeader(key) {
        return (key || "").toLowerCase().trim();
      }
      _parseHeaders() {
        if (!this.headers) {
          this.lines = [];
          this.parsed = true;
          return;
        }
        let lines = this.headers.toString("binary").replace(/[\r\n]+$/, "").split(/\r?\n/);
        for (let i = lines.length - 1; i >= 0; i--) {
          let chr = lines[i].charAt(0);
          if (i && (chr === " " || chr === "	")) {
            lines[i - 1] += "\r\n" + lines[i];
            lines.splice(i, 1);
          } else {
            let line = lines[i];
            if (!i && /^From /i.test(line)) {
              this.mbox = line;
              lines.splice(i, 1);
              continue;
            } else if (!i && /^POST /i.test(line)) {
              this.http = line;
              lines.splice(i, 1);
              continue;
            }
            let key = this._normalizeHeader(line.substr(0, line.indexOf(":")));
            lines[i] = {
              key,
              line
            };
          }
        }
        this.lines = lines;
        this.parsed = true;
      }
    };
    module.exports = Headers;
  }
});

// ../node_modules/@zone-eu/mailsplit/lib/mime-node.js
var require_mime_node = __commonJS({
  "../node_modules/@zone-eu/mailsplit/lib/mime-node.js"(exports, module) {
    "use strict";
    var Headers = require_headers();
    var libmime = require_libmime();
    var libqp = require_libqp();
    var libbase64 = require_libbase64();
    var PassThrough = require_stream().PassThrough;
    var pathlib = require_path();
    var MimeNode = class {
      constructor(parentNode, config) {
        this.type = "node";
        this.root = !parentNode;
        this.parentNode = parentNode;
        this._parentBoundary = this.parentNode && this.parentNode._boundary;
        this._headersLines = [];
        this._headerlen = 0;
        this._parsedContentType = false;
        this._boundary = false;
        this.multipart = false;
        this.encoding = false;
        this.headers = false;
        this.contentType = false;
        this.flowed = false;
        this.delSp = false;
        this.config = config || {};
        this.libmime = new libmime.Libmime({ Iconv: this.config.Iconv });
        this.parentPartNumber = parentNode && this.partNr || [];
        this.partNr = false;
        this.childPartNumbers = 0;
      }
      getPartNr(provided) {
        if (provided) {
          return [].concat(this.partNr || []).filter((nr) => !isNaN(nr)).concat(provided);
        }
        let childPartNr = ++this.childPartNumbers;
        return [].concat(this.partNr || []).filter((nr) => !isNaN(nr)).concat(childPartNr);
      }
      addHeaderChunk(line) {
        if (!line) {
          return;
        }
        this._headersLines.push(line);
        this._headerlen += line.length;
      }
      parseHeaders() {
        if (this.headers) {
          return;
        }
        this.headers = new Headers(Buffer.concat(this._headersLines, this._headerlen), this.config);
        this._parsedContentDisposition = this.libmime.parseHeaderValue(this.headers.getFirst("Content-Disposition"));
        let contentHeader;
        if (this.headers.get("Content-Type").length) {
          contentHeader = this.headers.getFirst("Content-Type");
        } else {
          if (this._parsedContentDisposition.params.filename) {
            let extension = pathlib.parse(this._parsedContentDisposition.params.filename).ext.replace(/^\./, "");
            if (extension) {
              contentHeader = libmime.detectMimeType(extension);
            }
          }
          if (!contentHeader) {
            if (/^attachment$/i.test(this._parsedContentDisposition.value)) {
              contentHeader = "application/octet-stream";
            } else {
              contentHeader = "text/plain";
            }
          }
        }
        this._parsedContentType = this.libmime.parseHeaderValue(contentHeader);
        this.encoding = this.headers.getFirst("Content-Transfer-Encoding").replace(/\(.*\)/g, "").toLowerCase().trim();
        this.contentType = (this._parsedContentType.value || "").toLowerCase().trim() || false;
        this.charset = this._parsedContentType.params.charset || false;
        this.disposition = (this._parsedContentDisposition.value || "").toLowerCase().trim() || false;
        if (this.disposition) {
          try {
            this.disposition = this.libmime.decodeWords(this.disposition);
          } catch (E) {
          }
        }
        this.filename = this._parsedContentDisposition.params.filename || this._parsedContentType.params.name || false;
        if (this._parsedContentType.params.format && this._parsedContentType.params.format.toLowerCase().trim() === "flowed") {
          this.flowed = true;
          if (this._parsedContentType.params.delsp && this._parsedContentType.params.delsp.toLowerCase().trim() === "yes") {
            this.delSp = true;
          }
        }
        if (this.filename) {
          try {
            this.filename = this.libmime.decodeWords(this.filename);
          } catch (E) {
          }
        }
        this.multipart = this.contentType && this.contentType.substr(0, this.contentType.indexOf("/")) === "multipart" && this.contentType.substr(this.contentType.indexOf("/") + 1) || false;
        this._boundary = this._parsedContentType.params.boundary && Buffer.from(this._parsedContentType.params.boundary) || false;
        this.rfc822 = this.contentType === "message/rfc822";
        if (!this.parentNode || this.parentNode.rfc822) {
          this.partNr = this.parentNode ? this.parentNode.getPartNr("TEXT") : ["TEXT"];
        } else {
          this.partNr = this.parentNode ? this.parentNode.getPartNr() : [];
        }
      }
      getHeaders() {
        if (!this.headers) {
          this.parseHeaders();
        }
        return this.headers.build();
      }
      setContentType(contentType) {
        if (!this.headers) {
          this.parseHeaders();
        }
        contentType = (contentType || "").toLowerCase().trim();
        if (contentType) {
          this._parsedContentType.value = contentType;
        }
        if (!this.flowed && this._parsedContentType.params.format) {
          delete this._parsedContentType.params.format;
        }
        if (!this.delSp && this._parsedContentType.params.delsp) {
          delete this._parsedContentType.params.delsp;
        }
        this.headers.update("Content-Type", this.libmime.buildHeaderValue(this._parsedContentType));
      }
      setCharset(charset) {
        if (!this.headers) {
          this.parseHeaders();
        }
        charset = (charset || "").toLowerCase().trim();
        if (charset === "ascii") {
          charset = "";
        }
        if (!charset) {
          if (!this._parsedContentType.value) {
            return;
          }
          delete this._parsedContentType.params.charset;
        } else {
          this._parsedContentType.params.charset = charset;
        }
        if (!this._parsedContentType.value) {
          this._parsedContentType.value = "text/plain";
        }
        this.headers.update("Content-Type", this.libmime.buildHeaderValue(this._parsedContentType));
      }
      setFilename(filename) {
        if (!this.headers) {
          this.parseHeaders();
        }
        this.filename = (filename || "").toLowerCase().trim();
        if (this._parsedContentType.params.name) {
          delete this._parsedContentType.params.name;
          this.headers.update("Content-Type", this.libmime.buildHeaderValue(this._parsedContentType));
        }
        if (!this.filename) {
          if (!this._parsedContentDisposition.value) {
            return;
          }
          delete this._parsedContentDisposition.params.filename;
        } else {
          this._parsedContentDisposition.params.filename = this.filename;
        }
        if (!this._parsedContentDisposition.value) {
          this._parsedContentDisposition.value = "attachment";
        }
        this.headers.update("Content-Disposition", this.libmime.buildHeaderValue(this._parsedContentDisposition));
      }
      getDecoder() {
        if (!this.headers) {
          this.parseHeaders();
        }
        switch (this.encoding) {
          case "base64":
            return new libbase64.Decoder();
          case "quoted-printable":
            return new libqp.Decoder();
          default:
            return new PassThrough();
        }
      }
      getEncoder(encoding) {
        if (!this.headers) {
          this.parseHeaders();
        }
        encoding = (encoding || "").toString().toLowerCase().trim();
        if (encoding && encoding !== this.encoding) {
          this.headers.update("Content-Transfer-Encoding", encoding);
        } else {
          encoding = this.encoding;
        }
        switch (encoding) {
          case "base64":
            return new libbase64.Encoder();
          case "quoted-printable":
            return new libqp.Encoder();
          default:
            return new PassThrough();
        }
      }
    };
    module.exports = MimeNode;
  }
});

// ../node_modules/@zone-eu/mailsplit/lib/message-splitter.js
var require_message_splitter = __commonJS({
  "../node_modules/@zone-eu/mailsplit/lib/message-splitter.js"(exports, module) {
    "use strict";
    var Transform = require_stream().Transform;
    var MimeNode = require_mime_node();
    var MAX_HEAD_SIZE = 1 * 1024 * 1024;
    var MAX_CHILD_NODES = 1e3;
    var HEAD = 1;
    var BODY = 2;
    var MessageSplitter = class extends Transform {
      constructor(config) {
        let options = {
          readableObjectMode: true,
          writableObjectMode: false
        };
        super(options);
        this.config = config || {};
        this.maxHeadSize = this.config.maxHeadSize || MAX_HEAD_SIZE;
        this.maxChildNodes = this.config.maxChildNodes || MAX_CHILD_NODES;
        this.tree = [];
        this.nodeCounter = 0;
        this.newNode();
        this.tree.push(this.node);
        this.line = false;
        this.hasFailed = false;
      }
      _transform(chunk, encoding, callback) {
        let pos = 0;
        let i = 0;
        let group = {
          type: "none"
        };
        let groupstart = this.line ? -this.line.length : 0;
        let groupend = 0;
        let checkTrailingLinebreak = (data) => {
          if (data.type === "body" && data.node.parentNode && data.value && data.value.length) {
            if (data.value[data.value.length - 1] === 10) {
              groupstart--;
              groupend--;
              pos--;
              if (data.value.length > 1 && data.value[data.value.length - 2] === 13) {
                groupstart--;
                groupend--;
                pos--;
                if (groupstart < 0 && !this.line) {
                  this.line = Buffer.allocUnsafe(1);
                  this.line[0] = 13;
                }
                data.value = data.value.slice(0, data.value.length - 2);
              } else {
                data.value = data.value.slice(0, data.value.length - 1);
              }
            } else if (data.value[data.value.length - 1] === 13) {
              groupstart--;
              groupend--;
              pos--;
              data.value = data.value.slice(0, data.value.length - 1);
            }
          }
        };
        let iterateData = () => {
          for (let len = chunk.length; i < len; i++) {
            if (chunk[i] === 10) {
              let start = Math.max(pos, 0);
              pos = ++i;
              return this.processLine(chunk.slice(start, i), false, (err, data, flush) => {
                if (err) {
                  this.hasFailed = true;
                  return setImmediate(() => callback(err));
                }
                if (!data) {
                  return setImmediate(iterateData);
                }
                if (flush) {
                  if (group && group.type !== "none") {
                    if (group.type === "body" && groupend >= groupstart && group.node.parentNode) {
                      if (chunk[groupend - 1] === 10) {
                        groupend--;
                        if (groupend >= groupstart && chunk[groupend - 1] === 13) {
                          groupend--;
                        }
                      }
                    }
                    if (groupstart !== groupend) {
                      group.value = chunk.slice(groupstart, groupend);
                      if (groupend < i) {
                        data.value = chunk.slice(groupend, i);
                      }
                    }
                    this.push(group);
                    group = {
                      type: "none"
                    };
                    groupstart = groupend = i;
                  }
                  this.push(data);
                  groupend = i;
                  return setImmediate(iterateData);
                }
                if (data.type === group.type) {
                  groupend = i;
                } else {
                  if (group.type === "body" && groupend >= groupstart && group.node.parentNode) {
                    if (chunk[groupend - 1] === 10) {
                      groupend--;
                      if (groupend >= groupstart && chunk[groupend - 1] === 13) {
                        groupend--;
                      }
                    }
                  }
                  if (group.type !== "none" && group.type !== "node") {
                    if (groupstart !== groupend) {
                      group.value = chunk.slice(groupstart, groupend);
                      if (group.value && group.value.length) {
                        this.push(group);
                        group = {
                          type: "none"
                        };
                      }
                    }
                  }
                  if (data.type === "node") {
                    this.push(data);
                    groupstart = i;
                    groupend = i;
                  } else if (groupstart < 0) {
                    groupstart = i;
                    groupend = i;
                    checkTrailingLinebreak(data);
                    if (data.value && data.value.length) {
                      this.push(data);
                    }
                  } else {
                    group = data;
                    groupstart = groupend;
                    groupend = i;
                  }
                }
                return setImmediate(iterateData);
              });
            }
          }
          if (pos >= groupstart + 1 && group.type === "body" && group.node.parentNode) {
            if (chunk[pos - 1] === 10) {
              pos--;
              if (pos >= groupstart && chunk[pos - 1] === 13) {
                pos--;
              }
            }
          }
          if (group.type !== "none" && group.type !== "node" && pos > groupstart) {
            group.value = chunk.slice(groupstart, pos);
            if (group.value && group.value.length) {
              this.push(group);
              group = {
                type: "none"
              };
            }
          }
          if (pos < chunk.length) {
            if (this.line) {
              this.line = Buffer.concat([this.line, chunk.slice(pos)]);
            } else {
              this.line = chunk.slice(pos);
            }
          }
          callback();
        };
        setImmediate(iterateData);
      }
      _flush(callback) {
        if (this.hasFailed) {
          return callback();
        }
        this.processLine(false, true, (err, data) => {
          if (err) {
            return setImmediate(() => callback(err));
          }
          if (data && (data.type === "node" || data.value && data.value.length)) {
            this.push(data);
          }
          callback();
        });
      }
      compareBoundary(line, startpos, boundary) {
        if (line.length < boundary.length + 3 + startpos || line.length > boundary.length + 6 + startpos) {
          return false;
        }
        for (let i = 0; i < boundary.length; i++) {
          if (line[i + 2 + startpos] !== boundary[i]) {
            return false;
          }
        }
        let pos = 0;
        for (let i = boundary.length + 2 + startpos; i < line.length; i++) {
          let c = line[i];
          if (pos === 0 && (c === 13 || c === 10)) {
            return 1;
          }
          if (pos === 0 && c !== 45) {
            return false;
          }
          if (pos === 1 && c !== 45) {
            return false;
          }
          if (pos === 2 && c !== 13 && c !== 10) {
            return false;
          }
          if (pos === 3 && c !== 10) {
            return false;
          }
          pos++;
        }
        return 2;
      }
      checkBoundary(line) {
        let startpos = 0;
        if (line.length >= 1 && (line[0] === 13 || line[0] === 10)) {
          startpos++;
          if (line.length >= 2 && (line[0] === 13 || line[1] === 10)) {
            startpos++;
          }
        }
        if (line.length < 4 || line[startpos] !== 45 || line[startpos + 1] !== 45) {
          return false;
        }
        let boundary;
        if (this.node._boundary && (boundary = this.compareBoundary(line, startpos, this.node._boundary))) {
          return boundary;
        }
        if (this.node._parentBoundary && (boundary = this.compareBoundary(line, startpos, this.node._parentBoundary))) {
          return boundary + 2;
        }
        return false;
      }
      processLine(line, final, next) {
        let flush = false;
        if (this.line && line) {
          line = Buffer.concat([this.line, line]);
          this.line = false;
        } else if (this.line && !line) {
          line = this.line;
          this.line = false;
        }
        if (!line) {
          line = Buffer.alloc(0);
        }
        if (this.nodeCounter > this.maxChildNodes) {
          let err = new Error("Max allowed child nodes exceeded");
          err.code = "EMAXLEN";
          return next(err);
        }
        let boundary = this.checkBoundary(line);
        if (boundary) {
          switch (boundary) {
            case 1:
              this.newNode(this.node);
              flush = true;
              break;
            case 2:
              break;
            case 3: {
              let parentNode = this.node.parentNode;
              if (parentNode && parentNode.contentType === "message/rfc822") {
                parentNode = parentNode.parentNode;
              }
              this.newNode(parentNode);
              flush = true;
              break;
            }
            case 4:
              if (this.node && this.node._headerlen && !this.node.headers) {
                this.node.parseHeaders();
                this.push(this.node);
              }
              if (this.tree.length) {
                this.node = this.tree.pop();
              }
              this.state = BODY;
              break;
          }
          return next(
            null,
            {
              node: this.node,
              type: "data",
              value: line
            },
            flush
          );
        }
        switch (this.state) {
          case HEAD: {
            this.node.addHeaderChunk(line);
            if (this.node._headerlen > this.maxHeadSize) {
              let err = new Error("Max header size for a MIME node exceeded");
              err.code = "EMAXLEN";
              return next(err);
            }
            if (final || line.length === 1 && line[0] === 10 || line.length === 2 && line[0] === 13 && line[1] === 10) {
              let currentNode = this.node;
              currentNode.parseHeaders();
              if (currentNode.contentType === "message/rfc822" && !this.config.ignoreEmbedded && (!currentNode.encoding || ["7bit", "8bit", "binary"].includes(currentNode.encoding)) && (this.config.defaultInlineEmbedded ? currentNode.disposition !== "attachment" : currentNode.disposition === "inline")) {
                currentNode.messageNode = true;
                this.newNode(currentNode);
                if (currentNode.parentNode) {
                  this.node._parentBoundary = currentNode.parentNode._boundary;
                }
              } else {
                if (currentNode.contentType === "message/rfc822") {
                  currentNode.messageNode = false;
                }
                this.state = BODY;
                if (currentNode.multipart && currentNode._boundary) {
                  this.tree.push(currentNode);
                }
              }
              return next(null, currentNode, flush);
            }
            return next();
          }
          case BODY: {
            return next(
              null,
              {
                node: this.node,
                type: this.node.multipart ? "data" : "body",
                value: line
              },
              flush
            );
          }
        }
        next(null, false);
      }
      newNode(parent) {
        this.node = new MimeNode(parent || false, this.config);
        this.state = HEAD;
        this.nodeCounter++;
      }
    };
    module.exports = MessageSplitter;
  }
});

// ../node_modules/@zone-eu/mailsplit/lib/message-joiner.js
var require_message_joiner = __commonJS({
  "../node_modules/@zone-eu/mailsplit/lib/message-joiner.js"(exports, module) {
    "use strict";
    var Transform = require_stream().Transform;
    var MessageJoiner = class extends Transform {
      constructor() {
        let options = {
          readableObjectMode: false,
          writableObjectMode: true
        };
        super(options);
      }
      _transform(obj, encoding, callback) {
        if (Buffer.isBuffer(obj)) {
          this.push(obj);
        } else if (obj.type === "node") {
          this.push(obj.getHeaders());
        } else if (obj.value) {
          this.push(obj.value);
        }
        return callback();
      }
      _flush(callback) {
        return callback();
      }
    };
    module.exports = MessageJoiner;
  }
});

// ../node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js
var require_flowed_decoder = __commonJS({
  "../node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js"(exports, module) {
    "use strict";
    var Transform = require_stream().Transform;
    var libmime = require_libmime();
    var FlowedDecoder = class extends Transform {
      constructor(config) {
        super();
        this.config = config || {};
        this.chunks = [];
        this.chunklen = 0;
        this.libmime = new libmime.Libmime({ Iconv: config.Iconv });
      }
      _transform(chunk, encoding, callback) {
        if (!chunk || !chunk.length) {
          return callback();
        }
        if (!encoding !== "buffer") {
          chunk = Buffer.from(chunk, encoding);
        }
        this.chunks.push(chunk);
        this.chunklen += chunk.length;
        callback();
      }
      _flush(callback) {
        if (this.chunklen) {
          let currentBody = Buffer.concat(this.chunks, this.chunklen);
          if (this.config.encoding === "base64") {
            currentBody = Buffer.from(currentBody.toString("binary"), "base64");
          }
          let content = this.libmime.decodeFlowed(currentBody.toString("binary"), this.config.delSp);
          this.push(Buffer.from(content, "binary"));
        }
        return callback();
      }
    };
    module.exports = FlowedDecoder;
  }
});

// ../node_modules/@zone-eu/mailsplit/lib/node-rewriter.js
var require_node_rewriter = __commonJS({
  "../node_modules/@zone-eu/mailsplit/lib/node-rewriter.js"(exports, module) {
    "use strict";
    var Transform = require_stream().Transform;
    var FlowedDecoder = require_flowed_decoder();
    var NodeRewriter = class extends Transform {
      constructor(filterFunc, rewriteAction) {
        let options = {
          readableObjectMode: true,
          writableObjectMode: true
        };
        super(options);
        this.filterFunc = filterFunc;
        this.rewriteAction = rewriteAction;
        this.decoder = false;
        this.encoder = false;
        this.continue = false;
      }
      _transform(data, encoding, callback) {
        this.processIncoming(data, callback);
      }
      _flush(callback) {
        if (this.decoder) {
          return this.processIncoming(
            {
              type: "none"
            },
            callback
          );
        }
        return callback();
      }
      processIncoming(data, callback) {
        if (this.decoder && data.type === "body") {
          if (!this.decoder.write(data.value)) {
            return this.decoder.once("drain", callback);
          } else {
            return callback();
          }
        } else if (this.decoder && data.type !== "body") {
          this.continue = () => {
            this.continue = false;
            this.decoder = false;
            this.encoder = false;
            this.processIncoming(data, callback);
          };
          return this.decoder.end();
        } else if (data.type === "node" && this.filterFunc(data)) {
          this.emit("node", this.createDecodePair(data));
        } else if (this.readable && data.type !== "none") {
          this.push(data);
        }
        callback();
      }
      createDecodePair(node) {
        this.decoder = node.getDecoder();
        if (["base64", "quoted-printable"].includes(node.encoding)) {
          this.encoder = node.getEncoder();
        } else {
          this.encoder = node.getEncoder("quoted-printable");
        }
        let lastByte = false;
        let decoder = this.decoder;
        let encoder = this.encoder;
        let firstChunk = true;
        decoder.$reading = false;
        let readFromEncoder = () => {
          decoder.$reading = true;
          let data = encoder.read();
          if (data === null) {
            decoder.$reading = false;
            return;
          }
          if (firstChunk) {
            firstChunk = false;
            if (this.readable) {
              this.push(node);
              if (node.type === "body") {
                lastByte = node.value && node.value.length && node.value[node.value.length - 1];
              }
            }
          }
          let writeMore = true;
          if (this.readable) {
            writeMore = this.push({
              node,
              type: "body",
              value: data
            });
            lastByte = data && data.length && data[data.length - 1];
          }
          if (writeMore) {
            return setImmediate(readFromEncoder);
          } else {
            encoder.pause();
            setTimeout(() => {
              encoder.resume();
              setImmediate(readFromEncoder);
            }, 100);
          }
        };
        encoder.on("readable", () => {
          if (!decoder.$reading) {
            return readFromEncoder();
          }
        });
        encoder.on("end", () => {
          if (firstChunk) {
            firstChunk = false;
            if (this.readable) {
              this.push(node);
              if (node.type === "body") {
                lastByte = node.value && node.value.length && node.value[node.value.length - 1];
              }
            }
          }
          if (lastByte !== 10) {
            this.push({
              node,
              type: "body",
              value: Buffer.from([10])
            });
          }
          if (this.continue) {
            return this.continue();
          }
        });
        if (/^text\//.test(node.contentType) && node.flowed) {
          let flowDecoder = decoder;
          decoder = new FlowedDecoder({
            delSp: node.delSp,
            encoding: node.encoding
          });
          flowDecoder.on("error", (err) => {
            decoder.emit("error", err);
          });
          flowDecoder.pipe(decoder);
          node.flowed = false;
          node.delSp = false;
          node.setContentType();
        }
        return {
          node,
          decoder,
          encoder
        };
      }
    };
    module.exports = NodeRewriter;
  }
});

// ../node_modules/@zone-eu/mailsplit/lib/node-streamer.js
var require_node_streamer = __commonJS({
  "../node_modules/@zone-eu/mailsplit/lib/node-streamer.js"(exports, module) {
    "use strict";
    var Transform = require_stream().Transform;
    var FlowedDecoder = require_flowed_decoder();
    var NodeStreamer = class extends Transform {
      constructor(filterFunc, streamAction) {
        let options = {
          readableObjectMode: true,
          writableObjectMode: true
        };
        super(options);
        this.filterFunc = filterFunc;
        this.streamAction = streamAction;
        this.decoder = false;
        this.canContinue = false;
        this.continue = false;
      }
      _transform(data, encoding, callback) {
        this.processIncoming(data, callback);
      }
      _flush(callback) {
        if (this.decoder) {
          return this.processIncoming(
            {
              type: "none"
            },
            callback
          );
        }
        return callback();
      }
      processIncoming(data, callback) {
        if (this.decoder && data.type === "body") {
          this.push(data);
          if (!this.decoder.write(data.value)) {
            return this.decoder.once("drain", callback);
          } else {
            return callback();
          }
        } else if (this.decoder && data.type !== "body") {
          let doContinue = () => {
            this.continue = false;
            this.decoder = false;
            this.canContinue = false;
            this.processIncoming(data, callback);
          };
          if (this.canContinue) {
            setImmediate(doContinue);
          } else {
            this.continue = () => doContinue();
          }
          return this.decoder.end();
        } else if (data.type === "node" && this.filterFunc(data)) {
          this.push(data);
          this.emit("node", this.createDecoder(data));
        } else if (this.readable && data.type !== "none") {
          this.push(data);
        }
        callback();
      }
      createDecoder(node) {
        this.decoder = node.getDecoder();
        let decoder = this.decoder;
        decoder.$reading = false;
        if (/^text\//.test(node.contentType) && node.flowed) {
          let flowDecoder = decoder;
          decoder = new FlowedDecoder({
            delSp: node.delSp
          });
          flowDecoder.on("error", (err) => {
            decoder.emit("error", err);
          });
          flowDecoder.pipe(decoder);
        }
        return {
          node,
          decoder,
          done: () => {
            if (typeof this.continue === "function") {
              this.continue();
            } else {
              this.canContinue = true;
            }
          }
        };
      }
    };
    module.exports = NodeStreamer;
  }
});

// ../node_modules/@zone-eu/mailsplit/lib/chunked-passthrough.js
var require_chunked_passthrough = __commonJS({
  "../node_modules/@zone-eu/mailsplit/lib/chunked-passthrough.js"(exports, module) {
    "use strict";
    var { Transform } = require_stream();
    var ChunkedPassthrough = class extends Transform {
      constructor(options = {}) {
        let config = {
          readableObjectMode: true,
          writableObjectMode: false
        };
        super(config);
        this.chunkSize = options.chunkSize || 64 * 1024;
        this.buffer = Buffer.alloc(0);
      }
      _transform(chunk, encoding, callback) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
        if (this.buffer.length >= this.chunkSize) {
          this.push(this.buffer);
          this.buffer = Buffer.alloc(0);
        }
        callback();
      }
      _flush(callback) {
        if (this.buffer.length > 0) {
          this.push(this.buffer);
          this.buffer = Buffer.alloc(0);
        }
        callback();
      }
    };
    module.exports = ChunkedPassthrough;
  }
});

// ../node_modules/@zone-eu/mailsplit/index.js
var require_mailsplit = __commonJS({
  "../node_modules/@zone-eu/mailsplit/index.js"(exports, module) {
    "use strict";
    var MessageSplitter = require_message_splitter();
    var MessageJoiner = require_message_joiner();
    var NodeRewriter = require_node_rewriter();
    var NodeStreamer = require_node_streamer();
    var Headers = require_headers();
    var ChunkedPassthrough = require_chunked_passthrough();
    module.exports = {
      Splitter: MessageSplitter,
      Joiner: MessageJoiner,
      Rewriter: NodeRewriter,
      Streamer: NodeStreamer,
      ChunkedPassthrough,
      Headers
    };
  }
});

// ../node_modules/imapflow/lib/limited-passthrough.js
var require_limited_passthrough = __commonJS({
  "../node_modules/imapflow/lib/limited-passthrough.js"(exports, module) {
    "use strict";
    var { Transform } = require_stream();
    var LimitedPassthrough = class extends Transform {
      constructor(options) {
        super();
        this.options = options || {};
        this.maxBytes = this.options.maxBytes || Infinity;
        this.processed = 0;
        this.limited = false;
      }
      _transform(chunk, encoding, done) {
        if (this.limited) {
          return done();
        }
        if (this.processed + chunk.length > this.maxBytes) {
          if (this.maxBytes - this.processed < 1) {
            return done();
          }
          chunk = chunk.slice(0, this.maxBytes - this.processed);
        }
        this.processed += chunk.length;
        if (this.processed >= this.maxBytes) {
          this.limited = true;
        }
        this.push(chunk);
        done();
      }
    };
    module.exports.LimitedPassthrough = LimitedPassthrough;
  }
});

// ../node_modules/imapflow/lib/handler/imap-stream.js
var require_imap_stream = __commonJS({
  "../node_modules/imapflow/lib/handler/imap-stream.js"(exports, module) {
    "use strict";
    var Transform = require_stream().Transform;
    var logger = require_logger();
    var LINE = 1;
    var LITERAL = 2;
    var LF = 10;
    var CR = 13;
    var NUM_0 = 48;
    var NUM_9 = 57;
    var CURLY_OPEN = 123;
    var CURLY_CLOSE = 125;
    var MAX_LITERAL_SIZE = 1024 * 1024 * 1024;
    var ImapStream = class extends Transform {
      constructor(options) {
        super({
          //writableHighWaterMark: 3,
          readableObjectMode: true,
          writableObjectMode: false
        });
        this.options = options || {};
        this.cid = this.options.cid;
        this.log = this.options.logger && typeof this.options.logger === "object" ? this.options.logger : logger.child({
          component: "imap-connection",
          cid: this.cid
        });
        this.readBytesCounter = 0;
        this.state = LINE;
        this.literalWaiting = 0;
        this.inputBuffer = [];
        this.lineBuffer = [];
        this.literalBuffer = [];
        this.literals = [];
        this.compress = false;
        this.secureConnection = this.options.secureConnection;
        this.processingInput = false;
        this.inputQueue = [];
      }
      checkLiteralMarker(line) {
        if (!line || !line.length) {
          return false;
        }
        let pos = line.length - 1;
        if (line[pos] === LF) {
          pos--;
        } else {
          return false;
        }
        if (pos >= 0 && line[pos] === CR) {
          pos--;
        }
        if (pos < 0) {
          return false;
        }
        if (!pos || line[pos] !== CURLY_CLOSE) {
          return false;
        }
        pos--;
        let numBytes = [];
        for (; pos > 0; pos--) {
          let c = line[pos];
          if (c >= NUM_0 && c <= NUM_9) {
            numBytes.unshift(c);
            continue;
          }
          if (c === CURLY_OPEN && numBytes.length) {
            const literalSize = Number(Buffer.from(numBytes).toString());
            if (literalSize > MAX_LITERAL_SIZE) {
              const err = new Error(`Literal size ${literalSize} exceeds maximum allowed size of ${MAX_LITERAL_SIZE} bytes`);
              err.code = "LiteralTooLarge";
              err.literalSize = literalSize;
              err.maxSize = MAX_LITERAL_SIZE;
              this.emit("error", err);
              return false;
            }
            this.state = LITERAL;
            this.literalWaiting = literalSize;
            return true;
          }
          return false;
        }
        return false;
      }
      async processInputChunk(chunk, startPos) {
        startPos = startPos || 0;
        if (startPos >= chunk.length) {
          return;
        }
        switch (this.state) {
          case LINE: {
            let lineStart = startPos;
            for (let i = startPos, len = chunk.length; i < len; i++) {
              if (chunk[i] === LF) {
                this.lineBuffer.push(chunk.slice(lineStart, i + 1));
                lineStart = i + 1;
                let line = Buffer.concat(this.lineBuffer);
                this.inputBuffer.push(line);
                this.lineBuffer = [];
                if (this.checkLiteralMarker(line)) {
                  return await this.processInputChunk(chunk, lineStart);
                }
                let payload = this.inputBuffer.length === 1 ? this.inputBuffer[0] : Buffer.concat(this.inputBuffer);
                let literals = this.literals;
                this.inputBuffer = [];
                this.literals = [];
                if (payload.length) {
                  let skipBytes = 0;
                  if (payload.length >= 1 && payload[payload.length - 1] === LF) {
                    skipBytes++;
                    if (payload.length >= 2 && payload[payload.length - 2] === CR) {
                      skipBytes++;
                    }
                  }
                  if (skipBytes) {
                    payload = payload.slice(0, payload.length - skipBytes);
                  }
                  if (payload.length) {
                    await new Promise((resolve) => {
                      this.push({ payload, literals, next: resolve });
                    });
                  }
                }
              }
            }
            if (lineStart < chunk.length) {
              this.lineBuffer.push(chunk.slice(lineStart));
            }
            break;
          }
          case LITERAL: {
            if (chunk.length === startPos + this.literalWaiting) {
              if (!startPos) {
                this.literalBuffer.push(chunk);
              } else {
                this.literalBuffer.push(chunk.slice(startPos));
              }
              this.literalWaiting -= chunk.length;
              this.literals.push(Buffer.concat(this.literalBuffer));
              this.literalBuffer = [];
              this.state = LINE;
              return;
            } else if (chunk.length > startPos + this.literalWaiting) {
              let partial = chunk.slice(startPos, startPos + this.literalWaiting);
              this.literalBuffer.push(partial);
              startPos += partial.length;
              this.literalWaiting -= partial.length;
              this.literals.push(Buffer.concat(this.literalBuffer));
              this.literalBuffer = [];
              this.state = LINE;
              return await this.processInputChunk(chunk, startPos);
            } else {
              let partial = chunk.slice(startPos);
              this.literalBuffer.push(partial);
              startPos += partial.length;
              this.literalWaiting -= partial.length;
              return;
            }
          }
        }
      }
      async processInput() {
        let data;
        let processedCount = 0;
        while (data = this.inputQueue.shift()) {
          await this.processInputChunk(data.chunk);
          data.next();
          processedCount++;
          if (processedCount % 10 === 0) {
            await new Promise((resolve) => setImmediate(resolve));
          }
        }
      }
      _transform(chunk, encoding, next) {
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        if (!chunk || !chunk.length) {
          return next();
        }
        this.readBytesCounter += chunk.length;
        if (this.options.logRaw) {
          this.log.trace({
            src: "s",
            msg: "read from socket",
            data: chunk.toString("base64"),
            compress: !!this.compress,
            secure: !!this.secureConnection,
            cid: this.cid
          });
        }
        if (chunk && chunk.length) {
          this.inputQueue.push({ chunk, next });
        }
        if (!this.processingInput) {
          this.processingInput = true;
          this.processInput().catch((err) => this.emit("error", err)).finally(() => this.processingInput = false);
        }
      }
      _flush(next) {
        next();
      }
    };
    module.exports.ImapStream = ImapStream;
  }
});

// ../node_modules/imapflow/lib/handler/imap-formal-syntax.js
var require_imap_formal_syntax = __commonJS({
  "../node_modules/imapflow/lib/handler/imap-formal-syntax.js"(exports, module) {
    "use strict";
    function expandRange(start, end) {
      let chars = [];
      for (let i = start; i <= end; i++) {
        chars.push(i);
      }
      return String.fromCharCode(...chars);
    }
    function excludeChars(source, exclude) {
      let sourceArr = Array.prototype.slice.call(source);
      for (let i = sourceArr.length - 1; i >= 0; i--) {
        if (exclude.indexOf(sourceArr[i]) >= 0) {
          sourceArr.splice(i, 1);
        }
      }
      return sourceArr.join("");
    }
    module.exports = {
      CHAR() {
        let value = expandRange(1, 127);
        this.CHAR = function() {
          return value;
        };
        return value;
      },
      CHAR8() {
        let value = expandRange(1, 255);
        this.CHAR8 = function() {
          return value;
        };
        return value;
      },
      SP() {
        return " ";
      },
      CTL() {
        let value = expandRange(0, 31) + "";
        this.CTL = function() {
          return value;
        };
        return value;
      },
      DQUOTE() {
        return '"';
      },
      ALPHA() {
        let value = expandRange(65, 90) + expandRange(97, 122);
        this.ALPHA = function() {
          return value;
        };
        return value;
      },
      DIGIT() {
        let value = expandRange(48, 57);
        this.DIGIT = function() {
          return value;
        };
        return value;
      },
      "ATOM-CHAR"() {
        let value = excludeChars(this.CHAR(), this["atom-specials"]());
        this["ATOM-CHAR"] = function() {
          return value;
        };
        return value;
      },
      "ASTRING-CHAR"() {
        let value = this["ATOM-CHAR"]() + this["resp-specials"]();
        this["ASTRING-CHAR"] = function() {
          return value;
        };
        return value;
      },
      "TEXT-CHAR"() {
        let value = excludeChars(this.CHAR(), "\r\n");
        this["TEXT-CHAR"] = function() {
          return value;
        };
        return value;
      },
      "atom-specials"() {
        let value = "(){" + this.SP() + this.CTL() + this["list-wildcards"]() + this["quoted-specials"]() + this["resp-specials"]();
        this["atom-specials"] = function() {
          return value;
        };
        return value;
      },
      "list-wildcards"() {
        return "%*";
      },
      "quoted-specials"() {
        let value = this.DQUOTE() + "\\";
        this["quoted-specials"] = function() {
          return value;
        };
        return value;
      },
      "resp-specials"() {
        return "]";
      },
      tag() {
        let value = excludeChars(this["ASTRING-CHAR"](), "+");
        this.tag = function() {
          return value;
        };
        return value;
      },
      command() {
        let value = this.ALPHA() + this.DIGIT() + "-";
        this.command = function() {
          return value;
        };
        return value;
      },
      verify(str, allowedChars) {
        for (let i = 0, len = str.length; i < len; i++) {
          if (allowedChars.indexOf(str.charAt(i)) < 0) {
            return i;
          }
        }
        return -1;
      }
    };
  }
});

// ../node_modules/imapflow/lib/handler/token-parser.js
var require_token_parser = __commonJS({
  "../node_modules/imapflow/lib/handler/token-parser.js"(exports, module) {
    "use strict";
    var imapFormalSyntax = require_imap_formal_syntax();
    var STATE_ATOM = 1;
    var STATE_LITERAL = 2;
    var STATE_NORMAL = 3;
    var STATE_PARTIAL = 4;
    var STATE_SEQUENCE = 5;
    var STATE_STRING = 6;
    var STATE_TEXT = 7;
    var RE_DIGITS = /^\d+$/;
    var RE_SINGLE_DIGIT = /^\d$/;
    var MAX_NODE_DEPTH = 25;
    var TokenParser = class {
      constructor(parent, startPos, str, options) {
        this.str = (str || "").toString();
        this.options = options || {};
        this.parent = parent;
        this.tree = this.currentNode = this.createNode();
        this.pos = startPos || 0;
        this.currentNode.type = "TREE";
        this.state = STATE_NORMAL;
      }
      async getAttributes() {
        await this.processString();
        const attributes = [];
        let branch = attributes;
        let walk = async (node) => {
          let curBranch = branch;
          let elm;
          let partial;
          if (!node.isClosed && node.type === "SEQUENCE" && node.value === "*") {
            node.isClosed = true;
            node.type = "ATOM";
          }
          if (!node.isClosed) {
            let error = new Error(`Unexpected end of input at position ${this.pos + this.str.length - 1} [E9]`);
            error.code = "ParserError9";
            error.parserContext = { input: this.str, pos: this.pos + this.str.length - 1 };
            throw error;
          }
          let type = (node.type || "").toString().toUpperCase();
          switch (type) {
            case "LITERAL":
            case "STRING":
            case "SEQUENCE":
              elm = {
                type: node.type.toUpperCase(),
                value: node.value
              };
              branch.push(elm);
              break;
            case "ATOM":
              if (node.value.toUpperCase() === "NIL") {
                branch.push(null);
                break;
              }
              elm = {
                type: node.type.toUpperCase(),
                value: node.value
              };
              branch.push(elm);
              break;
            case "SECTION":
              branch = branch[branch.length - 1].section = [];
              break;
            case "LIST":
              elm = [];
              branch.push(elm);
              branch = elm;
              break;
            case "PARTIAL":
              partial = node.value.split(".").map(Number);
              branch[branch.length - 1].partial = partial;
              break;
          }
          for (let childNode of node.childNodes) {
            await walk(childNode);
          }
          branch = curBranch;
        };
        await walk(this.tree);
        return attributes;
      }
      createNode(parentNode, startPos) {
        let node = {
          childNodes: [],
          type: false,
          value: "",
          isClosed: true
        };
        if (parentNode) {
          node.parentNode = parentNode;
          node.depth = parentNode.depth + 1;
        } else {
          node.depth = 0;
        }
        if (node.depth > MAX_NODE_DEPTH) {
          let error = new Error("Too much nesting in IMAP string");
          error.code = "MAX_IMAP_NESTING_REACHED";
          error._imapStr = this.str;
          throw error;
        }
        if (typeof startPos === "number") {
          node.startPos = startPos;
        }
        if (parentNode) {
          parentNode.childNodes.push(node);
        }
        return node;
      }
      async processString() {
        let chr, i, len;
        const checkSP = () => {
          while (this.str.charAt(i + 1) === " ") {
            i++;
          }
        };
        for (i = 0, len = this.str.length; i < len; i++) {
          chr = this.str.charAt(i);
          switch (this.state) {
            case STATE_NORMAL:
              switch (chr) {
                case '"':
                  this.currentNode = this.createNode(this.currentNode, this.pos + i);
                  this.currentNode.type = "string";
                  this.state = STATE_STRING;
                  this.currentNode.isClosed = false;
                  break;
                case "(":
                  this.currentNode = this.createNode(this.currentNode, this.pos + i);
                  this.currentNode.type = "LIST";
                  this.currentNode.isClosed = false;
                  break;
                case ")":
                  if (this.currentNode.type !== "LIST") {
                    let error = new Error(`Unexpected list terminator ) at position ${this.pos + i} [E10]`);
                    error.code = "ParserError10";
                    error.parserContext = { input: this.str, pos: this.pos + i, chr };
                    throw error;
                  }
                  this.currentNode.isClosed = true;
                  this.currentNode.endPos = this.pos + i;
                  this.currentNode = this.currentNode.parentNode;
                  checkSP();
                  break;
                case "]":
                  if (this.currentNode.type !== "SECTION") {
                    let error = new Error(`Unexpected section terminator ] at position ${this.pos + i} [E11]`);
                    error.code = "ParserError11";
                    error.parserContext = { input: this.str, pos: this.pos + i, chr };
                    throw error;
                  }
                  this.currentNode.isClosed = true;
                  this.currentNode.endPos = this.pos + i;
                  this.currentNode = this.currentNode.parentNode;
                  checkSP();
                  break;
                case "<":
                  if (this.str.charAt(i - 1) !== "]") {
                    this.currentNode = this.createNode(this.currentNode, this.pos + i);
                    this.currentNode.type = "ATOM";
                    this.currentNode.value = chr;
                    this.state = STATE_ATOM;
                  } else {
                    this.currentNode = this.createNode(this.currentNode, this.pos + i);
                    this.currentNode.type = "PARTIAL";
                    this.state = STATE_PARTIAL;
                    this.currentNode.isClosed = false;
                  }
                  break;
                case "~": {
                  let nextChr = this.str.charAt(i + 1);
                  if (nextChr !== "{") {
                    if (imapFormalSyntax["ATOM-CHAR"]().indexOf(nextChr) >= 0) {
                      this.currentNode = this.createNode(this.currentNode, this.pos + i);
                      this.currentNode.type = "ATOM";
                      this.currentNode.value = chr;
                      this.state = STATE_ATOM;
                      break;
                    }
                    let error = new Error(`Unexpected literal8 marker at position ${this.pos + i} [E12]`);
                    error.code = "ParserError12";
                    error.parserContext = { input: this.str, pos: this.pos + i, chr };
                    throw error;
                  }
                  this.expectedLiteralType = "literal8";
                  break;
                }
                case "{":
                  this.currentNode = this.createNode(this.currentNode, this.pos + i);
                  this.currentNode.type = "LITERAL";
                  this.currentNode.literalType = this.expectedLiteralType || "literal";
                  this.expectedLiteralType = false;
                  this.state = STATE_LITERAL;
                  this.currentNode.isClosed = false;
                  break;
                case "*":
                  this.currentNode = this.createNode(this.currentNode, this.pos + i);
                  this.currentNode.type = "SEQUENCE";
                  this.currentNode.value = chr;
                  this.currentNode.isClosed = false;
                  this.state = STATE_SEQUENCE;
                  break;
                case " ":
                  break;
                case "[":
                  if (["OK", "NO", "BAD", "BYE", "PREAUTH"].includes(this.parent.command.toUpperCase()) && this.currentNode === this.tree) {
                    this.currentNode.endPos = this.pos + i;
                    this.currentNode = this.createNode(this.currentNode, this.pos + i);
                    this.currentNode.type = "ATOM";
                    this.currentNode = this.createNode(this.currentNode, this.pos + i);
                    this.currentNode.type = "SECTION";
                    this.currentNode.isClosed = false;
                    this.state = STATE_NORMAL;
                    if (this.str.substr(i + 1, 9).toUpperCase() === "REFERRAL ") {
                      this.currentNode = this.createNode(this.currentNode, this.pos + i + 1);
                      this.currentNode.type = "ATOM";
                      this.currentNode.endPos = this.pos + i + 8;
                      this.currentNode.value = "REFERRAL";
                      this.currentNode = this.currentNode.parentNode;
                      this.currentNode = this.createNode(this.currentNode, this.pos + i + 10);
                      this.currentNode.type = "ATOM";
                      i = this.str.indexOf("]", i + 10);
                      this.currentNode.endPos = this.pos + i - 1;
                      this.currentNode.value = this.str.substring(this.currentNode.startPos - this.pos, this.currentNode.endPos - this.pos + 1);
                      this.currentNode = this.currentNode.parentNode;
                      this.currentNode.isClosed = true;
                      this.currentNode = this.currentNode.parentNode;
                      checkSP();
                    }
                    break;
                  }
                default:
                  if (imapFormalSyntax["ATOM-CHAR"]().indexOf(chr) < 0 && chr !== "\\" && chr !== "%" && chr.charCodeAt(0) < 128) {
                    let error = new Error(`Unexpected char at position ${this.pos + i} [E13: ${JSON.stringify(chr)}]`);
                    error.code = "ParserError13";
                    error.parserContext = { input: this.str, pos: this.pos + i, chr };
                    throw error;
                  }
                  this.currentNode = this.createNode(this.currentNode, this.pos + i);
                  this.currentNode.type = "ATOM";
                  this.currentNode.value = chr;
                  this.state = STATE_ATOM;
                  break;
              }
              break;
            case STATE_ATOM:
              if (chr === " ") {
                this.currentNode.endPos = this.pos + i - 1;
                this.currentNode = this.currentNode.parentNode;
                this.state = STATE_NORMAL;
                break;
              }
              if (this.currentNode.parentNode && (chr === ")" && this.currentNode.parentNode.type === "LIST" || chr === "]" && this.currentNode.parentNode.type === "SECTION")) {
                this.currentNode.endPos = this.pos + i - 1;
                this.currentNode = this.currentNode.parentNode;
                this.currentNode.isClosed = true;
                this.currentNode.endPos = this.pos + i;
                this.currentNode = this.currentNode.parentNode;
                this.state = STATE_NORMAL;
                checkSP();
                break;
              }
              if ((chr === "," || chr === ":") && RE_DIGITS.test(this.currentNode.value)) {
                this.currentNode.type = "SEQUENCE";
                this.currentNode.isClosed = true;
                this.state = STATE_SEQUENCE;
              }
              if (chr === "[" && ["BODY", "BODY.PEEK", "BINARY", "BINARY.PEEK"].indexOf(this.currentNode.value.toUpperCase()) >= 0) {
                this.currentNode.endPos = this.pos + i;
                this.currentNode = this.createNode(this.currentNode.parentNode, this.pos + i);
                this.currentNode.type = "SECTION";
                this.currentNode.isClosed = false;
                this.state = STATE_NORMAL;
                break;
              }
              if (imapFormalSyntax["ATOM-CHAR"]().indexOf(chr) < 0 && chr.charCodeAt(0) < 128 && // allow 8bit (presumably unicode) bytes
              chr !== "]" && !(chr === "*" && this.currentNode.value === "\\") && (!this.parent || !this.parent.command || !["NO", "BAD", "OK"].includes(this.parent.command))) {
                let error = new Error(`Unexpected char at position ${this.pos + i} [E16: ${JSON.stringify(chr)}]`);
                error.code = "ParserError16";
                error.parserContext = { input: this.str, pos: this.pos + i, chr };
                throw error;
              } else if (this.currentNode.value === "\\*") {
                let error = new Error(`Unexpected char at position ${this.pos + i} [E17: ${JSON.stringify(chr)}]`);
                error.code = "ParserError17";
                error.parserContext = { input: this.str, pos: this.pos + i, chr };
                throw error;
              }
              this.currentNode.value += chr;
              break;
            case STATE_STRING:
              if (chr === '"') {
                this.currentNode.endPos = this.pos + i;
                this.currentNode.isClosed = true;
                this.currentNode = this.currentNode.parentNode;
                this.state = STATE_NORMAL;
                checkSP();
                break;
              }
              if (chr === "\\") {
                i++;
                if (i >= len) {
                  let error = new Error(`Unexpected end of input at position ${this.pos + i} [E18]`);
                  error.code = "ParserError18";
                  error.parserContext = { input: this.str, pos: this.pos + i };
                  throw error;
                }
                chr = this.str.charAt(i);
              }
              this.currentNode.value += chr;
              break;
            case STATE_PARTIAL:
              if (chr === ">") {
                if (this.currentNode.value.at(-1) === ".") {
                  let error = new Error(`Unexpected end of partial at position ${this.pos + i} [E19]`);
                  error.code = "ParserError19";
                  error.parserContext = { input: this.str, pos: this.pos + i, chr };
                  throw error;
                }
                this.currentNode.endPos = this.pos + i;
                this.currentNode.isClosed = true;
                this.currentNode = this.currentNode.parentNode;
                this.state = STATE_NORMAL;
                checkSP();
                break;
              }
              if (chr === "." && (!this.currentNode.value.length || this.currentNode.value.match(/\./))) {
                let error = new Error(`Unexpected partial separator . at position ${this.pos + i} [E20]`);
                error.code = "ParserError20";
                error.parserContext = { input: this.str, pos: this.pos + i, chr };
                throw error;
              }
              if (imapFormalSyntax.DIGIT().indexOf(chr) < 0 && chr !== ".") {
                let error = new Error(`Unexpected char at position ${this.pos + i} [E21: ${JSON.stringify(chr)}]`);
                error.code = "ParserError21";
                error.parserContext = { input: this.str, pos: this.pos + i, chr };
                throw error;
              }
              if (this.currentNode.value.match(/^0$|\.0$/) && chr !== ".") {
                let error = new Error(`Invalid partial at position ${this.pos + i} [E22: ${JSON.stringify(chr)}]`);
                error.code = "ParserError22";
                error.parserContext = { input: this.str, pos: this.pos + i, chr };
                throw error;
              }
              this.currentNode.value += chr;
              break;
            case STATE_LITERAL:
              if (this.currentNode.started) {
                this.currentNode.chBuffer[this.currentNode.chPos++] = chr.charCodeAt(0);
                if (this.currentNode.chPos >= this.currentNode.literalLength) {
                  this.currentNode.endPos = this.pos + i;
                  this.currentNode.isClosed = true;
                  this.currentNode.value = this.currentNode.chBuffer.toString("binary");
                  this.currentNode.chBuffer = Buffer.alloc(0);
                  this.currentNode = this.currentNode.parentNode;
                  this.state = STATE_NORMAL;
                  checkSP();
                }
                break;
              }
              if (chr === "+" && this.options.literalPlus) {
                this.currentNode.literalPlus = true;
                break;
              }
              if (chr === "}") {
                if (!("literalLength" in this.currentNode)) {
                  let error = new Error(`Unexpected literal prefix end char } at position ${this.pos + i} [E23]`);
                  error.code = "ParserError23";
                  error.parserContext = { input: this.str, pos: this.pos + i, chr };
                  throw error;
                }
                if (this.str.charAt(i + 1) === "\n") {
                  i++;
                } else if (this.str.charAt(i + 1) === "\r" && this.str.charAt(i + 2) === "\n") {
                  i += 2;
                } else {
                  let error = new Error(`Unexpected char at position ${this.pos + i} [E24: ${JSON.stringify(chr)}]`);
                  error.code = "ParserError24";
                  error.parserContext = { input: this.str, pos: this.pos + i, chr };
                  throw error;
                }
                this.currentNode.literalLength = Number(this.currentNode.literalLength);
                if (!this.currentNode.literalLength) {
                  this.currentNode.endPos = this.pos + i;
                  this.currentNode.isClosed = true;
                  this.currentNode = this.currentNode.parentNode;
                  this.state = STATE_NORMAL;
                  checkSP();
                } else if (this.options.literals) {
                  this.currentNode.value = this.options.literals.shift();
                  this.currentNode.endPos = this.pos + i + this.currentNode.value.length;
                  this.currentNode.started = false;
                  this.currentNode.isClosed = true;
                  this.currentNode = this.currentNode.parentNode;
                  this.state = STATE_NORMAL;
                  checkSP();
                } else {
                  this.currentNode.started = true;
                  this.currentNode.chBuffer = Buffer.alloc(this.currentNode.literalLength);
                  this.currentNode.chPos = 0;
                }
                break;
              }
              if (imapFormalSyntax.DIGIT().indexOf(chr) < 0) {
                let error = new Error(`Unexpected char at position ${this.pos + i} [E25: ${JSON.stringify(chr)}]`);
                error.code = "ParserError25";
                error.parserContext = { input: this.str, pos: this.pos + i, chr };
                throw error;
              }
              if (this.currentNode.literalLength === "0") {
                let error = new Error(`Invalid literal at position ${this.pos + i} [E26]`);
                error.code = "ParserError26";
                error.parserContext = { input: this.str, pos: this.pos + i, chr };
                throw error;
              }
              this.currentNode.literalLength = (this.currentNode.literalLength || "") + chr;
              break;
            case STATE_SEQUENCE:
              if (chr === " ") {
                if (!RE_SINGLE_DIGIT.test(this.currentNode.value.at(-1)) && this.currentNode.value.at(-1) !== "*") {
                  let error = new Error(`Unexpected whitespace at position ${this.pos + i} [E27]`);
                  error.code = "ParserError27";
                  error.parserContext = { input: this.str, pos: this.pos + i, chr };
                  throw error;
                }
                if (this.currentNode.value !== "*" && this.currentNode.value.at(-1) === "*" && this.currentNode.value.at(-2) !== ":") {
                  let error = new Error(`Unexpected whitespace at position ${this.pos + i} [E28]`);
                  error.code = "ParserError28";
                  error.parserContext = { input: this.str, pos: this.pos + i, chr };
                  throw error;
                }
                this.currentNode.isClosed = true;
                this.currentNode.endPos = this.pos + i - 1;
                this.currentNode = this.currentNode.parentNode;
                this.state = STATE_NORMAL;
                break;
              } else if (this.currentNode.parentNode && chr === "]" && this.currentNode.parentNode.type === "SECTION") {
                this.currentNode.endPos = this.pos + i - 1;
                this.currentNode = this.currentNode.parentNode;
                this.currentNode.isClosed = true;
                this.currentNode.endPos = this.pos + i;
                this.currentNode = this.currentNode.parentNode;
                this.state = STATE_NORMAL;
                checkSP();
                break;
              }
              if (chr === ":") {
                if (!RE_SINGLE_DIGIT.test(this.currentNode.value.at(-1)) && this.currentNode.value.at(-1) !== "*") {
                  let error = new Error(`Unexpected range separator : at position ${this.pos + i} [E29]`);
                  error.code = "ParserError29";
                  error.parserContext = { input: this.str, pos: this.pos + i, chr };
                  throw error;
                }
              } else if (chr === "*") {
                if ([",", ":"].indexOf(this.currentNode.value.at(-1)) < 0) {
                  let error = new Error(`Unexpected range wildcard at position ${this.pos + i} [E30]`);
                  error.code = "ParserError30";
                  error.parserContext = { input: this.str, pos: this.pos + i, chr };
                  throw error;
                }
              } else if (chr === ",") {
                if (!RE_SINGLE_DIGIT.test(this.currentNode.value.at(-1)) && this.currentNode.value.at(-1) !== "*") {
                  let error = new Error(`Unexpected sequence separator , at position ${this.pos + i} [E31]`);
                  error.code = "ParserError31";
                  error.parserContext = { input: this.str, pos: this.pos + i, chr };
                  throw error;
                }
                if (this.currentNode.value.at(-1) === "*" && this.currentNode.value.at(-2) !== ":") {
                  let error = new Error(`Unexpected sequence separator , at position ${this.pos + i} [E32]`);
                  error.code = "ParserError32";
                  error.parserContext = { input: this.str, pos: this.pos + i, chr };
                  throw error;
                }
              } else if (!RE_SINGLE_DIGIT.test(chr)) {
                let error = new Error(`Unexpected char at position ${this.pos + i} [E33: ${JSON.stringify(chr)}]`);
                error.code = "ParserError33";
                error.parserContext = { input: this.str, pos: this.pos + i, chr };
                throw error;
              }
              if (RE_SINGLE_DIGIT.test(chr) && this.currentNode.value.at(-1) === "*") {
                let error = new Error(`Unexpected number at position ${this.pos + i} [E34: ${JSON.stringify(chr)}]`);
                error.code = "ParserError34";
                error.parserContext = { input: this.str, pos: this.pos + i, chr };
                throw error;
              }
              this.currentNode.value += chr;
              break;
            case STATE_TEXT:
              this.currentNode.value += chr;
              break;
          }
        }
      }
    };
    module.exports.TokenParser = TokenParser;
  }
});

// ../node_modules/imapflow/lib/handler/parser-instance.js
var require_parser_instance = __commonJS({
  "../node_modules/imapflow/lib/handler/parser-instance.js"(exports, module) {
    "use strict";
    var imapFormalSyntax = require_imap_formal_syntax();
    var { TokenParser } = require_token_parser();
    var ParserInstance = class {
      constructor(input, options) {
        this.input = (input || "").toString();
        this.options = options || {};
        this.remainder = this.input;
        this.pos = 0;
      }
      async getTag() {
        if (!this.tag) {
          this.tag = await this.getElement(imapFormalSyntax.tag() + "*+", true);
        }
        return this.tag;
      }
      async getCommand() {
        if (this.tag === "+") {
          this.humanReadable = this.remainder.trim();
          this.remainder = "";
          return "";
        }
        if (!this.command) {
          this.command = await this.getElement(imapFormalSyntax.command());
        }
        switch ((this.command || "").toString().toUpperCase()) {
          case "OK":
          case "NO":
          case "BAD":
          case "PREAUTH":
          case "BYE":
            {
              let match = this.remainder.match(/^\s+\[/);
              if (match) {
                let nesting = 1;
                for (let i = match[0].length; i <= this.remainder.length; i++) {
                  let c = this.remainder[i];
                  if (c === "[") {
                    nesting++;
                  } else if (c === "]") {
                    nesting--;
                  }
                  if (!nesting) {
                    this.humanReadable = this.remainder.substring(i + 1).trim();
                    this.remainder = this.remainder.substring(0, i + 1);
                    break;
                  }
                }
              } else {
                this.humanReadable = this.remainder.trim();
                this.remainder = "";
              }
            }
            break;
        }
        return this.command;
      }
      async getElement(syntax) {
        let match, element, errPos;
        if (this.remainder.match(/^\s/)) {
          let error = new Error(`Unexpected whitespace at position ${this.pos} [E1]`);
          error.code = "ParserError1";
          error.parserContext = { input: this.input, pos: this.pos };
          throw error;
        }
        if (match = this.remainder.match(/^\s*[^\s]+(?=\s|$)/)) {
          element = match[0];
          if ((errPos = imapFormalSyntax.verify(element, syntax)) >= 0) {
            if (this.tag === "Server" && element === "Unavailable.") {
              let error2 = new Error(`Server returned an error: ${this.input}`);
              error2.code = "ParserErrorExchange";
              error2.parserContext = {
                input: this.input,
                element,
                pos: this.pos,
                value: {
                  tag: "*",
                  command: "BAD",
                  attributes: [{ type: "TEXT", value: this.input }]
                }
              };
              throw error2;
            }
            let error = new Error(`Unexpected char at position ${this.pos + errPos} [E2: ${JSON.stringify(element.charAt(errPos))}]`);
            error.code = "ParserError2";
            error.parserContext = { input: this.input, element, pos: this.pos };
            throw error;
          }
        } else {
          let error = new Error(`Unexpected end of input at position ${this.pos} [E3]`);
          error.code = "ParserError3";
          error.parserContext = { input: this.input, pos: this.pos };
          throw error;
        }
        this.pos += match[0].length;
        this.remainder = this.remainder.substr(match[0].length);
        return element;
      }
      async getSpace() {
        if (!this.remainder.length) {
          if (this.tag === "+" && this.pos === 1) {
            return;
          }
          let error = new Error(`Unexpected end of input at position ${this.pos} [E4]`);
          error.code = "ParserError4";
          error.parserContext = { input: this.input, pos: this.pos };
          throw error;
        }
        if (imapFormalSyntax.verify(this.remainder.charAt(0), imapFormalSyntax.SP()) >= 0) {
          let error = new Error(`Unexpected char at position ${this.pos} [E5: ${JSON.stringify(this.remainder.charAt(0))}]`);
          error.code = "ParserError5";
          error.parserContext = { input: this.input, element: this.remainder, pos: this.pos };
          throw error;
        }
        this.pos++;
        this.remainder = this.remainder.substr(1);
      }
      async getAttributes() {
        if (!this.remainder.length) {
          let error = new Error(`Unexpected end of input at position ${this.pos} [E6]`);
          error.code = "ParserError6";
          error.parserContext = { input: this.input, pos: this.pos };
          throw error;
        }
        if (this.remainder.match(/^\s/)) {
          let error = new Error(`Unexpected whitespace at position ${this.pos} [E7]`);
          error.code = "ParserError7";
          error.parserContext = { input: this.input, element: this.remainder, pos: this.pos };
          throw error;
        }
        const tokenParser = new TokenParser(this, this.pos, this.remainder, this.options);
        return await tokenParser.getAttributes();
      }
    };
    module.exports.ParserInstance = ParserInstance;
  }
});

// ../node_modules/imapflow/lib/handler/imap-parser.js
var require_imap_parser = __commonJS({
  "../node_modules/imapflow/lib/handler/imap-parser.js"(exports, module) {
    "use strict";
    var imapFormalSyntax = require_imap_formal_syntax();
    var { ParserInstance } = require_parser_instance();
    module.exports = async (command, options) => {
      options = options || {};
      let nullBytesRemoved = 0;
      if (command[0] === 0) {
        let firstNonNull = -1;
        for (let i = 0; i < command.length; i++) {
          if (command[i] !== 0) {
            firstNonNull = i;
            break;
          }
        }
        if (firstNonNull === -1) {
          return { tag: "*", command: "BAD", attributes: [] };
        }
        command = command.slice(firstNonNull);
        nullBytesRemoved = firstNonNull;
      }
      const parser = new ParserInstance(command, options);
      const response = {};
      try {
        response.tag = await parser.getTag();
        await parser.getSpace();
        response.command = await parser.getCommand();
        if (nullBytesRemoved) {
          response.nullBytesRemoved = nullBytesRemoved;
        }
        if (["UID", "AUTHENTICATE"].indexOf((response.command || "").toUpperCase()) >= 0) {
          await parser.getSpace();
          response.command += " " + await parser.getElement(imapFormalSyntax.command());
        }
        if (parser.remainder.trim().length) {
          await parser.getSpace();
          response.attributes = await parser.getAttributes();
        }
        if (parser.humanReadable) {
          response.attributes = (response.attributes || []).concat({
            type: "TEXT",
            value: parser.humanReadable
          });
        }
      } catch (err) {
        if (err.code === "ParserErrorExchange" && err.parserContext && err.parserContext.value) {
          return err.parserContext.value;
        }
        throw err;
      }
      return response;
    };
  }
});

// ../node_modules/imapflow/lib/handler/imap-compiler.js
var require_imap_compiler = __commonJS({
  "../node_modules/imapflow/lib/handler/imap-compiler.js"(exports, module) {
    "use strict";
    var imapFormalSyntax = require_imap_formal_syntax();
    var formatRespEntry = (entry, returnEmpty) => {
      if (typeof entry === "string") {
        return Buffer.from(entry);
      }
      if (typeof entry === "number") {
        return Buffer.from(entry.toString());
      }
      if (Buffer.isBuffer(entry)) {
        return entry;
      }
      if (returnEmpty) {
        return null;
      }
      return Buffer.alloc(0);
    };
    module.exports = async (response, options) => {
      let { asArray, isLogging, literalPlus, literalMinus } = options || {};
      const respParts = [];
      let resp = [].concat(formatRespEntry(response.tag, true) || []).concat(response.command ? formatRespEntry(" " + response.command) : []);
      let val;
      let lastType;
      let walk = async (node, options2) => {
        options2 = options2 || {};
        let lastRespEntry = resp.length && resp[resp.length - 1];
        let lastRespByte = lastRespEntry && lastRespEntry.length && lastRespEntry[lastRespEntry.length - 1] || "";
        if (typeof lastRespByte === "number") {
          lastRespByte = String.fromCharCode(lastRespByte);
        }
        if (lastType === "LITERAL" || !["(", "<", "["].includes(lastRespByte) && resp.length) {
          if (options2.subArray) {
          } else {
            resp.push(formatRespEntry(" "));
          }
        }
        if (node && node.buffer && !Buffer.isBuffer(node)) {
          node = node.buffer;
        }
        if (Array.isArray(node)) {
          lastType = "LIST";
          resp.push(formatRespEntry("("));
          let subArray = node.length > 1 && Array.isArray(node[0]);
          for (let child of node) {
            if (subArray && !Array.isArray(child)) {
              subArray = false;
            }
            await walk(child, { subArray });
          }
          resp.push(formatRespEntry(")"));
          return;
        }
        if (!node && typeof node !== "string" && typeof node !== "number" && !Buffer.isBuffer(node)) {
          resp.push(formatRespEntry("NIL"));
          return;
        }
        if (typeof node === "string" || Buffer.isBuffer(node)) {
          if (isLogging && node.length > 100) {
            resp.push(formatRespEntry('"(* ' + node.length + 'B string *)"'));
          } else {
            resp.push(formatRespEntry(JSON.stringify(node.toString())));
          }
          return;
        }
        if (typeof node === "number") {
          resp.push(formatRespEntry(Math.round(node) || 0));
          return;
        }
        lastType = node.type;
        if (isLogging && node.sensitive) {
          resp.push(formatRespEntry('"(* value hidden *)"'));
          return;
        }
        switch (node.type.toUpperCase()) {
          case "LITERAL":
            if (isLogging) {
              resp.push(formatRespEntry('"(* ' + node.value.length + 'B literal *)"'));
            } else {
              let literalLength = !node.value ? 0 : Math.max(node.value.length, 0);
              let canAppend = !asArray || literalPlus || literalMinus && literalLength <= 4096;
              let usePlus = canAppend && (literalMinus || literalPlus);
              resp.push(formatRespEntry(`${node.isLiteral8 ? "~" : ""}{${literalLength}${usePlus ? "+" : ""}}\r
`));
              if (canAppend) {
                if (node.value && node.value.length) {
                  resp.push(formatRespEntry(node.value));
                }
              } else {
                respParts.push(resp);
                resp = [].concat(formatRespEntry(node.value, true) || []);
              }
            }
            break;
          case "STRING":
            if (isLogging && node.value.length > 100) {
              resp.push(formatRespEntry('"(* ' + node.value.length + 'B string *)"'));
            } else {
              resp.push(formatRespEntry(JSON.stringify((node.value || "").toString())));
            }
            break;
          case "TEXT":
          case "SEQUENCE":
            if (node.value) {
              resp.push(formatRespEntry(node.value));
            }
            break;
          case "NUMBER":
            resp.push(formatRespEntry(node.value || 0));
            break;
          case "ATOM":
          case "SECTION":
            val = (node.value || "").toString();
            if (!node.section || val) {
              if (node.value === "" || imapFormalSyntax.verify(val.charAt(0) === "\\" ? val.substr(1) : val, imapFormalSyntax["ATOM-CHAR"]()) >= 0) {
                val = JSON.stringify(val);
              }
              resp.push(formatRespEntry(val));
            }
            if (node.section) {
              resp.push(formatRespEntry("["));
              for (let child of node.section) {
                await walk(child);
              }
              resp.push(formatRespEntry("]"));
            }
            if (node.partial) {
              resp.push(formatRespEntry(`<${node.partial.join(".")}>`));
            }
            break;
        }
      };
      if (response.attributes) {
        let attributes = Array.isArray(response.attributes) ? response.attributes : [].concat(response.attributes);
        for (let child of attributes) {
          await walk(child);
        }
      }
      if (resp.length) {
        respParts.push(resp);
      }
      for (let i = 0; i < respParts.length; i++) {
        respParts[i] = Buffer.concat(respParts[i]);
      }
      return asArray ? respParts : respParts.flatMap((entry) => entry);
    };
  }
});

// ../node_modules/imapflow/lib/handler/imap-handler.js
var require_imap_handler = __commonJS({
  "../node_modules/imapflow/lib/handler/imap-handler.js"(exports, module) {
    "use strict";
    var parser = require_imap_parser();
    var compiler = require_imap_compiler();
    module.exports = {
      parser,
      compiler
    };
  }
});

// ../node_modules/imapflow/package.json
var require_package = __commonJS({
  "../node_modules/imapflow/package.json"(exports, module) {
    module.exports = {
      name: "imapflow",
      version: "1.1.0",
      description: "IMAP Client for Node",
      main: "lib/imap-flow.js",
      types: "lib/imap-flow.d.ts",
      scripts: {
        test: "grunt",
        prepare: "npm run build",
        docs: "rm -rf docs && mkdir -p docs && jsdoc lib/imap-flow.js -c jsdoc.json -R README.md --destination docs/ && cp assets/favicon.ico docs",
        build: "npm run docs",
        st: "npm run docs && st -d docs -i index.html",
        update: "rm -rf node_modules package-lock.json && ncu -u && npm install",
        format: 'prettier --write "**/*.{js,json,md,yml,yaml}" --ignore-path .prettierignore',
        lint: "eslint ."
      },
      repository: {
        type: "git",
        url: "git+https://github.com/postalsys/imapflow.git"
      },
      keywords: [
        "imap",
        "email",
        "mail"
      ],
      author: "Postal Systems O",
      license: "MIT",
      bugs: {
        url: "https://github.com/postalsys/imapflow/issues"
      },
      homepage: "https://imapflow.com/",
      devDependencies: {
        "@babel/eslint-parser": "7.28.4",
        "@babel/eslint-plugin": "7.27.1",
        "@babel/plugin-syntax-class-properties": "7.12.13",
        "@babel/preset-env": "7.28.3",
        "@eslint/eslintrc": "3.3.1",
        "@eslint/js": "9.19.0",
        "@types/node": "24.9.1",
        eslint: "9.19.0",
        "eslint-config-nodemailer": "1.2.0",
        "eslint-config-prettier": "10.1.8",
        grunt: "1.6.1",
        "grunt-cli": "1.5.0",
        "grunt-contrib-nodeunit": "5.0.0",
        "grunt-eslint": "24.3.0",
        "imapflow-jsdoc-template": "3.4.0-imapflow.3",
        jsdoc: "4.0.4",
        prettier: "3.6.2",
        st: "3.0.3",
        typescript: "5.9.3"
      },
      dependencies: {
        "encoding-japanese": "2.2.0",
        "iconv-lite": "0.7.0",
        libbase64: "1.3.0",
        libmime: "5.3.7",
        libqp: "2.1.1",
        "@zone-eu/mailsplit": "5.4.7",
        nodemailer: "7.0.10",
        pino: "10.1.0",
        socks: "2.8.7"
      }
    };
  }
});

// ../node_modules/imapflow/node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js
var require_http_proxy_client = __commonJS({
  "../node_modules/imapflow/node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js"(exports, module) {
    "use strict";
    var net = require_net();
    var tls = require_tls();
    var urllib = require_url();
    function httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {
      let proxy = urllib.parse(proxyUrl);
      let options;
      let connect;
      let socket;
      options = {
        host: proxy.hostname,
        port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === "https:" ? 443 : 80
      };
      if (proxy.protocol === "https:") {
        options.rejectUnauthorized = false;
        connect = tls.connect.bind(tls);
      } else {
        connect = net.connect.bind(net);
      }
      let finished = false;
      let tempSocketErr = (err) => {
        if (finished) {
          return;
        }
        finished = true;
        try {
          socket.destroy();
        } catch (_E) {
        }
        callback(err);
      };
      let timeoutErr = () => {
        let err = new Error("Proxy socket timed out");
        err.code = "ETIMEDOUT";
        tempSocketErr(err);
      };
      socket = connect(options, () => {
        if (finished) {
          return;
        }
        let reqHeaders = {
          Host: destinationHost + ":" + destinationPort,
          Connection: "close"
        };
        if (proxy.auth) {
          reqHeaders["Proxy-Authorization"] = "Basic " + Buffer.from(proxy.auth).toString("base64");
        }
        socket.write(
          // HTTP method
          "CONNECT " + destinationHost + ":" + destinationPort + " HTTP/1.1\r\n" + // HTTP request headers
          Object.keys(reqHeaders).map((key) => key + ": " + reqHeaders[key]).join("\r\n") + // End request
          "\r\n\r\n"
        );
        let headers = "";
        let onSocketData = (chunk) => {
          let match;
          let remainder;
          if (finished) {
            return;
          }
          headers += chunk.toString("binary");
          if (match = headers.match(/\r\n\r\n/)) {
            socket.removeListener("data", onSocketData);
            remainder = headers.substr(match.index + match[0].length);
            headers = headers.substr(0, match.index);
            if (remainder) {
              socket.unshift(Buffer.from(remainder, "binary"));
            }
            finished = true;
            match = headers.match(/^HTTP\/\d+\.\d+ (\d+)/i);
            if (!match || (match[1] || "").charAt(0) !== "2") {
              try {
                socket.destroy();
              } catch (_E) {
              }
              return callback(new Error("Invalid response from proxy" + (match && ": " + match[1] || "")));
            }
            socket.removeListener("error", tempSocketErr);
            socket.removeListener("timeout", timeoutErr);
            socket.setTimeout(0);
            return callback(null, socket);
          }
        };
        socket.on("data", onSocketData);
      });
      socket.setTimeout(httpProxyClient.timeout || 30 * 1e3);
      socket.on("timeout", timeoutErr);
      socket.once("error", tempSocketErr);
    }
    module.exports = httpProxyClient;
  }
});

// ../node_modules/imapflow/lib/proxy-connection.js
var require_proxy_connection = __commonJS({
  "../node_modules/imapflow/lib/proxy-connection.js"(exports, module) {
    "use strict";
    var httpProxyClient = require_http_proxy_client();
    var { SocksClient } = require_build();
    var util = require_util();
    var httpProxyClientAsync = util.promisify(httpProxyClient);
    var dns = require_dns().promises;
    var net = require_net();
    var proxyConnection = async (logger, connectionUrl, host, port) => {
      let proxyUrl = new URL(connectionUrl);
      let protocol = proxyUrl.protocol.replace(/:$/, "").toLowerCase();
      if (!net.isIP(host)) {
        let resolveResult = await dns.resolve(host);
        if (resolveResult && resolveResult.length) {
          host = resolveResult[0];
        }
      }
      switch (protocol) {
        case "http":
        case "https": {
          try {
            let socket = await httpProxyClientAsync(proxyUrl.href, port, host);
            if (socket) {
              if (proxyUrl.password) {
                proxyUrl.password = "(hidden)";
              }
              logger.info({
                msg: "Established a socket via HTTP proxy",
                proxyUrl: proxyUrl.href,
                port,
                host
              });
            }
            return socket;
          } catch (err) {
            if (proxyUrl.password) {
              proxyUrl.password = "(hidden)";
            }
            logger.error({
              msg: "Failed to establish a socket via HTTP proxy",
              proxyUrl: proxyUrl.href,
              port,
              host,
              err
            });
            throw err;
          }
        }
        case "socks":
        case "socks5":
        case "socks4":
        case "socks4a": {
          let proxyType = Number(protocol.replace(/\D/g, "")) || 5;
          let targetHost = proxyUrl.hostname;
          if (!net.isIP(targetHost)) {
            let resolveResult = await dns.resolve(targetHost);
            if (resolveResult && resolveResult.length) {
              targetHost = resolveResult[0];
            }
          }
          let connectionOpts = {
            proxy: {
              host: targetHost,
              port: Number(proxyUrl.port) || 1080,
              type: proxyType
            },
            destination: {
              host,
              port
            },
            command: "connect",
            set_tcp_nodelay: true
          };
          if (proxyUrl.username || proxyUrl.password) {
            connectionOpts.proxy.userId = proxyUrl.username;
            connectionOpts.proxy.password = proxyUrl.password;
          }
          try {
            const info = await SocksClient.createConnection(connectionOpts);
            if (info && info.socket) {
              if (proxyUrl.password) {
                proxyUrl.password = "(hidden)";
              }
              logger.info({
                msg: "Established a socket via SOCKS proxy",
                proxyUrl: proxyUrl.href,
                port,
                host
              });
            }
            return info.socket;
          } catch (err) {
            if (proxyUrl.password) {
              proxyUrl.password = "(hidden)";
            }
            logger.error({
              msg: "Failed to establish a socket via SOCKS proxy",
              proxyUrl: proxyUrl.href,
              port,
              host,
              err
            });
            throw err;
          }
        }
      }
    };
    module.exports = { proxyConnection };
  }
});

// ../node_modules/imapflow/lib/charsets.js
var require_charsets = __commonJS({
  "../node_modules/imapflow/lib/charsets.js"(exports, module) {
    "use strict";
    var CHARACTER_SETS = [
      "US-ASCII",
      "ISO-8859-1",
      "ISO-8859-2",
      "ISO-8859-3",
      "ISO-8859-4",
      "ISO-8859-5",
      "ISO-8859-6",
      "ISO-8859-7",
      "ISO-8859-8",
      "ISO-8859-9",
      "ISO-8859-10",
      "ISO_6937-2-add",
      "JIS_X0201",
      "JIS_Encoding",
      "Shift_JIS",
      "EUC-JP",
      "Extended_UNIX_Code_Fixed_Width_for_Japanese",
      "BS_4730",
      "SEN_850200_C",
      "IT",
      "ES",
      "DIN_66003",
      "NS_4551-1",
      "NF_Z_62-010",
      "ISO-10646-UTF-1",
      "ISO_646.basic:1983",
      "INVARIANT",
      "ISO_646.irv:1983",
      "NATS-SEFI",
      "NATS-SEFI-ADD",
      "NATS-DANO",
      "NATS-DANO-ADD",
      "SEN_850200_B",
      "KS_C_5601-1987",
      "ISO-2022-KR",
      "EUC-KR",
      "ISO-2022-JP",
      "ISO-2022-JP-2",
      "JIS_C6220-1969-jp",
      "JIS_C6220-1969-ro",
      "PT",
      "greek7-old",
      "latin-greek",
      "NF_Z_62-010_(1973)",
      "Latin-greek-1",
      "ISO_5427",
      "JIS_C6226-1978",
      "BS_viewdata",
      "INIS",
      "INIS-8",
      "INIS-cyrillic",
      "ISO_5427:1981",
      "ISO_5428:1980",
      "GB_1988-80",
      "GB_2312-80",
      "NS_4551-2",
      "videotex-suppl",
      "PT2",
      "ES2",
      "MSZ_7795.3",
      "JIS_C6226-1983",
      "greek7",
      "ASMO_449",
      "iso-ir-90",
      "JIS_C6229-1984-a",
      "JIS_C6229-1984-b",
      "JIS_C6229-1984-b-add",
      "JIS_C6229-1984-hand",
      "JIS_C6229-1984-hand-add",
      "JIS_C6229-1984-kana",
      "ISO_2033-1983",
      "ANSI_X3.110-1983",
      "T.61-7bit",
      "T.61-8bit",
      "ECMA-cyrillic",
      "CSA_Z243.4-1985-1",
      "CSA_Z243.4-1985-2",
      "CSA_Z243.4-1985-gr",
      "ISO-8859-6-E",
      "ISO-8859-6-I",
      "T.101-G2",
      "ISO-8859-8-E",
      "ISO-8859-8-I",
      "CSN_369103",
      "JUS_I.B1.002",
      "IEC_P27-1",
      "JUS_I.B1.003-serb",
      "JUS_I.B1.003-mac",
      "greek-ccitt",
      "NC_NC00-10:81",
      "ISO_6937-2-25",
      "GOST_19768-74",
      "ISO_8859-supp",
      "ISO_10367-box",
      "latin-lap",
      "JIS_X0212-1990",
      "DS_2089",
      "us-dk",
      "dk-us",
      "KSC5636",
      "UNICODE-1-1-UTF-7",
      "ISO-2022-CN",
      "ISO-2022-CN-EXT",
      "UTF-8",
      "ISO-8859-13",
      "ISO-8859-14",
      "ISO-8859-15",
      "ISO-8859-16",
      "GBK",
      "GB18030",
      "OSD_EBCDIC_DF04_15",
      "OSD_EBCDIC_DF03_IRV",
      "OSD_EBCDIC_DF04_1",
      "ISO-11548-1",
      "KZ-1048",
      "ISO-10646-UCS-2",
      "ISO-10646-UCS-4",
      "ISO-10646-UCS-Basic",
      "ISO-10646-Unicode-Latin1",
      "ISO-10646-J-1",
      "ISO-Unicode-IBM-1261",
      "ISO-Unicode-IBM-1268",
      "ISO-Unicode-IBM-1276",
      "ISO-Unicode-IBM-1264",
      "ISO-Unicode-IBM-1265",
      "UNICODE-1-1",
      "SCSU",
      "UTF-7",
      "UTF-16BE",
      "UTF-16LE",
      "UTF-16",
      "CESU-8",
      "UTF-32",
      "UTF-32BE",
      "UTF-32LE",
      "BOCU-1",
      "ISO-8859-1-Windows-3.0-Latin-1",
      "ISO-8859-1-Windows-3.1-Latin-1",
      "ISO-8859-2-Windows-Latin-2",
      "ISO-8859-9-Windows-Latin-5",
      "hp-roman8",
      "Adobe-Standard-Encoding",
      "Ventura-US",
      "Ventura-International",
      "DEC-MCS",
      "IBM850",
      "PC8-Danish-Norwegian",
      "IBM862",
      "PC8-Turkish",
      "IBM-Symbols",
      "IBM-Thai",
      "HP-Legal",
      "HP-Pi-font",
      "HP-Math8",
      "Adobe-Symbol-Encoding",
      "HP-DeskTop",
      "Ventura-Math",
      "Microsoft-Publishing",
      "Windows-31J",
      "GB2312",
      "Big5",
      "macintosh",
      "IBM037",
      "IBM038",
      "IBM273",
      "IBM274",
      "IBM275",
      "IBM277",
      "IBM278",
      "IBM280",
      "IBM281",
      "IBM284",
      "IBM285",
      "IBM290",
      "IBM297",
      "IBM420",
      "IBM423",
      "IBM424",
      "IBM437",
      "IBM500",
      "IBM851",
      "IBM852",
      "IBM855",
      "IBM857",
      "IBM860",
      "IBM861",
      "IBM863",
      "IBM864",
      "IBM865",
      "IBM868",
      "IBM869",
      "IBM870",
      "IBM871",
      "IBM880",
      "IBM891",
      "IBM903",
      "IBM904",
      "IBM905",
      "IBM918",
      "IBM1026",
      "EBCDIC-AT-DE",
      "EBCDIC-AT-DE-A",
      "EBCDIC-CA-FR",
      "EBCDIC-DK-NO",
      "EBCDIC-DK-NO-A",
      "EBCDIC-FI-SE",
      "EBCDIC-FI-SE-A",
      "EBCDIC-FR",
      "EBCDIC-IT",
      "EBCDIC-PT",
      "EBCDIC-ES",
      "EBCDIC-ES-A",
      "EBCDIC-ES-S",
      "EBCDIC-UK",
      "EBCDIC-US",
      "UNKNOWN-8BIT",
      "MNEMONIC",
      "MNEM",
      "VISCII",
      "VIQR",
      "KOI8-R",
      "HZ-GB-2312",
      "IBM866",
      "IBM775",
      "KOI8-U",
      "IBM00858",
      "IBM00924",
      "IBM01140",
      "IBM01141",
      "IBM01142",
      "IBM01143",
      "IBM01144",
      "IBM01145",
      "IBM01146",
      "IBM01147",
      "IBM01148",
      "IBM01149",
      "Big5-HKSCS",
      "IBM1047",
      "PTCP154",
      "Amiga-1251",
      "KOI7-switched",
      "BRF",
      "TSCII",
      "CP51932",
      "windows-874",
      "windows-1250",
      "windows-1251",
      "windows-1252",
      "windows-1253",
      "windows-1254",
      "windows-1255",
      "windows-1256",
      "windows-1257",
      "windows-1258",
      "TIS-620",
      "CP50220"
    ];
    var CHARSET_MAP = /* @__PURE__ */ new Map();
    CHARACTER_SETS.forEach((entry) => {
      let key = entry.replace(/[_-\s]/g, "").toLowerCase();
      let modifiedKey = key.replace(/^windows/, "win").replace(/^usascii/, "ascii").replace(/^iso8859/, "latin");
      CHARSET_MAP.set(key, entry);
      if (!CHARSET_MAP.has(modifiedKey)) {
        CHARSET_MAP.set(modifiedKey, entry);
      }
    });
    module.exports.resolveCharset = (charset) => {
      let key = charset.replace(/[_-\s]/g, "").toLowerCase();
      if (CHARSET_MAP.has(key)) {
        return CHARSET_MAP.get(key);
      }
      return null;
    };
  }
});

// ../node_modules/imapflow/lib/jp-decoder.js
var require_jp_decoder = __commonJS({
  "../node_modules/imapflow/lib/jp-decoder.js"(exports, module) {
    "use strict";
    var { Transform } = require_stream();
    var encodingJapanese = require_src();
    var JPDecoder = class extends Transform {
      constructor(charset) {
        super();
        this.charset = charset;
        this.chunks = [];
        this.chunklen = 0;
      }
      _transform(chunk, encoding, done) {
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        this.chunks.push(chunk);
        this.chunklen += chunk.length;
        done();
      }
      _flush(done) {
        let input = Buffer.concat(this.chunks, this.chunklen);
        try {
          let output = encodingJapanese.convert(input, {
            to: "UNICODE",
            // to_encoding
            from: this.charset,
            // from_encoding
            type: "string"
          });
          if (typeof output === "string") {
            output = Buffer.from(output);
          }
          this.push(output);
        } catch {
          this.push(input);
        }
        done();
      }
    };
    module.exports.JPDecoder = JPDecoder;
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/lib/bom-handling.js"(exports) {
    "use strict";
    var BOMChar = "\uFEFF";
    exports.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options) {
      this.encoder = encoder;
      this.addBOM = true;
    }
    PrependBOMWrapper.prototype.write = function(str) {
      if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
      }
      return this.encoder.write(str);
    };
    PrependBOMWrapper.prototype.end = function() {
      return this.encoder.end();
    };
    exports.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options) {
      this.decoder = decoder;
      this.pass = false;
      this.options = options || {};
    }
    StripBOMWrapper.prototype.write = function(buf) {
      var res = this.decoder.write(buf);
      if (this.pass || !res) {
        return res;
      }
      if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === "function") {
          this.options.stripBOM();
        }
      }
      this.pass = true;
      return res;
    };
    StripBOMWrapper.prototype.end = function() {
      return this.decoder.end();
    };
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/lib/helpers/merge-exports.js
var require_merge_exports = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/lib/helpers/merge-exports.js"(exports, module) {
    "use strict";
    var hasOwn = typeof Object.hasOwn === "undefined" ? Function.call.bind(Object.prototype.hasOwnProperty) : Object.hasOwn;
    function mergeModules(target, module2) {
      for (var key in module2) {
        if (hasOwn(module2, key)) {
          target[key] = module2[key];
        }
      }
    }
    module.exports = mergeModules;
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/internal.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    module.exports = {
      // Encodings
      utf8: { type: "_internal", bomAware: true },
      cesu8: { type: "_internal", bomAware: true },
      unicode11utf8: "utf8",
      ucs2: { type: "_internal", bomAware: true },
      utf16le: "ucs2",
      binary: { type: "_internal" },
      base64: { type: "_internal" },
      hex: { type: "_internal" },
      // Codec.
      _internal: InternalCodec
    };
    function InternalCodec(codecOptions, iconv) {
      this.enc = codecOptions.encodingName;
      this.bomAware = codecOptions.bomAware;
      if (this.enc === "base64") {
        this.encoder = InternalEncoderBase64;
      } else if (this.enc === "utf8") {
        this.encoder = InternalEncoderUtf8;
      } else if (this.enc === "cesu8") {
        this.enc = "utf8";
        this.encoder = InternalEncoderCesu8;
        if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
          this.decoder = InternalDecoderCesu8;
          this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
      }
    }
    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;
    var StringDecoder = require_string_decoder().StringDecoder;
    function InternalDecoder(options, codec) {
      this.decoder = new StringDecoder(codec.enc);
    }
    InternalDecoder.prototype.write = function(buf) {
      if (!Buffer2.isBuffer(buf)) {
        buf = Buffer2.from(buf);
      }
      return this.decoder.write(buf);
    };
    InternalDecoder.prototype.end = function() {
      return this.decoder.end();
    };
    function InternalEncoder(options, codec) {
      this.enc = codec.enc;
    }
    InternalEncoder.prototype.write = function(str) {
      return Buffer2.from(str, this.enc);
    };
    InternalEncoder.prototype.end = function() {
    };
    function InternalEncoderBase64(options, codec) {
      this.prevStr = "";
    }
    InternalEncoderBase64.prototype.write = function(str) {
      str = this.prevStr + str;
      var completeQuads = str.length - str.length % 4;
      this.prevStr = str.slice(completeQuads);
      str = str.slice(0, completeQuads);
      return Buffer2.from(str, "base64");
    };
    InternalEncoderBase64.prototype.end = function() {
      return Buffer2.from(this.prevStr, "base64");
    };
    function InternalEncoderCesu8(options, codec) {
    }
    InternalEncoderCesu8.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length * 3);
      var bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode < 128) {
          buf[bufIdx++] = charCode;
        } else if (charCode < 2048) {
          buf[bufIdx++] = 192 + (charCode >>> 6);
          buf[bufIdx++] = 128 + (charCode & 63);
        } else {
          buf[bufIdx++] = 224 + (charCode >>> 12);
          buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
          buf[bufIdx++] = 128 + (charCode & 63);
        }
      }
      return buf.slice(0, bufIdx);
    };
    InternalEncoderCesu8.prototype.end = function() {
    };
    function InternalDecoderCesu8(options, codec) {
      this.acc = 0;
      this.contBytes = 0;
      this.accBytes = 0;
      this.defaultCharUnicode = codec.defaultCharUnicode;
    }
    InternalDecoderCesu8.prototype.write = function(buf) {
      var acc = this.acc;
      var contBytes = this.contBytes;
      var accBytes = this.accBytes;
      var res = "";
      for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 192) !== 128) {
          if (contBytes > 0) {
            res += this.defaultCharUnicode;
            contBytes = 0;
          }
          if (curByte < 128) {
            res += String.fromCharCode(curByte);
          } else if (curByte < 224) {
            acc = curByte & 31;
            contBytes = 1;
            accBytes = 1;
          } else if (curByte < 240) {
            acc = curByte & 15;
            contBytes = 2;
            accBytes = 1;
          } else {
            res += this.defaultCharUnicode;
          }
        } else {
          if (contBytes > 0) {
            acc = acc << 6 | curByte & 63;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
              if (accBytes === 2 && acc < 128 && acc > 0) {
                res += this.defaultCharUnicode;
              } else if (accBytes === 3 && acc < 2048) {
                res += this.defaultCharUnicode;
              } else {
                res += String.fromCharCode(acc);
              }
            }
          } else {
            res += this.defaultCharUnicode;
          }
        }
      }
      this.acc = acc;
      this.contBytes = contBytes;
      this.accBytes = accBytes;
      return res;
    };
    InternalDecoderCesu8.prototype.end = function() {
      var res = 0;
      if (this.contBytes > 0) {
        res += this.defaultCharUnicode;
      }
      return res;
    };
    function InternalEncoderUtf8(options, codec) {
      this.highSurrogate = "";
    }
    InternalEncoderUtf8.prototype.write = function(str) {
      if (this.highSurrogate) {
        str = this.highSurrogate + str;
        this.highSurrogate = "";
      }
      if (str.length > 0) {
        var charCode = str.charCodeAt(str.length - 1);
        if (charCode >= 55296 && charCode < 56320) {
          this.highSurrogate = str[str.length - 1];
          str = str.slice(0, str.length - 1);
        }
      }
      return Buffer2.from(str, this.enc);
    };
    InternalEncoderUtf8.prototype.end = function() {
      if (this.highSurrogate) {
        var str = this.highSurrogate;
        this.highSurrogate = "";
        return Buffer2.from(str, this.enc);
      }
    };
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/utf32.js"(exports) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports._utf32 = Utf32Codec;
    function Utf32Codec(codecOptions, iconv) {
      this.iconv = iconv;
      this.bomAware = true;
      this.isLE = codecOptions.isLE;
    }
    exports.utf32le = { type: "_utf32", isLE: true };
    exports.utf32be = { type: "_utf32", isLE: false };
    exports.ucs4le = "utf32le";
    exports.ucs4be = "utf32be";
    Utf32Codec.prototype.encoder = Utf32Encoder;
    Utf32Codec.prototype.decoder = Utf32Decoder;
    function Utf32Encoder(options, codec) {
      this.isLE = codec.isLE;
      this.highSurrogate = 0;
    }
    Utf32Encoder.prototype.write = function(str) {
      var src = Buffer2.from(str, "ucs2");
      var dst = Buffer2.alloc(src.length * 2);
      var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
      var offset = 0;
      for (var i = 0; i < src.length; i += 2) {
        var code = src.readUInt16LE(i);
        var isHighSurrogate = code >= 55296 && code < 56320;
        var isLowSurrogate = code >= 56320 && code < 57344;
        if (this.highSurrogate) {
          if (isHighSurrogate || !isLowSurrogate) {
            write32.call(dst, this.highSurrogate, offset);
            offset += 4;
          } else {
            var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
            write32.call(dst, codepoint, offset);
            offset += 4;
            this.highSurrogate = 0;
            continue;
          }
        }
        if (isHighSurrogate) {
          this.highSurrogate = code;
        } else {
          write32.call(dst, code, offset);
          offset += 4;
          this.highSurrogate = 0;
        }
      }
      if (offset < dst.length) {
        dst = dst.slice(0, offset);
      }
      return dst;
    };
    Utf32Encoder.prototype.end = function() {
      if (!this.highSurrogate) {
        return;
      }
      var buf = Buffer2.alloc(4);
      if (this.isLE) {
        buf.writeUInt32LE(this.highSurrogate, 0);
      } else {
        buf.writeUInt32BE(this.highSurrogate, 0);
      }
      this.highSurrogate = 0;
      return buf;
    };
    function Utf32Decoder(options, codec) {
      this.isLE = codec.isLE;
      this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
      this.overflow = [];
    }
    Utf32Decoder.prototype.write = function(src) {
      if (src.length === 0) {
        return "";
      }
      var i = 0;
      var codepoint = 0;
      var dst = Buffer2.alloc(src.length + 4);
      var offset = 0;
      var isLE = this.isLE;
      var overflow = this.overflow;
      var badChar = this.badChar;
      if (overflow.length > 0) {
        for (; i < src.length && overflow.length < 4; i++) {
          overflow.push(src[i]);
        }
        if (overflow.length === 4) {
          if (isLE) {
            codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
          } else {
            codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
          }
          overflow.length = 0;
          offset = _writeCodepoint(dst, offset, codepoint, badChar);
        }
      }
      for (; i < src.length - 3; i += 4) {
        if (isLE) {
          codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
        } else {
          codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
        }
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
      for (; i < src.length; i++) {
        overflow.push(src[i]);
      }
      return dst.slice(0, offset).toString("ucs2");
    };
    function _writeCodepoint(dst, offset, codepoint, badChar) {
      if (codepoint < 0 || codepoint > 1114111) {
        codepoint = badChar;
      }
      if (codepoint >= 65536) {
        codepoint -= 65536;
        var high = 55296 | codepoint >> 10;
        dst[offset++] = high & 255;
        dst[offset++] = high >> 8;
        var codepoint = 56320 | codepoint & 1023;
      }
      dst[offset++] = codepoint & 255;
      dst[offset++] = codepoint >> 8;
      return offset;
    }
    Utf32Decoder.prototype.end = function() {
      this.overflow.length = 0;
    };
    exports.utf32 = Utf32AutoCodec;
    exports.ucs4 = "utf32";
    function Utf32AutoCodec(options, iconv) {
      this.iconv = iconv;
    }
    Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
    Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
    function Utf32AutoEncoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0) {
        options.addBOM = true;
      }
      this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
    }
    Utf32AutoEncoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf32AutoEncoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf32AutoDecoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf32AutoDecoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 32) {
          return "";
        }
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++) {
          resStr += this.decoder.write(this.initialBufs[i]);
        }
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf32AutoDecoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++) {
          resStr += this.decoder.write(this.initialBufs[i]);
        }
        var trail = this.decoder.end();
        if (trail) {
          resStr += trail;
        }
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var invalidLE = 0;
      var invalidBE = 0;
      var bmpCharsLE = 0;
      var bmpCharsBE = 0;
      outerLoop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 4) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                  return "utf-32le";
                }
                if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                  return "utf-32be";
                }
              }
              if (b[0] !== 0 || b[1] > 16) invalidBE++;
              if (b[3] !== 0 || b[2] > 16) invalidLE++;
              if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
              if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outerLoop;
              }
            }
          }
        }
      if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
      if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
      return defaultEncoding || "utf-32le";
    }
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/utf16.js"(exports) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports.utf16be = Utf16BECodec;
    function Utf16BECodec() {
    }
    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;
    function Utf16BEEncoder() {
    }
    Utf16BEEncoder.prototype.write = function(str) {
      var buf = Buffer2.from(str, "ucs2");
      for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
      }
      return buf;
    };
    Utf16BEEncoder.prototype.end = function() {
    };
    function Utf16BEDecoder() {
      this.overflowByte = -1;
    }
    Utf16BEDecoder.prototype.write = function(buf) {
      if (buf.length == 0) {
        return "";
      }
      var buf2 = Buffer2.alloc(buf.length + 1);
      var i = 0;
      var j = 0;
      if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
      }
      for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
      }
      this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
      return buf2.slice(0, j).toString("ucs2");
    };
    Utf16BEDecoder.prototype.end = function() {
      this.overflowByte = -1;
    };
    exports.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;
    function Utf16Encoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0) {
        options.addBOM = true;
      }
      this.encoder = codec.iconv.getEncoder("utf-16le", options);
    }
    Utf16Encoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf16Encoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf16Decoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf16Decoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 16) {
          return "";
        }
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++) {
          resStr += this.decoder.write(this.initialBufs[i]);
        }
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf16Decoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++) {
          resStr += this.decoder.write(this.initialBufs[i]);
        }
        var trail = this.decoder.end();
        if (trail) {
          resStr += trail;
        }
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var asciiCharsLE = 0;
      var asciiCharsBE = 0;
      outerLoop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 2) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254) return "utf-16le";
                if (b[0] === 254 && b[1] === 255) return "utf-16be";
              }
              if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
              if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outerLoop;
              }
            }
          }
        }
      if (asciiCharsBE > asciiCharsLE) return "utf-16be";
      if (asciiCharsBE < asciiCharsLE) return "utf-16le";
      return defaultEncoding || "utf-16le";
    }
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/utf7.js"(exports) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports.utf7 = Utf7Codec;
    exports.unicode11utf7 = "utf7";
    function Utf7Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    function Utf7Encoder(options, codec) {
      this.iconv = codec.iconv;
    }
    Utf7Encoder.prototype.write = function(str) {
      return Buffer2.from(str.replace(nonDirectChars, (function(chunk) {
        return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
      }).bind(this)));
    };
    Utf7Encoder.prototype.end = function() {
    };
    function Utf7Decoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (i = 0; i < 256; i++) {
      base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    }
    var i;
    var plusChar = "+".charCodeAt(0);
    var minusChar = "-".charCodeAt(0);
    var andChar = "&".charCodeAt(0);
    Utf7Decoder.prototype.write = function(buf) {
      var res = "";
      var lastI = 0;
      var inBase64 = this.inBase64;
      var base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == plusChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64Chars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "+";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar) {
              i2--;
            }
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7Decoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0) {
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      }
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
    exports.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;
    function Utf7IMAPEncoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = Buffer2.alloc(6);
      this.base64AccumIdx = 0;
    }
    Utf7IMAPEncoder.prototype.write = function(str) {
      var inBase64 = this.inBase64;
      var base64Accum = this.base64Accum;
      var base64AccumIdx = this.base64AccumIdx;
      var buf = Buffer2.alloc(str.length * 5 + 10);
      var bufIdx = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var uChar = str.charCodeAt(i2);
        if (uChar >= 32 && uChar <= 126) {
          if (inBase64) {
            if (base64AccumIdx > 0) {
              bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
              base64AccumIdx = 0;
            }
            buf[bufIdx++] = minusChar;
            inBase64 = false;
          }
          if (!inBase64) {
            buf[bufIdx++] = uChar;
            if (uChar === andChar) {
              buf[bufIdx++] = minusChar;
            }
          }
        } else {
          if (!inBase64) {
            buf[bufIdx++] = andChar;
            inBase64 = true;
          }
          if (inBase64) {
            base64Accum[base64AccumIdx++] = uChar >> 8;
            base64Accum[base64AccumIdx++] = uChar & 255;
            if (base64AccumIdx == base64Accum.length) {
              bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
              base64AccumIdx = 0;
            }
          }
        }
      }
      this.inBase64 = inBase64;
      this.base64AccumIdx = base64AccumIdx;
      return buf.slice(0, bufIdx);
    };
    Utf7IMAPEncoder.prototype.end = function() {
      var buf = Buffer2.alloc(10);
      var bufIdx = 0;
      if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
          bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
          this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        this.inBase64 = false;
      }
      return buf.slice(0, bufIdx);
    };
    function Utf7IMAPDecoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[",".charCodeAt(0)] = true;
    Utf7IMAPDecoder.prototype.write = function(buf) {
      var res = "";
      var lastI = 0;
      var inBase64 = this.inBase64;
      var base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == andChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64IMAPChars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "&";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar) {
              i2--;
            }
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7IMAPDecoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0) {
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      }
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/sbcs-codec.js"(exports) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv) {
      if (!codecOptions) {
        throw new Error("SBCS codec is called without the data.");
      }
      if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) {
        throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
      }
      if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++) {
          asciiString += String.fromCharCode(i);
        }
        codecOptions.chars = asciiString + codecOptions.chars;
      }
      this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
      var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
      for (var i = 0; i < codecOptions.chars.length; i++) {
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
      }
      this.encodeBuf = encodeBuf;
    }
    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;
    function SBCSEncoder(options, codec) {
      this.encodeBuf = codec.encodeBuf;
    }
    SBCSEncoder.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length);
      for (var i = 0; i < str.length; i++) {
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
      }
      return buf;
    };
    SBCSEncoder.prototype.end = function() {
    };
    function SBCSDecoder(options, codec) {
      this.decodeBuf = codec.decodeBuf;
    }
    SBCSDecoder.prototype.write = function(buf) {
      var decodeBuf = this.decodeBuf;
      var newBuf = Buffer2.alloc(buf.length * 2);
      var idx1 = 0;
      var idx2 = 0;
      for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
      }
      return newBuf.toString("ucs2");
    };
    SBCSDecoder.prototype.end = function() {
    };
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/sbcs-data.js"(exports, module) {
    "use strict";
    module.exports = {
      // Not supported by iconv, not sure why.
      10029: "maccenteuro",
      maccenteuro: {
        type: "_sbcs",
        chars: ""
      },
      808: "cp808",
      ibm808: "cp808",
      cp808: {
        type: "_sbcs",
        chars: ""
      },
      mik: {
        type: "_sbcs",
        chars: ""
      },
      cp720: {
        type: "_sbcs",
        chars: ""
      },
      // Aliases of generated encodings.
      ascii8bit: "ascii",
      usascii: "ascii",
      ansix34: "ascii",
      ansix341968: "ascii",
      ansix341986: "ascii",
      csascii: "ascii",
      cp367: "ascii",
      ibm367: "ascii",
      isoir6: "ascii",
      iso646us: "ascii",
      iso646irv: "ascii",
      us: "ascii",
      latin1: "iso88591",
      latin2: "iso88592",
      latin3: "iso88593",
      latin4: "iso88594",
      latin5: "iso88599",
      latin6: "iso885910",
      latin7: "iso885913",
      latin8: "iso885914",
      latin9: "iso885915",
      latin10: "iso885916",
      csisolatin1: "iso88591",
      csisolatin2: "iso88592",
      csisolatin3: "iso88593",
      csisolatin4: "iso88594",
      csisolatincyrillic: "iso88595",
      csisolatinarabic: "iso88596",
      csisolatingreek: "iso88597",
      csisolatinhebrew: "iso88598",
      csisolatin5: "iso88599",
      csisolatin6: "iso885910",
      l1: "iso88591",
      l2: "iso88592",
      l3: "iso88593",
      l4: "iso88594",
      l5: "iso88599",
      l6: "iso885910",
      l7: "iso885913",
      l8: "iso885914",
      l9: "iso885915",
      l10: "iso885916",
      isoir14: "iso646jp",
      isoir57: "iso646cn",
      isoir100: "iso88591",
      isoir101: "iso88592",
      isoir109: "iso88593",
      isoir110: "iso88594",
      isoir144: "iso88595",
      isoir127: "iso88596",
      isoir126: "iso88597",
      isoir138: "iso88598",
      isoir148: "iso88599",
      isoir157: "iso885910",
      isoir166: "tis620",
      isoir179: "iso885913",
      isoir199: "iso885914",
      isoir203: "iso885915",
      isoir226: "iso885916",
      cp819: "iso88591",
      ibm819: "iso88591",
      cyrillic: "iso88595",
      arabic: "iso88596",
      arabic8: "iso88596",
      ecma114: "iso88596",
      asmo708: "iso88596",
      greek: "iso88597",
      greek8: "iso88597",
      ecma118: "iso88597",
      elot928: "iso88597",
      hebrew: "iso88598",
      hebrew8: "iso88598",
      turkish: "iso88599",
      turkish8: "iso88599",
      thai: "iso885911",
      thai8: "iso885911",
      celtic: "iso885914",
      celtic8: "iso885914",
      isoceltic: "iso885914",
      tis6200: "tis620",
      tis62025291: "tis620",
      tis62025330: "tis620",
      1e4: "macroman",
      10006: "macgreek",
      10007: "maccyrillic",
      10079: "maciceland",
      10081: "macturkish",
      cspc8codepage437: "cp437",
      cspc775baltic: "cp775",
      cspc850multilingual: "cp850",
      cspcp852: "cp852",
      cspc862latinhebrew: "cp862",
      cpgr: "cp869",
      msee: "cp1250",
      mscyrl: "cp1251",
      msansi: "cp1252",
      msgreek: "cp1253",
      msturk: "cp1254",
      mshebr: "cp1255",
      msarab: "cp1256",
      winbaltrim: "cp1257",
      cp20866: "koi8r",
      20866: "koi8r",
      ibm878: "koi8r",
      cskoi8r: "koi8r",
      cp21866: "koi8u",
      21866: "koi8u",
      ibm1168: "koi8u",
      strk10482002: "rk1048",
      tcvn5712: "tcvn",
      tcvn57121: "tcvn",
      gb198880: "iso646cn",
      cn: "iso646cn",
      csiso14jisc6220ro: "iso646jp",
      jisc62201969ro: "iso646jp",
      jp: "iso646jp",
      cshproman8: "hproman8",
      r8: "hproman8",
      roman8: "hproman8",
      xroman8: "hproman8",
      ibm1051: "hproman8",
      mac: "macintosh",
      csmacintosh: "macintosh"
    };
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/sbcs-data-generated.js"(exports, module) {
    "use strict";
    module.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": ""
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": ""
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": ""
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": ""
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": ""
      },
      "macroman": {
        "type": "_sbcs",
        "chars": ""
      },
      "macromania": {
        "type": "_sbcs",
        "chars": ""
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "\uFEFF"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": ""
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": ""
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": ")(.,-"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": ""
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": ""
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": ""
      },
      "pt154": {
        "type": "_sbcs",
        "chars": ""
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": ""
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": ""
      },
      "ascii": {
        "type": "_sbcs",
        "chars": ""
      },
      "tis620": {
        "type": "_sbcs",
        "chars": ""
      }
    };
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/dbcs-codec.js"(exports) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports._dbcs = DBCSCodec;
    var UNASSIGNED = -1;
    var GB18030_CODE = -2;
    var SEQ_START = -10;
    var NODE_START = -1e3;
    var UNASSIGNED_NODE = new Array(256);
    var DEF_CHAR = -1;
    for (i = 0; i < 256; i++) {
      UNASSIGNED_NODE[i] = UNASSIGNED;
    }
    var i;
    function DBCSCodec(codecOptions, iconv) {
      this.encodingName = codecOptions.encodingName;
      if (!codecOptions) {
        throw new Error("DBCS codec is called without the data.");
      }
      if (!codecOptions.table) {
        throw new Error("Encoding '" + this.encodingName + "' has no data.");
      }
      var mappingTable = codecOptions.table();
      this.decodeTables = [];
      this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
      this.decodeTableSeq = [];
      for (var i2 = 0; i2 < mappingTable.length; i2++) {
        this._addDecodeChunk(mappingTable[i2]);
      }
      if (typeof codecOptions.gb18030 === "function") {
        this.gb18030 = codecOptions.gb18030();
        var commonThirdByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var commonFourthByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var firstByteNode = this.decodeTables[0];
        for (var i2 = 129; i2 <= 254; i2++) {
          var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
          for (var j = 48; j <= 57; j++) {
            if (secondByteNode[j] === UNASSIGNED) {
              secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
            } else if (secondByteNode[j] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 2");
            }
            var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
            for (var k = 129; k <= 254; k++) {
              if (thirdByteNode[k] === UNASSIGNED) {
                thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
              } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
                continue;
              } else if (thirdByteNode[k] > NODE_START) {
                throw new Error("gb18030 decode tables conflict at byte 3");
              }
              var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
              for (var l = 48; l <= 57; l++) {
                if (fourthByteNode[l] === UNASSIGNED) {
                  fourthByteNode[l] = GB18030_CODE;
                }
              }
            }
          }
        }
      }
      this.defaultCharUnicode = iconv.defaultCharUnicode;
      this.encodeTable = [];
      this.encodeTableSeq = [];
      var skipEncodeChars = {};
      if (codecOptions.encodeSkipVals) {
        for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
          var val = codecOptions.encodeSkipVals[i2];
          if (typeof val === "number") {
            skipEncodeChars[val] = true;
          } else {
            for (var j = val.from; j <= val.to; j++) {
              skipEncodeChars[j] = true;
            }
          }
        }
      }
      this._fillEncodeTable(0, 0, skipEncodeChars);
      if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd) {
          if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) {
            this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
          }
        }
      }
      this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
      if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
      if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
    }
    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
      var bytes = [];
      for (; addr > 0; addr >>>= 8) {
        bytes.push(addr & 255);
      }
      if (bytes.length == 0) {
        bytes.push(0);
      }
      var node = this.decodeTables[0];
      for (var i2 = bytes.length - 1; i2 > 0; i2--) {
        var val = node[bytes[i2]];
        if (val == UNASSIGNED) {
          node[bytes[i2]] = NODE_START - this.decodeTables.length;
          this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
          node = this.decodeTables[NODE_START - val];
        } else {
          throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
        }
      }
      return node;
    };
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
      var curAddr = parseInt(chunk[0], 16);
      var writeTable = this._getDecodeTrieNode(curAddr);
      curAddr = curAddr & 255;
      for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
          for (var l = 0; l < part.length; ) {
            var code = part.charCodeAt(l++);
            if (code >= 55296 && code < 56320) {
              var codeTrail = part.charCodeAt(l++);
              if (codeTrail >= 56320 && codeTrail < 57344) {
                writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
              } else {
                throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
              }
            } else if (code > 4080 && code <= 4095) {
              var len = 4095 - code + 2;
              var seq = [];
              for (var m = 0; m < len; m++) {
                seq.push(part.charCodeAt(l++));
              }
              writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
              this.decodeTableSeq.push(seq);
            } else {
              writeTable[curAddr++] = code;
            }
          }
        } else if (typeof part === "number") {
          var charCode = writeTable[curAddr - 1] + 1;
          for (var l = 0; l < part; l++) {
            writeTable[curAddr++] = charCode++;
          }
        } else {
          throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
        }
      }
      if (curAddr > 255) {
        throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
      }
    };
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
      var high = uCode >> 8;
      if (this.encodeTable[high] === void 0) {
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
      }
      return this.encodeTable[high];
    };
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      if (bucket[low] <= SEQ_START) {
        this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
      } else if (bucket[low] == UNASSIGNED) {
        bucket[low] = dbcsCode;
      }
    };
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
      var uCode = seq[0];
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      var node;
      if (bucket[low] <= SEQ_START) {
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
      } else {
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
      }
      for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === "object") {
          node = oldVal;
        } else {
          node = node[uCode] = {};
          if (oldVal !== void 0) {
            node[DEF_CHAR] = oldVal;
          }
        }
      }
      uCode = seq[seq.length - 1];
      node[uCode] = dbcsCode;
    };
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
      var node = this.decodeTables[nodeIdx];
      var hasValues = false;
      var subNodeEmpty = {};
      for (var i2 = 0; i2 < 256; i2++) {
        var uCode = node[i2];
        var mbCode = prefix + i2;
        if (skipEncodeChars[mbCode]) {
          continue;
        }
        if (uCode >= 0) {
          this._setEncodeChar(uCode, mbCode);
          hasValues = true;
        } else if (uCode <= NODE_START) {
          var subNodeIdx = NODE_START - uCode;
          if (!subNodeEmpty[subNodeIdx]) {
            var newPrefix = mbCode << 8 >>> 0;
            if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) {
              hasValues = true;
            } else {
              subNodeEmpty[subNodeIdx] = true;
            }
          }
        } else if (uCode <= SEQ_START) {
          this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
          hasValues = true;
        }
      }
      return hasValues;
    };
    function DBCSEncoder(options, codec) {
      this.leadSurrogate = -1;
      this.seqObj = void 0;
      this.encodeTable = codec.encodeTable;
      this.encodeTableSeq = codec.encodeTableSeq;
      this.defaultCharSingleByte = codec.defCharSB;
      this.gb18030 = codec.gb18030;
    }
    DBCSEncoder.prototype.write = function(str) {
      var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3));
      var leadSurrogate = this.leadSurrogate;
      var seqObj = this.seqObj;
      var nextChar = -1;
      var i2 = 0;
      var j = 0;
      while (true) {
        if (nextChar === -1) {
          if (i2 == str.length) break;
          var uCode = str.charCodeAt(i2++);
        } else {
          var uCode = nextChar;
          nextChar = -1;
        }
        if (uCode >= 55296 && uCode < 57344) {
          if (uCode < 56320) {
            if (leadSurrogate === -1) {
              leadSurrogate = uCode;
              continue;
            } else {
              leadSurrogate = uCode;
              uCode = UNASSIGNED;
            }
          } else {
            if (leadSurrogate !== -1) {
              uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
              leadSurrogate = -1;
            } else {
              uCode = UNASSIGNED;
            }
          }
        } else if (leadSurrogate !== -1) {
          nextChar = uCode;
          uCode = UNASSIGNED;
          leadSurrogate = -1;
        }
        var dbcsCode = UNASSIGNED;
        if (seqObj !== void 0 && uCode != UNASSIGNED) {
          var resCode = seqObj[uCode];
          if (typeof resCode === "object") {
            seqObj = resCode;
            continue;
          } else if (typeof resCode === "number") {
            dbcsCode = resCode;
          } else if (resCode == void 0) {
            resCode = seqObj[DEF_CHAR];
            if (resCode !== void 0) {
              dbcsCode = resCode;
              nextChar = uCode;
            } else {
            }
          }
          seqObj = void 0;
        } else if (uCode >= 0) {
          var subtable = this.encodeTable[uCode >> 8];
          if (subtable !== void 0) {
            dbcsCode = subtable[uCode & 255];
          }
          if (dbcsCode <= SEQ_START) {
            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
            continue;
          }
          if (dbcsCode == UNASSIGNED && this.gb18030) {
            var idx = findIdx(this.gb18030.uChars, uCode);
            if (idx != -1) {
              var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
              newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
              dbcsCode = dbcsCode % 12600;
              newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
              dbcsCode = dbcsCode % 1260;
              newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
              dbcsCode = dbcsCode % 10;
              newBuf[j++] = 48 + dbcsCode;
              continue;
            }
          }
        }
        if (dbcsCode === UNASSIGNED) {
          dbcsCode = this.defaultCharSingleByte;
        }
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 65536) {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        } else if (dbcsCode < 16777216) {
          newBuf[j++] = dbcsCode >> 16;
          newBuf[j++] = dbcsCode >> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        } else {
          newBuf[j++] = dbcsCode >>> 24;
          newBuf[j++] = dbcsCode >>> 16 & 255;
          newBuf[j++] = dbcsCode >>> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = seqObj;
      this.leadSurrogate = leadSurrogate;
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.end = function() {
      if (this.leadSurrogate === -1 && this.seqObj === void 0) {
        return;
      }
      var newBuf = Buffer2.alloc(10);
      var j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== void 0) {
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          }
        } else {
        }
        this.seqObj = void 0;
      }
      if (this.leadSurrogate !== -1) {
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
      }
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.findIdx = findIdx;
    function DBCSDecoder(options, codec) {
      this.nodeIdx = 0;
      this.prevBytes = [];
      this.decodeTables = codec.decodeTables;
      this.decodeTableSeq = codec.decodeTableSeq;
      this.defaultCharUnicode = codec.defaultCharUnicode;
      this.gb18030 = codec.gb18030;
    }
    DBCSDecoder.prototype.write = function(buf) {
      var newBuf = Buffer2.alloc(buf.length * 2);
      var nodeIdx = this.nodeIdx;
      var prevBytes = this.prevBytes;
      var prevOffset = this.prevBytes.length;
      var seqStart = -this.prevBytes.length;
      var uCode;
      for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
        var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) {
        } else if (uCode === UNASSIGNED) {
          uCode = this.defaultCharUnicode.charCodeAt(0);
          i2 = seqStart;
        } else if (uCode === GB18030_CODE) {
          if (i2 >= 3) {
            var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
          } else {
            var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
          }
          var idx = findIdx(this.gb18030.gbChars, ptr);
          uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
          nodeIdx = NODE_START - uCode;
          continue;
        } else if (uCode <= SEQ_START) {
          var seq = this.decodeTableSeq[SEQ_START - uCode];
          for (var k = 0; k < seq.length - 1; k++) {
            uCode = seq[k];
            newBuf[j++] = uCode & 255;
            newBuf[j++] = uCode >> 8;
          }
          uCode = seq[seq.length - 1];
        } else {
          throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        }
        if (uCode >= 65536) {
          uCode -= 65536;
          var uCodeLead = 55296 | uCode >> 10;
          newBuf[j++] = uCodeLead & 255;
          newBuf[j++] = uCodeLead >> 8;
          uCode = 56320 | uCode & 1023;
        }
        newBuf[j++] = uCode & 255;
        newBuf[j++] = uCode >> 8;
        nodeIdx = 0;
        seqStart = i2 + 1;
      }
      this.nodeIdx = nodeIdx;
      this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
      return newBuf.slice(0, j).toString("ucs2");
    };
    DBCSDecoder.prototype.end = function() {
      var ret = "";
      while (this.prevBytes.length > 0) {
        ret += this.defaultCharUnicode;
        var bytesArr = this.prevBytes.slice(1);
        this.prevBytes = [];
        this.nodeIdx = 0;
        if (bytesArr.length > 0) {
          ret += this.write(bytesArr);
        }
      }
      this.prevBytes = [];
      this.nodeIdx = 0;
      return ret;
    };
    function findIdx(table, val) {
      if (table[0] > val) {
        return -1;
      }
      var l = 0;
      var r = table.length;
      while (l < r - 1) {
        var mid = l + (r - l + 1 >> 1);
        if (table[mid] <= val) {
          l = mid;
        } else {
          r = mid;
        }
      }
      return l;
    }
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/shiftjis.json"(exports, module) {
    module.exports = [
      ["0", "\0", 128],
      ["a1", "", 62],
      ["8140", "", 9, ""],
      ["8180", ""],
      ["81b8", ""],
      ["81c8", ""],
      ["81da", ""],
      ["81f0", ""],
      ["81fc", ""],
      ["824f", "", 9],
      ["8260", "", 25],
      ["8281", "", 25],
      ["829f", "", 82],
      ["8340", "", 62],
      ["8380", "", 22],
      ["839f", "", 16, "", 6],
      ["83bf", "", 16, "", 6],
      ["8440", "", 5, "", 25],
      ["8470", "", 5, "", 7],
      ["8480", "", 17],
      ["849f", ""],
      ["8740", "", 19, "", 9],
      ["875f", ""],
      ["877e", ""],
      ["8780", "", 4, ""],
      ["889f", ""],
      ["8940", ""],
      ["8980", ""],
      ["8a40", ""],
      ["8a80", ""],
      ["8b40", ""],
      ["8b80", ""],
      ["8c40", ""],
      ["8c80", ""],
      ["8d40", ""],
      ["8d80", ""],
      ["8e40", ""],
      ["8e80", ""],
      ["8f40", ""],
      ["8f80", ""],
      ["9040", ""],
      ["9080", ""],
      ["9140", ""],
      ["9180", ""],
      ["9240", ""],
      ["9280", ""],
      ["9340", ""],
      ["9380", ""],
      ["9440", ""],
      ["9480", ""],
      ["9540", ""],
      ["9580", ""],
      ["9640", ""],
      ["9680", ""],
      ["9740", ""],
      ["9780", ""],
      ["9840", ""],
      ["989f", ""],
      ["9940", ""],
      ["9980", ""],
      ["9a40", ""],
      ["9a80", ""],
      ["9b40", ""],
      ["9b80", ""],
      ["9c40", ""],
      ["9c80", ""],
      ["9d40", ""],
      ["9d80", ""],
      ["9e40", ""],
      ["9e80", ""],
      ["9f40", ""],
      ["9f80", ""],
      ["e040", ""],
      ["e080", ""],
      ["e140", ""],
      ["e180", ""],
      ["e240", ""],
      ["e280", ""],
      ["e340", ""],
      ["e380", ""],
      ["e440", ""],
      ["e480", ""],
      ["e540", ""],
      ["e580", ""],
      ["e640", ""],
      ["e680", ""],
      ["e740", ""],
      ["e780", ""],
      ["e840", ""],
      ["e880", ""],
      ["e940", ""],
      ["e980", ""],
      ["ea40", ""],
      ["ea80", ""],
      ["ed40", ""],
      ["ed80", ""],
      ["ee40", ""],
      ["ee80", ""],
      ["eeef", "", 9, ""],
      ["f040", "", 62],
      ["f080", "", 124],
      ["f140", "", 62],
      ["f180", "", 124],
      ["f240", "", 62],
      ["f280", "", 124],
      ["f340", "", 62],
      ["f380", "", 124],
      ["f440", "", 62],
      ["f480", "", 124],
      ["f540", "", 62],
      ["f580", "", 124],
      ["f640", "", 62],
      ["f680", "", 124],
      ["f740", "", 62],
      ["f780", "", 124],
      ["f840", "", 62],
      ["f880", "", 124],
      ["f940", ""],
      ["fa40", "", 9, "", 9, ""],
      ["fa80", ""],
      ["fb40", ""],
      ["fb80", ""],
      ["fc40", ""]
    ];
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/eucjp.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127],
      ["8ea1", "", 62],
      ["a1a1", "", 9, ""],
      ["a2a1", ""],
      ["a2ba", ""],
      ["a2ca", ""],
      ["a2dc", ""],
      ["a2f2", ""],
      ["a2fe", ""],
      ["a3b0", "", 9],
      ["a3c1", "", 25],
      ["a3e1", "", 25],
      ["a4a1", "", 82],
      ["a5a1", "", 85],
      ["a6a1", "", 16, "", 6],
      ["a6c1", "", 16, "", 6],
      ["a7a1", "", 5, "", 25],
      ["a7d1", "", 5, "", 25],
      ["a8a1", ""],
      ["ada1", "", 19, "", 9],
      ["adc0", ""],
      ["addf", "", 4, ""],
      ["b0a1", ""],
      ["b1a1", ""],
      ["b2a1", ""],
      ["b3a1", ""],
      ["b4a1", ""],
      ["b5a1", ""],
      ["b6a1", ""],
      ["b7a1", ""],
      ["b8a1", ""],
      ["b9a1", ""],
      ["baa1", ""],
      ["bba1", ""],
      ["bca1", ""],
      ["bda1", ""],
      ["bea1", ""],
      ["bfa1", ""],
      ["c0a1", ""],
      ["c1a1", ""],
      ["c2a1", ""],
      ["c3a1", ""],
      ["c4a1", ""],
      ["c5a1", ""],
      ["c6a1", ""],
      ["c7a1", ""],
      ["c8a1", ""],
      ["c9a1", ""],
      ["caa1", ""],
      ["cba1", ""],
      ["cca1", ""],
      ["cda1", ""],
      ["cea1", ""],
      ["cfa1", ""],
      ["d0a1", ""],
      ["d1a1", ""],
      ["d2a1", ""],
      ["d3a1", ""],
      ["d4a1", ""],
      ["d5a1", ""],
      ["d6a1", ""],
      ["d7a1", ""],
      ["d8a1", ""],
      ["d9a1", ""],
      ["daa1", ""],
      ["dba1", ""],
      ["dca1", ""],
      ["dda1", ""],
      ["dea1", ""],
      ["dfa1", ""],
      ["e0a1", ""],
      ["e1a1", ""],
      ["e2a1", ""],
      ["e3a1", ""],
      ["e4a1", ""],
      ["e5a1", ""],
      ["e6a1", ""],
      ["e7a1", ""],
      ["e8a1", ""],
      ["e9a1", ""],
      ["eaa1", ""],
      ["eba1", ""],
      ["eca1", ""],
      ["eda1", ""],
      ["eea1", ""],
      ["efa1", ""],
      ["f0a1", ""],
      ["f1a1", ""],
      ["f2a1", ""],
      ["f3a1", ""],
      ["f4a1", ""],
      ["f9a1", ""],
      ["faa1", ""],
      ["fba1", ""],
      ["fca1", ""],
      ["fcf1", "", 9, ""],
      ["8fa2af", ""],
      ["8fa2c2", ""],
      ["8fa2eb", ""],
      ["8fa6e1", ""],
      ["8fa6e7", ""],
      ["8fa6e9", ""],
      ["8fa6ec", ""],
      ["8fa6f1", ""],
      ["8fa7c2", "", 10, ""],
      ["8fa7f2", "", 10, ""],
      ["8fa9a1", ""],
      ["8fa9a4", ""],
      ["8fa9a6", ""],
      ["8fa9a8", ""],
      ["8fa9ab", ""],
      ["8fa9af", ""],
      ["8fa9c1", ""],
      ["8faaa1", ""],
      ["8faaba", ""],
      ["8faba1", ""],
      ["8fabbd", ""],
      ["8fabc5", ""],
      ["8fb0a1", ""],
      ["8fb1a1", ""],
      ["8fb2a1", "", 4, ""],
      ["8fb3a1", ""],
      ["8fb4a1", ""],
      ["8fb5a1", ""],
      ["8fb6a1", "", 5, "", 4, ""],
      ["8fb7a1", "", 4, ""],
      ["8fb8a1", ""],
      ["8fb9a1", ""],
      ["8fbaa1", "", 4, ""],
      ["8fbba1", ""],
      ["8fbca1", "", 4, ""],
      ["8fbda1", "", 4, ""],
      ["8fbea1", "", 4, ""],
      ["8fbfa1", ""],
      ["8fc0a1", ""],
      ["8fc1a1", ""],
      ["8fc2a1", ""],
      ["8fc3a1", "", 4, ""],
      ["8fc4a1", ""],
      ["8fc5a1", ""],
      ["8fc6a1", ""],
      ["8fc7a1", ""],
      ["8fc8a1", ""],
      ["8fc9a1", "", 4, "", 4, ""],
      ["8fcaa1", ""],
      ["8fcba1", ""],
      ["8fcca1", "", 9, ""],
      ["8fcda1", "", 5, ""],
      ["8fcea1", "", 6, ""],
      ["8fcfa1", ""],
      ["8fd0a1", ""],
      ["8fd1a1", ""],
      ["8fd2a1", "", 5],
      ["8fd3a1", ""],
      ["8fd4a1", "", 4, ""],
      ["8fd5a1", ""],
      ["8fd6a1", ""],
      ["8fd7a1", ""],
      ["8fd8a1", ""],
      ["8fd9a1", "", 4, "", 6, ""],
      ["8fdaa1", "", 4, ""],
      ["8fdba1", "", 6, ""],
      ["8fdca1", "", 4, ""],
      ["8fdda1", "", 4, ""],
      ["8fdea1", "", 4, ""],
      ["8fdfa1", ""],
      ["8fe0a1", ""],
      ["8fe1a1", "", 4, ""],
      ["8fe2a1", ""],
      ["8fe3a1", "", 5, "", 4, ""],
      ["8fe4a1", "", 4, ""],
      ["8fe5a1", "", 4, ""],
      ["8fe6a1", ""],
      ["8fe7a1", ""],
      ["8fe8a1", "", 4, ""],
      ["8fe9a1", "", 4],
      ["8feaa1", "", 4, ""],
      ["8feba1", "", 4, ""],
      ["8feca1", ""],
      ["8feda1", "", 4, "", 4, ""]
    ];
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/cp936.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127, ""],
      ["8140", "", 5, "", 9, "", 6, ""],
      ["8180", "", 6, "", 4, "", 4, "", 5, ""],
      ["8240", "", 4, "", 8, "", 4, "", 11],
      ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""],
      ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""],
      ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5],
      ["8440", "", 5, "", 5, ""],
      ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""],
      ["8540", "", 9, ""],
      ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""],
      ["8640", "", 4, "", 5, "", 4, "", 5, ""],
      ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""],
      ["8740", "", 7, "", 11, "", 4, "", 4],
      ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6],
      ["8840", "", 9, "", 4, "", 4, ""],
      ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7],
      ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""],
      ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""],
      ["8a40", "", 4, "", 12, ""],
      ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5],
      ["8b40", "", 8, "", 17, "", 6, "", 13, ""],
      ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6],
      ["8c40", "", 7, ""],
      ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4],
      ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4],
      ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""],
      ["8e40", "", 21, "", 12, "", 6, "", 12, ""],
      ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6],
      ["8f40", "", 5, "", 11, "", 8, ""],
      ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""],
      ["9040", "", 4, "", 4, "", 6, ""],
      ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6],
      ["9140", "", 6, "", 6, "", 18, "", 4, ""],
      ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""],
      ["9240", "", 6, "", 5, ""],
      ["9280", "", 5, "", 7, "", 6, ""],
      ["9340", "", 6, "", 4, "", 4, "", 5, ""],
      ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""],
      ["9440", "", 24, "", 7, "", 7, "", 4, "", 8],
      ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""],
      ["9540", "", 4, "", 4, "", 6, ""],
      ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""],
      ["9640", "", 5, "", 4, ""],
      ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5],
      ["9740", "", 7, "", 8, "", 7, "", 9, ""],
      ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""],
      ["9840", "", 4, "", 5, "", 9, ""],
      ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""],
      ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5],
      ["9980", "", 114, "", 6],
      ["9a40", "", 11, "", 7, "", 13, ""],
      ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""],
      ["9b40", "", 4, ""],
      ["9b80", "", 5, "", 4, "", 4, "", 5, ""],
      ["9c40", "", 7, ""],
      ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5],
      ["9d40", "", 7, "", 4, "", 9, "", 6, ""],
      ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""],
      ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6],
      ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""],
      ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""],
      ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4],
      ["a040", "", 9, "", 5, "", 9, "", 11, "", 19],
      ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""],
      ["a1a1", "", 7, ""],
      ["a2a1", "", 9],
      ["a2b1", "", 19, "", 19, "", 9],
      ["a2e5", "", 9],
      ["a2f1", "", 11],
      ["a3a1", "", 88, ""],
      ["a4a1", "", 82],
      ["a5a1", "", 85],
      ["a6a1", "", 16, "", 6],
      ["a6c1", "", 16, "", 6],
      ["a6e0", ""],
      ["a6ee", ""],
      ["a6f4", ""],
      ["a7a1", "", 5, "", 25],
      ["a7d1", "", 5, "", 25],
      ["a840", "", 35, "", 6],
      ["a880", "", 7, ""],
      ["a8a1", ""],
      ["a8bd", ""],
      ["a8c0", ""],
      ["a8c5", "", 36],
      ["a940", "", 8, ""],
      ["a959", ""],
      ["a95c", ""],
      ["a960", "", 9, "", 8],
      ["a980", "", 4, ""],
      ["a996", ""],
      ["a9a4", "", 75],
      ["aa40", "", 5, "", 5, "", 8],
      ["aa80", "", 7, "", 10, ""],
      ["ab40", "", 11, "", 4, "", 5, "", 4],
      ["ab80", "", 6, "", 4],
      ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11],
      ["ac80", "", 6, "", 12, "", 4, ""],
      ["ad40", "", 10, "", 7, "", 15, "", 12],
      ["ad80", "", 9, "", 8, "", 6, ""],
      ["ae40", "", 6, "", 7, "", 4, ""],
      ["ae80", "", 7, "", 6, "", 4, ""],
      ["af40", "", 4, ""],
      ["af80", ""],
      ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""],
      ["b080", "", 7, "", 8, "", 9, ""],
      ["b140", "", 4, "", 7, "", 10, ""],
      ["b180", "", 4, "", 7, "", 7, ""],
      ["b240", "", 11, "", 5, "", 11, "", 4],
      ["b280", "", 12, "", 8, "", 4, ""],
      ["b340", "", 5, ""],
      ["b380", "", 11, "", 7, "", 6, ""],
      ["b440", "", 7, "", 9],
      ["b480", "", 4, "", 5, "", 6, ""],
      ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""],
      ["b580", "", 6, "", 4, ""],
      ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""],
      ["b680", "", 6, "", 4, ""],
      ["b740", "", 14, "", 5, "", 9, "", 4, "", 16],
      ["b780", "", 6, ""],
      ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""],
      ["b880", "", 4, ""],
      ["b940", "", 5, "", 10, "", 6, ""],
      ["b980", "", 7, ""],
      ["ba40", "", 4, "", 4, "", 7, "", 5, ""],
      ["ba80", "", 4, "", 5, "", 12, "", 5, ""],
      ["bb40", "", 9, "", 36, "", 5, "", 9],
      ["bb80", "", 6, "", 4, ""],
      ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5],
      ["bc80", "", 14, "", 6, ""],
      ["bd40", "", 54, "", 7],
      ["bd80", "", 32, ""],
      ["be40", "", 12, "", 6, "", 42],
      ["be80", "", 32, ""],
      ["bf40", "", 62],
      ["bf80", "", 4, "", 4, "", 21, ""],
      ["c040", "", 35, "", 23, ""],
      ["c080", "", 6, "", 9, ""],
      ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""],
      ["c180", "", 4, "", 4, "", 5, ""],
      ["c240", "", 6, "", 5, ""],
      ["c280", "", 13, "", 5, "", 11, ""],
      ["c340", "", 5, "", 4, "", 6, ""],
      ["c380", "", 12, "", 4, ""],
      ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""],
      ["c480", "", 7, "", 5, "", 6, ""],
      ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""],
      ["c580", "", 7, "", 7, ""],
      ["c640", ""],
      ["c680", "", 4, "", 9, ""],
      ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""],
      ["c780", ""],
      ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""],
      ["c880", "", 6, "", 4, "", 4, ""],
      ["c940", "", 4, "", 7, "", 12, ""],
      ["c980", "", 4, "", 4, "", 10, ""],
      ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10],
      ["ca80", "", 4, "", 8, ""],
      ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""],
      ["cb80", "", 5, "", 6, "", 14, ""],
      ["cc40", "", 4, "", 10, "", 15, "", 13, ""],
      ["cc80", "", 11, "", 4, "", 7, ""],
      ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""],
      ["cd80", ""],
      ["ce40", "", 6, "", 5, "", 7, ""],
      ["ce80", "", 4, "", 6, "", 4, ""],
      ["cf40", "", 4, "", 4, "", 6, "", 9],
      ["cf80", "", 5, "", 7, "", 4, ""],
      ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""],
      ["d080", "", 4, "", 4, "", 5, ""],
      ["d140", "", 4, "", 4, "", 6, "", 5],
      ["d180", "", 4, "", 4, "", 4, ""],
      ["d240", "", 8, "", 24, "", 5, "", 19, ""],
      ["d280", "", 26, ""],
      ["d340", "", 30, "", 6],
      ["d380", "", 4, "", 5, "", 21, ""],
      ["d440", "", 31, "", 8, "", 21],
      ["d480", "", 25, "", 6, ""],
      ["d540", "", 7, "", 7, "", 46],
      ["d580", "", 32, ""],
      ["d640", "", 34, "", 27],
      ["d680", "", 30, ""],
      ["d740", "", 31, "", 4, "", 25],
      ["d780", "", 24, ""],
      ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""],
      ["d880", "", 6, "", 20, ""],
      ["d940", "", 62],
      ["d980", "", 32, ""],
      ["da40", "", 14, "", 8, "", 4, "", 9, ""],
      ["da80", "", 12, ""],
      ["db40", "", 6, "", 7, "", 4, ""],
      ["db80", "", 4, "", 5, "", 11, ""],
      ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7],
      ["dc80", "", 10, "", 21, ""],
      ["dd40", "", 62],
      ["dd80", "", 32, ""],
      ["de40", "", 32, ""],
      ["de80", "", 4, ""],
      ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""],
      ["df80", "", 4, ""],
      ["e040", "", 19, ""],
      ["e080", "", 10, "", 6, "", 8, ""],
      ["e140", "", 4, "", 6, "", 5, "", 5, ""],
      ["e180", "", 10, "", 9, "", 8, ""],
      ["e240", "", 62],
      ["e280", "", 32, "", 5, ""],
      ["e340", "", 45, "", 16],
      ["e380", "", 7, "", 24, ""],
      ["e440", "", 5, "", 24, "", 31],
      ["e480", "", 32, ""],
      ["e540", "", 51, "", 10],
      ["e580", "", 31, ""],
      ["e640", "", 34, "", 27],
      ["e680", "", 29, ""],
      ["e740", "", 7, "", 54],
      ["e780", "", 32, "", 6, "", 4, ""],
      ["e840", "", 14, "", 43, ""],
      ["e880", "", 20, ""],
      ["e940", "", 7, "", 42],
      ["e980", "", 32, ""],
      ["ea40", "", 27, "", 6, ""],
      ["ea80", "", 4, "", 12, ""],
      ["eb40", "", 9, "", 7, "", 9, "", 6, ""],
      ["eb80", "", 4, ""],
      ["ec40", "", 8, "", 4, "", 18, "", 7],
      ["ec80", "", 4, "", 7, "", 4, "", 4, ""],
      ["ed40", "", 6, "", 46],
      ["ed80", "", 4, "", 23, ""],
      ["ee40", "", 62],
      ["ee80", "", 32, "", 4, "", 6, ""],
      ["ef40", "", 5, "", 37, "", 4],
      ["ef80", "", 30, "", 4, "", 8, ""],
      ["f040", "", 4, "", 28, "", 26],
      ["f080", "", 9, "", 12, "", 4, "", 6, ""],
      ["f140", "", 10, "", 47],
      ["f180", "", 32, ""],
      ["f240", "", 62],
      ["f280", "", 32, ""],
      ["f340", "", 17, "", 6, "", 4, ""],
      ["f380", "", 8, "", 6, ""],
      ["f440", "", 5, "", 10, "", 10, "", 7, "", 5],
      ["f480", "", 32, ""],
      ["f540", "", 62],
      ["f580", "", 32, ""],
      ["f640", "", 62],
      ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""],
      ["f740", "", 62],
      ["f780", "", 4, "", 4, ""],
      ["f840", "", 62],
      ["f880", "", 32],
      ["f940", "", 62],
      ["f980", "", 32],
      ["fa40", "", 62],
      ["fa80", "", 32],
      ["fb40", "", 27, "", 9, ""],
      ["fb80", "", 5, "", 8, "", 5, ""],
      ["fc40", "", 8, "", 4, "", 8, "", 6],
      ["fc80", "", 4, "", 5, "", 8, ""],
      ["fd40", "", 4, "", 4, "", 10, "", 38],
      ["fd80", "", 5, "", 11, "", 4, ""],
      ["fe40", ""]
    ];
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/gbk-added.json"(exports, module) {
    module.exports = [
      ["a140", "", 62],
      ["a180", "", 32],
      ["a240", "", 62],
      ["a280", "", 32],
      ["a2ab", "", 5],
      ["a2e3", ""],
      ["a2ef", ""],
      ["a2fd", ""],
      ["a340", "", 62],
      ["a380", "", 31, ""],
      ["a440", "", 62],
      ["a480", "", 32],
      ["a4f4", "", 10],
      ["a540", "", 62],
      ["a580", "", 32],
      ["a5f7", "", 7],
      ["a640", "", 62],
      ["a680", "", 32],
      ["a6b9", "", 7],
      ["a6d9", "", 6],
      ["a6ec", ""],
      ["a6f3", ""],
      ["a6f6", "", 8],
      ["a740", "", 62],
      ["a780", "", 32],
      ["a7c2", "", 14],
      ["a7f2", "", 12],
      ["a896", "", 10],
      ["a8bc", ""],
      ["a8bf", ""],
      ["a8c1", ""],
      ["a8ea", "", 20],
      ["a958", ""],
      ["a95b", ""],
      ["a95d", ""],
      ["a989", "", 11],
      ["a997", "", 12],
      ["a9f0", "", 14],
      ["aaa1", "", 93],
      ["aba1", "", 93],
      ["aca1", "", 93],
      ["ada1", "", 93],
      ["aea1", "", 93],
      ["afa1", "", 93],
      ["d7fa", "", 4],
      ["f8a1", "", 93],
      ["f9a1", "", 93],
      ["faa1", "", 93],
      ["fba1", "", 93],
      ["fca1", "", 93],
      ["fda1", "", 93],
      ["fe50", ""],
      ["fe80", "", 6, "", 93],
      ["8135f437", ""]
    ];
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json"(exports, module) {
    module.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3] };
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/cp949.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127],
      ["8141", "", 4, "", 6, ""],
      ["8161", "", 9, "", 5, ""],
      ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""],
      ["8241", "", 7, "", 5],
      ["8261", "", 6, "", 5, ""],
      ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18],
      ["8341", "", 5, "", 5, "", 7],
      ["8361", "", 18, ""],
      ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8],
      ["8441", "", 5, "", 8],
      ["8461", "", 18],
      ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""],
      ["8541", "", 5, "", 4, "", 6, "", 4],
      ["8561", "", 5, "", 5, "", 6, ""],
      ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""],
      ["8641", "", 6, "", 5, ""],
      ["8661", "", 6, "", 10],
      ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""],
      ["8741", "", 9, "", 15],
      ["8761", "", 18, ""],
      ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4],
      ["8841", "", 4, "", 5, "", 6, "", 4],
      ["8861", "", 4, ""],
      ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""],
      ["8941", "", 6, "", 5, ""],
      ["8961", "", 10, "", 5, ""],
      ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15],
      ["8a41", "", 10, "", 6, ""],
      ["8a61", "", 4, "", 18, ""],
      ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""],
      ["8b41", "", 5, "", 4, "", 6, ""],
      ["8b61", "", 6, "", 8],
      ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18],
      ["8c41", "", 15, "", 4],
      ["8c61", "", 6, "", 5, "", 6, "", 5],
      ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16],
      ["8d41", "", 16, "", 8],
      ["8d61", "", 17, ""],
      ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""],
      ["8e41", "", 6, "", 5, "", 8],
      ["8e61", "", 4, "", 19],
      ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7],
      ["8f41", "", 7, "", 17],
      ["8f61", "", 7, "", 6, "", 4],
      ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5],
      ["9041", "", 6, "", 5, ""],
      ["9061", "", 5, "", 15],
      ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""],
      ["9141", "", 6, "", 5],
      ["9161", "", 9, "", 5],
      ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6],
      ["9241", "", 7, "", 4, ""],
      ["9261", "", 7, "", 7, "", 4],
      ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""],
      ["9341", "", 4, ""],
      ["9361", "", 6, "", 8],
      ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""],
      ["9441", "", 5, "", 5, "", 8],
      ["9461", "", 5, "", 6, "", 12],
      ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24],
      ["9541", "", 11, "", 5, ""],
      ["9561", "", 6, "", 5, ""],
      ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14],
      ["9641", "", 23, ""],
      ["9661", "", 6, "", 5, "", 8],
      ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44],
      ["9741", "", 16, "", 8],
      ["9761", "", 17, "", 7],
      ["9781", "", 11, "", 5, "", 6, "", 89, ""],
      ["9841", "", 16, "", 5, ""],
      ["9861", "", 6, "", 15],
      ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""],
      ["9941", "", 6, "", 5, ""],
      ["9961", "", 6, "", 5, ""],
      ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""],
      ["9a41", "", 16],
      ["9a61", "", 6, "", 6, ""],
      ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""],
      ["9b41", "", 6, "", 8],
      ["9b61", "", 17, "", 7],
      ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""],
      ["9c41", "", 4, "", 5, "", 5],
      ["9c61", "", 8, "", 6, "", 9],
      ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12],
      ["9d41", "", 13, "", 8],
      ["9d61", "", 25],
      ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""],
      ["9e41", "", 7, "", 9, ""],
      ["9e61", "", 4, "", 6, ""],
      ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""],
      ["9f41", "", 5, "", 4, "", 5, ""],
      ["9f61", "", 6, "", 5, ""],
      ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""],
      ["a041", "", 5, "", 6, ""],
      ["a061", "", 5, "", 13],
      ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""],
      ["a141", "", 18, ""],
      ["a161", "", 6, "", 5, ""],
      ["a181", "", 14, "", 5, "", 4, "", 9, ""],
      ["a241", "", 5, "", 18],
      ["a261", "", 6, "", 18],
      ["a281", "", 7, "", 6, "", 7, ""],
      ["a341", "", 6, "", 10, ""],
      ["a361", "", 6, "", 16],
      ["a381", "", 16, "", 4, "", 58, "", 32, ""],
      ["a441", "", 5, ""],
      ["a461", "", 5, "", 12],
      ["a481", "", 28, "", 93],
      ["a541", "", 4, "", 6, "", 5, ""],
      ["a561", "", 17, "", 5, ""],
      ["a581", "", 16, "", 14, "", 9],
      ["a5b0", "", 9],
      ["a5c1", "", 16, "", 6],
      ["a5e1", "", 16, "", 6],
      ["a641", "", 19, ""],
      ["a661", "", 5, "", 5, "", 6],
      ["a681", "", 6, "", 18, "", 7],
      ["a741", "", 4, "", 6, "", 7],
      ["a761", "", 22, ""],
      ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""],
      ["a841", "", 10, "", 14],
      ["a861", "", 18, "", 6],
      ["a881", "", 19, "", 11, ""],
      ["a8a6", ""],
      ["a8a8", ""],
      ["a8b1", "", 27, "", 25, "", 14, ""],
      ["a941", "", 14, "", 10],
      ["a961", "", 18],
      ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""],
      ["aa41", "", 6, "", 4, ""],
      ["aa61", "", 4, "", 5, "", 6, ""],
      ["aa81", "", 29, "", 82],
      ["ab41", "", 6, "", 5, ""],
      ["ab61", "", 6, "", 5, "", 5],
      ["ab81", "", 8, "", 6, "", 12, "", 85],
      ["ac41", "", 5, "", 6, ""],
      ["ac61", "", 11, "", 4],
      ["ac81", "", 28, "", 5, "", 25],
      ["acd1", "", 5, "", 25],
      ["ad41", "", 6, "", 5, "", 7],
      ["ad61", "", 6, "", 10, ""],
      ["ad81", "", 5, "", 18, ""],
      ["ae41", "", 5, "", 16],
      ["ae61", "", 5, "", 6, "", 4],
      ["ae81", "", 6, "", 5, ""],
      ["af41", "", 19],
      ["af61", "", 13, "", 5, ""],
      ["af81", "", 5, "", 6, "", 5, ""],
      ["b041", "", 5, "", 5, "", 12],
      ["b061", "", 5, "", 19],
      ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""],
      ["b141", "", 6, "", 5, ""],
      ["b161", "", 6, "", 5, "", 11],
      ["b181", "", 14, "", 6, ""],
      ["b241", "", 6, "", 5, ""],
      ["b261", "", 18, "", 5, ""],
      ["b281", "", 5, "", 18, "", 6, ""],
      ["b341", "", 19, ""],
      ["b361", "", 5, "", 5, "", 5],
      ["b381", "", 5, "", 5, "", 19, "", 4, ""],
      ["b441", "", 5, "", 6, "", 5],
      ["b461", "", 6, "", 10, ""],
      ["b481", "", 6, "", 18, "", 4, "", 4, ""],
      ["b541", "", 14, "", 5],
      ["b561", "", 5, "", 5, "", 4],
      ["b581", "", 6, "", 5, "", 11, ""],
      ["b641", "", 7, "", 17],
      ["b661", "", 15, ""],
      ["b681", "", 5, "", 6, "", 5, ""],
      ["b741", "", 13, "", 6, ""],
      ["b761", "", 20, ""],
      ["b781", "", 6, "", 14, ""],
      ["b841", "", 7, "", 17],
      ["b861", "", 8, "", 13],
      ["b881", "", 5, "", 24, "", 4, ""],
      ["b941", "", 6, "", 5, ""],
      ["b961", "", 14, "", 6, ""],
      ["b981", "", 22, "", 4, "", 4, ""],
      ["ba41", "", 5, "", 6, ""],
      ["ba61", "", 5, "", 4, "", 5],
      ["ba81", "", 6, "", 9, ""],
      ["bb41", "", 4, "", 5, "", 4, ""],
      ["bb61", "", 6, "", 5, ""],
      ["bb81", "", 31, ""],
      ["bc41", "", 17, ""],
      ["bc61", "", 5, "", 6, ""],
      ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""],
      ["bd41", "", 7, "", 7, ""],
      ["bd61", "", 5, "", 13],
      ["bd81", "", 5, "", 25, ""],
      ["be41", "", 7, "", 14],
      ["be61", "", 7, "", 7, ""],
      ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""],
      ["bf41", "", 10, "", 14],
      ["bf61", "", 18, ""],
      ["bf81", "", 5, "", 7, "", 6, "", 5, ""],
      ["c041", "", 5, "", 6, "", 5],
      ["c061", "", 25],
      ["c081", "", 6, "", 5, "", 7, ""],
      ["c141", "", 5, "", 6, ""],
      ["c161", "", 19, ""],
      ["c181", "", 31, ""],
      ["c241", "", 4, "", 5, ""],
      ["c261", "", 4, "", 5, "", 6, ""],
      ["c281", "", 5, "", 7, "", 9, ""],
      ["c341", "", 4],
      ["c361", "", 4, "", 5, "", 11],
      ["c381", "", 5, "", 7, "", 5, ""],
      ["c441", "", 7, "", 7, ""],
      ["c461", "", 5, "", 4],
      ["c481", "", 5, "", 11, ""],
      ["c541", "", 6, "", 5, ""],
      ["c561", "", 6, "", 5, "", 4],
      ["c581", "", 6, "", 5, ""],
      ["c641", "", 6, "", 5],
      ["c6a1", ""],
      ["c7a1", ""],
      ["c8a1", ""],
      ["caa1", ""],
      ["cba1", ""],
      ["cca1", ""],
      ["cda1", ""],
      ["cea1", ""],
      ["cfa1", ""],
      ["d0a1", ""],
      ["d1a1", "", 5, "", 4, ""],
      ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""],
      ["d3a1", ""],
      ["d4a1", ""],
      ["d5a1", ""],
      ["d6a1", ""],
      ["d7a1", ""],
      ["d8a1", ""],
      ["d9a1", ""],
      ["daa1", ""],
      ["dba1", ""],
      ["dca1", ""],
      ["dda1", ""],
      ["dea1", ""],
      ["dfa1", ""],
      ["e0a1", ""],
      ["e1a1", ""],
      ["e2a1", ""],
      ["e3a1", ""],
      ["e4a1", ""],
      ["e5a1", ""],
      ["e6a1", ""],
      ["e7a1", ""],
      ["e8a1", ""],
      ["e9a1", ""],
      ["eaa1", ""],
      ["eba1", ""],
      ["eca1", ""],
      ["eda1", ""],
      ["eea1", ""],
      ["efa1", ""],
      ["f0a1", ""],
      ["f1a1", ""],
      ["f2a1", ""],
      ["f3a1", ""],
      ["f4a1", ""],
      ["f5a1", ""],
      ["f6a1", ""],
      ["f7a1", ""],
      ["f8a1", ""],
      ["f9a1", ""],
      ["faa1", ""],
      ["fba1", ""],
      ["fca1", ""],
      ["fda1", ""]
    ];
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/cp950.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127],
      ["a140", ""],
      ["a1a1", "", 4, ""],
      ["a240", "", 7, ""],
      ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21],
      ["a340", "", 16, "", 6, "", 16, "", 6, "", 10],
      ["a3a1", "", 25, ""],
      ["a3e1", ""],
      ["a440", ""],
      ["a4a1", ""],
      ["a540", ""],
      ["a5a1", ""],
      ["a640", ""],
      ["a6a1", ""],
      ["a740", ""],
      ["a7a1", ""],
      ["a840", ""],
      ["a8a1", ""],
      ["a940", ""],
      ["a9a1", ""],
      ["aa40", ""],
      ["aaa1", ""],
      ["ab40", ""],
      ["aba1", ""],
      ["ac40", ""],
      ["aca1", ""],
      ["ad40", ""],
      ["ada1", ""],
      ["ae40", ""],
      ["aea1", ""],
      ["af40", ""],
      ["afa1", ""],
      ["b040", ""],
      ["b0a1", ""],
      ["b140", ""],
      ["b1a1", ""],
      ["b240", ""],
      ["b2a1", ""],
      ["b340", ""],
      ["b3a1", ""],
      ["b440", ""],
      ["b4a1", ""],
      ["b540", ""],
      ["b5a1", ""],
      ["b640", ""],
      ["b6a1", ""],
      ["b740", ""],
      ["b7a1", ""],
      ["b840", ""],
      ["b8a1", ""],
      ["b940", ""],
      ["b9a1", ""],
      ["ba40", ""],
      ["baa1", ""],
      ["bb40", ""],
      ["bba1", ""],
      ["bc40", ""],
      ["bca1", ""],
      ["bd40", ""],
      ["bda1", ""],
      ["be40", ""],
      ["bea1", ""],
      ["bf40", ""],
      ["bfa1", ""],
      ["c040", ""],
      ["c0a1", ""],
      ["c140", ""],
      ["c1a1", ""],
      ["c240", ""],
      ["c2a1", ""],
      ["c340", ""],
      ["c3a1", ""],
      ["c440", ""],
      ["c4a1", ""],
      ["c540", ""],
      ["c5a1", ""],
      ["c640", ""],
      ["c940", ""],
      ["c9a1", ""],
      ["ca40", ""],
      ["caa1", ""],
      ["cb40", ""],
      ["cba1", ""],
      ["cc40", ""],
      ["cca1", ""],
      ["cd40", ""],
      ["cda1", ""],
      ["ce40", ""],
      ["cea1", ""],
      ["cf40", ""],
      ["cfa1", ""],
      ["d040", ""],
      ["d0a1", ""],
      ["d140", ""],
      ["d1a1", ""],
      ["d240", ""],
      ["d2a1", ""],
      ["d340", ""],
      ["d3a1", ""],
      ["d440", ""],
      ["d4a1", ""],
      ["d540", ""],
      ["d5a1", ""],
      ["d640", ""],
      ["d6a1", ""],
      ["d740", ""],
      ["d7a1", ""],
      ["d840", ""],
      ["d8a1", ""],
      ["d940", ""],
      ["d9a1", ""],
      ["da40", ""],
      ["daa1", ""],
      ["db40", ""],
      ["dba1", ""],
      ["dc40", ""],
      ["dca1", ""],
      ["dd40", ""],
      ["dda1", ""],
      ["de40", ""],
      ["dea1", ""],
      ["df40", ""],
      ["dfa1", ""],
      ["e040", ""],
      ["e0a1", ""],
      ["e140", ""],
      ["e1a1", ""],
      ["e240", ""],
      ["e2a1", ""],
      ["e340", ""],
      ["e3a1", ""],
      ["e440", ""],
      ["e4a1", ""],
      ["e540", ""],
      ["e5a1", ""],
      ["e640", ""],
      ["e6a1", ""],
      ["e740", ""],
      ["e7a1", ""],
      ["e840", ""],
      ["e8a1", ""],
      ["e940", ""],
      ["e9a1", ""],
      ["ea40", ""],
      ["eaa1", ""],
      ["eb40", ""],
      ["eba1", ""],
      ["ec40", ""],
      ["eca1", ""],
      ["ed40", ""],
      ["eda1", ""],
      ["ee40", ""],
      ["eea1", ""],
      ["ef40", ""],
      ["efa1", ""],
      ["f040", ""],
      ["f0a1", ""],
      ["f140", ""],
      ["f1a1", ""],
      ["f240", ""],
      ["f2a1", ""],
      ["f340", ""],
      ["f3a1", ""],
      ["f440", ""],
      ["f4a1", ""],
      ["f540", ""],
      ["f5a1", ""],
      ["f640", ""],
      ["f6a1", ""],
      ["f740", ""],
      ["f7a1", ""],
      ["f840", ""],
      ["f8a1", ""],
      ["f940", ""],
      ["f9a1", ""]
    ];
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/tables/big5-added.json"(exports, module) {
    module.exports = [
      ["8740", ""],
      ["8767", ""],
      ["87a1", ""],
      ["8840", "", 4, ""],
      ["88a1", ""],
      ["8940", ""],
      ["8943", ""],
      ["8946", ""],
      ["894c", ""],
      ["89a1", ""],
      ["89ab", ""],
      ["89b0", ""],
      ["89b5", ""],
      ["89c1", ""],
      ["89c5", ""],
      ["8a40", ""],
      ["8a43", ""],
      ["8a64", ""],
      ["8a76", ""],
      ["8aa1", ""],
      ["8aac", ""],
      ["8ab2", ""],
      ["8abb", ""],
      ["8ac9", ""],
      ["8ace", ""],
      ["8adf", ""],
      ["8af6", ""],
      ["8b40", ""],
      ["8b55", ""],
      ["8ba1", ""],
      ["8bde", ""],
      ["8c40", ""],
      ["8ca1", ""],
      ["8ca7", ""],
      ["8cc9", ""],
      ["8cce", ""],
      ["8ce6", ""],
      ["8d40", ""],
      ["8d42", ""],
      ["8da1", ""],
      ["8e40", ""],
      ["8ea1", ""],
      ["8f40", ""],
      ["8fa1", ""],
      ["9040", ""],
      ["90a1", ""],
      ["9140", ""],
      ["91a1", ""],
      ["9240", ""],
      ["92a1", ""],
      ["9340", ""],
      ["93a1", ""],
      ["9440", ""],
      ["94a1", ""],
      ["9540", ""],
      ["95a1", ""],
      ["9640", ""],
      ["96a1", ""],
      ["9740", ""],
      ["97a1", ""],
      ["9840", ""],
      ["98a1", ""],
      ["9940", ""],
      ["99a1", ""],
      ["9a40", ""],
      ["9aa1", ""],
      ["9b40", ""],
      ["9b62", ""],
      ["9ba1", ""],
      ["9c40", ""],
      ["9ca1", ""],
      ["9d40", ""],
      ["9da1", ""],
      ["9e40", ""],
      ["9ea1", ""],
      ["9ead", ""],
      ["9ec5", ""],
      ["9ef5", ""],
      ["9f40", ""],
      ["9f4f", ""],
      ["9fa1", ""],
      ["9fae", ""],
      ["9fb2", ""],
      ["9fc1", ""],
      ["9fc9", ""],
      ["9fdb", ""],
      ["9fe7", ""],
      ["9feb", ""],
      ["9ff0", ""],
      ["a040", ""],
      ["a055", ""],
      ["a058", ""],
      ["a05b", ""],
      ["a063", ""],
      ["a073", ""],
      ["a0a1", ""],
      ["a0a6", ""],
      ["a0ae", ""],
      ["a0b0", ""],
      ["a0d4", ""],
      ["a0e2", ""],
      ["a3c0", "", 31, ""],
      ["c6a1", "", 9, "", 9, "", 9, "", 23],
      ["c740", "", 58, ""],
      ["c7a1", "", 81, "", 5, "", 4],
      ["c840", "", 26, "", 25, ""],
      ["c8a1", ""],
      ["c8cd", ""],
      ["c8f5", ""],
      ["f9fe", ""],
      ["fa40", ""],
      ["faa1", ""],
      ["fb40", ""],
      ["fba1", ""],
      ["fc40", ""],
      ["fca1", ""],
      ["fd40", ""],
      ["fda1", ""],
      ["fe40", ""],
      ["fea1", ""]
    ];
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/dbcs-data.js"(exports, module) {
    "use strict";
    module.exports = {
      // == Japanese/ShiftJIS ====================================================
      // All japanese encodings are based on JIS X set of standards:
      // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
      // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes.
      //              Has several variations in 1978, 1983, 1990 and 1997.
      // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
      // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
      //              2 planes, first is superset of 0208, second - revised 0212.
      //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
      // Byte encodings are:
      //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
      //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
      //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
      //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
      //               0x00-0x7F       - lower part of 0201
      //               0x8E, 0xA1-0xDF - upper part of 0201
      //               (0xA1-0xFE)x2   - 0208 plane (94x94).
      //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
      //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
      //               Used as-is in ISO2022 family.
      //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII,
      //                0201-1976 Roman, 0208-1978, 0208-1983.
      //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
      //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
      //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
      //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
      //
      // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
      //
      // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
      shiftjis: {
        type: "_dbcs",
        table: function() {
          return require_shiftjis();
        },
        encodeAdd: { "": 92, "": 126 },
        encodeSkipVals: [{ from: 60736, to: 63808 }]
      },
      csshiftjis: "shiftjis",
      mskanji: "shiftjis",
      sjis: "shiftjis",
      windows31j: "shiftjis",
      ms31j: "shiftjis",
      xsjis: "shiftjis",
      windows932: "shiftjis",
      ms932: "shiftjis",
      932: "shiftjis",
      cp932: "shiftjis",
      eucjp: {
        type: "_dbcs",
        table: function() {
          return require_eucjp();
        },
        encodeAdd: { "": 92, "": 126 }
      },
      // TODO: KDDI extension to Shift_JIS
      // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
      // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
      // == Chinese/GBK ==========================================================
      // http://en.wikipedia.org/wiki/GBK
      // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
      // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
      gb2312: "cp936",
      gb231280: "cp936",
      gb23121980: "cp936",
      csgb2312: "cp936",
      csiso58gb231280: "cp936",
      euccn: "cp936",
      // Microsoft's CP936 is a subset and approximation of GBK.
      windows936: "cp936",
      ms936: "cp936",
      936: "cp936",
      cp936: {
        type: "_dbcs",
        table: function() {
          return require_cp936();
        }
      },
      // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
      gbk: {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        }
      },
      xgbk: "gbk",
      isoir58: "gbk",
      // GB18030 is an algorithmic extension of GBK.
      // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
      // http://icu-project.org/docs/papers/gb18030.html
      // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
      // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
      gb18030: {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        },
        gb18030: function() {
          return require_gb18030_ranges();
        },
        encodeSkipVals: [128],
        encodeAdd: { "": 41699 }
      },
      chinese: "gb18030",
      // == Korean ===============================================================
      // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
      windows949: "cp949",
      ms949: "cp949",
      949: "cp949",
      cp949: {
        type: "_dbcs",
        table: function() {
          return require_cp949();
        }
      },
      cseuckr: "cp949",
      csksc56011987: "cp949",
      euckr: "cp949",
      isoir149: "cp949",
      korean: "cp949",
      ksc56011987: "cp949",
      ksc56011989: "cp949",
      ksc5601: "cp949",
      // == Big5/Taiwan/Hong Kong ================================================
      // There are lots of tables for Big5 and cp950. Please see the following links for history:
      // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
      // Variations, in roughly number of defined chars:
      //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
      //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
      //  * Big5-2003 (Taiwan standard) almost superset of cp950.
      //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
      //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard.
      //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
      //    Plus, it has 4 combining sequences.
      //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
      //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
      //    Implementations are not consistent within browsers; sometimes labeled as just big5.
      //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
      //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
      //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
      //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
      //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
      //
      // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
      // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
      windows950: "cp950",
      ms950: "cp950",
      950: "cp950",
      cp950: {
        type: "_dbcs",
        table: function() {
          return require_cp950();
        }
      },
      // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
      big5: "big5hkscs",
      big5hkscs: {
        type: "_dbcs",
        table: function() {
          return require_cp950().concat(require_big5_added());
        },
        encodeSkipVals: [
          // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
          // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
          // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
          36457,
          36463,
          36478,
          36523,
          36532,
          36557,
          36560,
          36695,
          36713,
          36718,
          36811,
          36862,
          36973,
          36986,
          37060,
          37084,
          37105,
          37311,
          37551,
          37552,
          37553,
          37554,
          37585,
          37959,
          38090,
          38361,
          38652,
          39285,
          39798,
          39800,
          39803,
          39878,
          39902,
          39916,
          39926,
          40002,
          40019,
          40034,
          40040,
          40043,
          40055,
          40124,
          40125,
          40144,
          40279,
          40282,
          40388,
          40431,
          40443,
          40617,
          40687,
          40701,
          40800,
          40907,
          41079,
          41180,
          41183,
          36812,
          37576,
          38468,
          38637,
          // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
          41636,
          41637,
          41639,
          41638,
          41676,
          41678
        ]
      },
      cnbig5: "big5hkscs",
      csbig5: "big5hkscs",
      xxbig5: "big5hkscs"
    };
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/encodings/index.js"(exports, module) {
    "use strict";
    var mergeModules = require_merge_exports();
    var modules = [
      require_internal(),
      require_utf32(),
      require_utf16(),
      require_utf7(),
      require_sbcs_codec(),
      require_sbcs_data(),
      require_sbcs_data_generated(),
      require_dbcs_codec(),
      require_dbcs_data()
    ];
    for (i = 0; i < modules.length; i++) {
      module = modules[i];
      mergeModules(exports, module);
    }
    var module;
    var i;
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/lib/streams.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    module.exports = function(streamModule) {
      var Transform = streamModule.Transform;
      function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false;
        Transform.call(this, options);
      }
      IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteEncoderStream }
      });
      IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk !== "string") {
          return done(new Error("Iconv encoding stream needs strings as its input."));
        }
        try {
          var res = this.conv.write(chunk);
          if (res && res.length) this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length) this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on("error", cb);
        this.on("data", function(chunk) {
          chunks.push(chunk);
        });
        this.on("end", function() {
          cb(null, Buffer2.concat(chunks));
        });
        return this;
      };
      function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = "utf8";
        Transform.call(this, options);
      }
      IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteDecoderStream }
      });
      IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array)) {
          return done(new Error("Iconv decoding stream needs buffers as its input."));
        }
        try {
          var res = this.conv.write(chunk);
          if (res && res.length) this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length) this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = "";
        this.on("error", cb);
        this.on("data", function(chunk) {
          res += chunk;
        });
        this.on("end", function() {
          cb(null, res);
        });
        return this;
      };
      return {
        IconvLiteEncoderStream,
        IconvLiteDecoderStream
      };
    };
  }
});

// ../node_modules/imapflow/node_modules/iconv-lite/lib/index.js
var require_lib = __commonJS({
  "../node_modules/imapflow/node_modules/iconv-lite/lib/index.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    var bomHandling = require_bom_handling();
    var mergeModules = require_merge_exports();
    var iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = { __proto__: null };
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings) {
        var raw = require_encodings();
        iconv.encodings = { __proto__: null };
        mergeModules(iconv.encodings, raw);
      }
      var enc = iconv._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec) {
          return codec;
        }
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef) {
              codecOptions[key] = codecDef[key];
            }
            if (!codecOptions.encodingName) {
              codecOptions.encodingName = enc;
            }
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName) {
              codecOptions.encodingName = enc;
            }
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding);
      var encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM) {
        encoder = new bomHandling.PrependBOM(encoder, options);
      }
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding);
      var decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false)) {
        decoder = new bomHandling.StripBOM(decoder, options);
      }
      return decoder;
    };
    iconv.enableStreamingAPI = function enableStreamingAPI(streamModule2) {
      if (iconv.supportsStreams) {
        return;
      }
      var streams = require_streams()(streamModule2);
      iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
      iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
      };
      iconv.supportsStreams = true;
    };
    var streamModule;
    try {
      streamModule = require_stream();
    } catch (e) {
    }
    if (streamModule && streamModule.Transform) {
      iconv.enableStreamingAPI(streamModule);
    } else {
      iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
    if (false) {
      console.error("iconv-lite warning: js files use non-utf8 encoding. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
    }
  }
});

// ../node_modules/imapflow/lib/tools.js
var require_tools = __commonJS({
  "../node_modules/imapflow/lib/tools.js"(exports, module) {
    "use strict";
    var libmime = require_libmime();
    var { resolveCharset } = require_charsets();
    var { compiler } = require_imap_handler();
    var { createHash } = require_crypto();
    var { JPDecoder } = require_jp_decoder();
    var iconv = require_lib();
    var FLAG_COLORS = ["red", "orange", "yellow", "green", "blue", "purple", "grey"];
    var AuthenticationFailure = class extends Error {
      constructor() {
        super(...arguments);
        __publicField(this, "authenticationFailed", true);
      }
    };
    var tools = {
      encodePath(connection, path) {
        path = (path || "").toString();
        if (!connection.enabled.has("UTF8=ACCEPT") && /[&\x00-\x08\x0b-\x0c\x0e-\x1f\u0080-\uffff]/.test(path)) {
          try {
            path = iconv.encode(path, "utf-7-imap").toString();
          } catch {
          }
        }
        return path;
      },
      decodePath(connection, path) {
        path = (path || "").toString();
        if (!connection.enabled.has("UTF8=ACCEPT") && /[&]/.test(path)) {
          try {
            path = iconv.decode(Buffer.from(path), "utf-7-imap").toString();
          } catch {
          }
        }
        return path;
      },
      normalizePath(connection, path, skipNamespace) {
        if (Array.isArray(path)) {
          path = path.join(connection.namespace && connection.namespace.delimiter || "");
        }
        if (path.toUpperCase() === "INBOX") {
          return "INBOX";
        }
        if (!skipNamespace && connection.namespace && connection.namespace.prefix && path.indexOf(connection.namespace.prefix) !== 0) {
          path = connection.namespace.prefix + path;
        }
        return path;
      },
      comparePaths(connection, a, b) {
        if (!a || !b) {
          return false;
        }
        return tools.normalizePath(connection, a) === tools.normalizePath(connection, b);
      },
      updateCapabilities(list) {
        let map = /* @__PURE__ */ new Map();
        if (list && Array.isArray(list)) {
          list.forEach((val) => {
            if (typeof val.value !== "string") {
              return false;
            }
            let capability = val.value.toUpperCase().trim();
            if (capability === "IMAP4REV1") {
              map.set("IMAP4rev1", true);
              return;
            }
            if (capability.indexOf("APPENDLIMIT=") === 0) {
              let splitPos = capability.indexOf("=");
              let appendLimit = Number(capability.substr(splitPos + 1)) || 0;
              map.set("APPENDLIMIT", appendLimit);
              return;
            }
            map.set(capability, true);
          });
        }
        return map;
      },
      AuthenticationFailure,
      getStatusCode(response) {
        return response && response.attributes && response.attributes[0] && response.attributes[0].section && response.attributes[0].section[0] && typeof response.attributes[0].section[0].value === "string" ? response.attributes[0].section[0].value.toUpperCase().trim() : false;
      },
      async getErrorText(response) {
        if (!response) {
          return false;
        }
        return (await compiler(response)).toString();
      },
      getFolderTree(folders) {
        let tree = {
          root: true,
          folders: []
        };
        let getTreeNode = (parents) => {
          let node = tree;
          if (!parents || !parents.length) {
            return node;
          }
          for (let parent of parents) {
            let cur = node.folders && node.folders.find((folder) => folder.name === parent);
            if (cur) {
              node = cur;
            } else {
              cur = {
                name: parent,
                folders: []
              };
            }
          }
          return node;
        };
        for (let folder of folders) {
          let parent = getTreeNode(folder.parent);
          let existing = parent.folders && parent.folders.find((existing2) => existing2.name === folder.name);
          if (existing) {
            existing.name = folder.name;
            existing.flags = folder.flags;
            existing.path = folder.path;
            existing.subscribed = !!folder.subscribed;
            existing.listed = !!folder.listed;
            existing.status = !!folder.status;
            if (folder.specialUse) {
              existing.specialUse = folder.specialUse;
            }
            if (folder.flags.has("\\Noselect")) {
              existing.disabled = true;
            }
            if (folder.flags.has("\\HasChildren") && !existing.folders) {
              existing.folders = [];
            }
          } else {
            let data = {
              name: folder.name,
              flags: folder.flags,
              path: folder.path,
              subscribed: !!folder.subscribed,
              listed: !!folder.listed,
              status: !!folder.status
            };
            if (folder.delimiter) {
              data.delimiter = folder.delimiter;
            }
            if (folder.specialUse) {
              data.specialUse = folder.specialUse;
            }
            if (folder.flags.has("\\Noselect")) {
              data.disabled = true;
            }
            if (folder.flags.has("\\HasChildren")) {
              data.folders = [];
            }
            if (!parent.folders) {
              parent.folders = [];
            }
            parent.folders.push(data);
          }
        }
        return tree;
      },
      getFlagColor(flags) {
        if (!flags.has("\\Flagged")) {
          return null;
        }
        const bit0 = flags.has("$MailFlagBit0") ? 1 : 0;
        const bit1 = flags.has("$MailFlagBit1") ? 2 : 0;
        const bit2 = flags.has("$MailFlagBit2") ? 4 : 0;
        const color = bit0 | bit1 | bit2;
        return FLAG_COLORS[color] || "red";
      },
      getColorFlags(color) {
        const colorCode = color ? FLAG_COLORS.indexOf((color || "").toString().toLowerCase().trim()) : null;
        if (colorCode < 0 && colorCode !== null) {
          return null;
        }
        const bits = [];
        bits[0] = colorCode & 1;
        bits[1] = colorCode & 2;
        bits[2] = colorCode & 4;
        let result = { add: colorCode ? ["\\Flagged"] : [], remove: colorCode ? [] : ["\\Flagged"] };
        for (let i = 0; i < bits.length; i++) {
          if (bits[i]) {
            result.add.push(`$MailFlagBit${i}`);
          } else {
            result.remove.push(`$MailFlagBit${i}`);
          }
        }
        return result;
      },
      async formatMessageResponse(untagged, mailbox) {
        var _a;
        let map = {};
        map.seq = Number(untagged.command);
        let key;
        let attributes = untagged.attributes && untagged.attributes[1] || [];
        for (let i = 0, len = attributes.length; i < len; i++) {
          let attribute = attributes[i];
          if (i % 2 === 0) {
            key = (await compiler({
              attributes: [attribute]
            })).toString().toLowerCase().replace(/<\d+(\.\d+)?>$/, "");
            continue;
          }
          if (typeof key !== "string") {
            continue;
          }
          let getString = (attribute2) => {
            if (!attribute2) {
              return false;
            }
            if (typeof attribute2.value === "string") {
              return attribute2.value;
            }
            if (Buffer.isBuffer(attribute2.value)) {
              return attribute2.value.toString();
            }
          };
          let getBuffer = (attribute2) => {
            if (!attribute2) {
              return false;
            }
            if (Buffer.isBuffer(attribute2.value)) {
              return attribute2.value;
            }
          };
          let getArray = (attribute2) => {
            if (Array.isArray(attribute2)) {
              return attribute2.map((entry) => entry && typeof entry.value === "string" ? entry.value : false).filter((entry) => entry);
            }
          };
          switch (key) {
            case "body[]":
            case "binary[]":
              map.source = getBuffer(attribute);
              break;
            case "uid":
              map.uid = Number(getString(attribute));
              if (map.uid && (!mailbox.uidNext || mailbox.uidNext <= map.uid)) {
                mailbox.uidNext = map.uid + 1;
              }
              break;
            case "modseq":
              map.modseq = BigInt(getArray(attribute)[0]);
              if (map.modseq && (!mailbox.highestModseq || mailbox.highestModseq < map.modseq)) {
                mailbox.highestModseq = map.modseq;
              }
              break;
            case "emailid":
              map.emailId = getArray(attribute)[0];
              break;
            case "x-gm-msgid":
              map.emailId = getString(attribute);
              break;
            case "threadid":
              map.threadId = getArray(attribute)[0];
              break;
            case "x-gm-thrid":
              map.threadId = getString(attribute);
              break;
            case "x-gm-labels":
              map.labels = new Set(getArray(attribute));
              break;
            case "rfc822.size":
              map.size = Number(getString(attribute)) || 0;
              break;
            case "flags":
              map.flags = new Set(getArray(attribute));
              break;
            case "envelope":
              map.envelope = tools.parseEnvelope(attribute);
              break;
            case "bodystructure":
              map.bodyStructure = tools.parseBodystructure(attribute);
              break;
            case "internaldate": {
              let value = getString(attribute);
              let date = new Date(value);
              if (date.toString() === "Invalid Date") {
                map.internalDate = value;
              } else {
                map.internalDate = date;
              }
              break;
            }
            default: {
              let match = key.match(/(body|binary)\[/i);
              if (match) {
                let partKey = key.replace(/^(body|binary)\[|]$/gi, "");
                partKey = partKey.replace(/\.fields.*$/g, "");
                let value = getBuffer(attribute);
                if (partKey === "header") {
                  map.headers = value;
                  break;
                }
                if (!map.bodyParts) {
                  map.bodyParts = /* @__PURE__ */ new Map();
                }
                map.bodyParts.set(partKey, value);
                break;
              }
              break;
            }
          }
        }
        if (map.emailId || map.uid) {
          let path = mailbox.path;
          if (/[0x80-0xff]/.test(path)) {
            try {
              path = iconv.encode(path, "utf-7-imap").toString();
            } catch {
            }
          }
          map.id = map.emailId || createHash("md5").update([path, ((_a = mailbox.uidValidity) == null ? void 0 : _a.toString()) || "", map.uid.toString()].join(":")).digest("hex");
        }
        if (map.flags) {
          let flagColor = tools.getFlagColor(map.flags);
          if (flagColor) {
            map.flagColor = flagColor;
          }
        }
        return map;
      },
      processName(name) {
        name = (name || "").toString();
        if (name.length > 2 && name.at(0) === '"' && name.at(-1) === '"') {
          name = name.replace(/^"|"$/g, "");
        }
        return name;
      },
      parseEnvelope(entry) {
        let getStrValue = (obj) => {
          if (!obj) {
            return false;
          }
          if (typeof obj.value === "string") {
            return obj.value;
          }
          if (Buffer.isBuffer(obj.value)) {
            return obj.value.toString();
          }
          return obj.value;
        };
        let processAddresses = function(list) {
          return [].concat(list || []).map((addr) => {
            let address = (getStrValue(addr[2]) || "") + "@" + (getStrValue(addr[3]) || "");
            if (address === "@") {
              address = "";
            }
            return {
              name: tools.processName(libmime.decodeWords(getStrValue(addr[0]))),
              address
            };
          }).filter((addr) => addr.name || addr.address);
        }, envelope = {};
        if (entry[0] && entry[0].value) {
          let date = new Date(getStrValue(entry[0]));
          if (date.toString() === "Invalid Date") {
            envelope.date = getStrValue(entry[0]);
          } else {
            envelope.date = date;
          }
        }
        if (entry[1] && entry[1].value) {
          envelope.subject = libmime.decodeWords(getStrValue(entry[1]));
        }
        if (entry[2] && entry[2].length) {
          envelope.from = processAddresses(entry[2]);
        }
        if (entry[3] && entry[3].length) {
          envelope.sender = processAddresses(entry[3]);
        }
        if (entry[4] && entry[4].length) {
          envelope.replyTo = processAddresses(entry[4]);
        }
        if (entry[5] && entry[5].length) {
          envelope.to = processAddresses(entry[5]);
        }
        if (entry[6] && entry[6].length) {
          envelope.cc = processAddresses(entry[6]);
        }
        if (entry[7] && entry[7].length) {
          envelope.bcc = processAddresses(entry[7]);
        }
        if (entry[8] && entry[8].value) {
          envelope.inReplyTo = (getStrValue(entry[8]) || "").toString().trim();
        }
        if (entry[9] && entry[9].value) {
          envelope.messageId = (getStrValue(entry[9]) || "").toString().trim();
        }
        return envelope;
      },
      getStructuredParams(arr) {
        let key;
        let params = {};
        [].concat(arr || []).forEach((val, j) => {
          if (j % 2) {
            params[key] = libmime.decodeWords((val && val.value || "").toString());
          } else {
            key = (val && val.value || "").toString().toLowerCase();
          }
        });
        if (params.filename && !params["filename*"] && /^[a-z\-_0-9]+'[a-z]*'[^'\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]+/.test(params.filename)) {
          let [encoding, , encodedValue] = params.filename.split("'");
          if (resolveCharset(encoding)) {
            params["filename*"] = `${encoding}''${encodedValue}`;
          }
        }
        Object.keys(params).forEach((key2) => {
          let actualKey;
          let nr;
          let value;
          let match = key2.match(/\*((\d+)\*?)?$/);
          if (!match) {
            return;
          }
          actualKey = key2.substr(0, match.index).toLowerCase();
          nr = Number(match[2]) || 0;
          if (!params[actualKey] || typeof params[actualKey] !== "object") {
            params[actualKey] = {
              charset: false,
              values: []
            };
          }
          value = params[key2];
          if (nr === 0 && match[0].charAt(match[0].length - 1) === "*" && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {
            params[actualKey].charset = match[1] || "utf-8";
            value = match[2];
          }
          params[actualKey].values.push({ nr, value });
          delete params[key2];
        });
        Object.keys(params).forEach((key2) => {
          let value;
          if (params[key2] && Array.isArray(params[key2].values)) {
            value = params[key2].values.sort((a, b) => a.nr - b.nr).map((val) => val && val.value || "").join("");
            if (params[key2].charset) {
              params[key2] = libmime.decodeWords(
                "=?" + params[key2].charset + "?Q?" + value.replace(/[=?_\s]/g, (s) => {
                  let c = s.charCodeAt(0).toString(16);
                  if (s === " ") {
                    return "_";
                  } else {
                    return "%" + (c.length < 2 ? "0" : "") + c;
                  }
                }).replace(/%/g, "=") + "?="
              );
            } else {
              params[key2] = libmime.decodeWords(value);
            }
          }
        });
        return params;
      },
      parseBodystructure(entry) {
        let walk = (node, path) => {
          path = path || [];
          let curNode = {}, i = 0, part = 0;
          if (path.length) {
            curNode.part = path.join(".");
          }
          if (Array.isArray(node[0])) {
            curNode.childNodes = [];
            while (Array.isArray(node[i])) {
              curNode.childNodes.push(walk(node[i], path.concat(++part)));
              i++;
            }
            curNode.type = "multipart/" + ((node[i++] || {}).value || "").toString().toLowerCase();
            if (i < node.length - 1) {
              if (node[i]) {
                curNode.parameters = tools.getStructuredParams(node[i]);
              }
              i++;
            }
          } else {
            curNode.type = [((node[i++] || {}).value || "").toString().toLowerCase(), ((node[i++] || {}).value || "").toString().toLowerCase()].join("/");
            if (node[i]) {
              curNode.parameters = tools.getStructuredParams(node[i]);
            }
            i++;
            if (node[i]) {
              curNode.id = ((node[i] || {}).value || "").toString();
            }
            i++;
            if (node[i]) {
              curNode.description = ((node[i] || {}).value || "").toString();
            }
            i++;
            if (node[i]) {
              curNode.encoding = ((node[i] || {}).value || "").toString().toLowerCase();
            }
            i++;
            if (node[i]) {
              curNode.size = Number((node[i] || {}).value || 0) || 0;
            }
            i++;
            if (curNode.type === "message/rfc822") {
              if (node[i]) {
                curNode.envelope = tools.parseEnvelope([].concat(node[i] || []));
              }
              i++;
              if (node[i]) {
                curNode.childNodes = [
                  // rfc822 bodyparts share the same path, difference is between MIME and HEADER
                  // path.MIME returns message/rfc822 header
                  // path.HEADER returns inlined message header
                  walk(node[i], path)
                ];
              }
              i++;
              if (node[i]) {
                curNode.lineCount = Number((node[i] || {}).value || 0) || 0;
              }
              i++;
            }
            if (/^text\//.test(curNode.type)) {
              if (node.length === 11 && Array.isArray(node[i + 1]) && !Array.isArray(node[i + 2])) {
              } else {
                if (node[i]) {
                  curNode.lineCount = Number((node[i] || {}).value || 0) || 0;
                }
                i++;
              }
            }
            if (i < node.length - 1) {
              if (node[i]) {
                curNode.md5 = ((node[i] || {}).value || "").toString().toLowerCase();
              }
              i++;
            }
          }
          if (i < node.length - 1) {
            if (Array.isArray(node[i]) && node[i].length) {
              curNode.disposition = ((node[i][0] || {}).value || "").toString().toLowerCase();
              if (Array.isArray(node[i][1])) {
                curNode.dispositionParameters = tools.getStructuredParams(node[i][1]);
              }
            }
            i++;
          }
          if (i < node.length - 1) {
            if (node[i]) {
              curNode.language = [].concat(node[i] || []).map((val) => (val && val.value || "").toString().toLowerCase());
            }
            i++;
          }
          if (i < node.length - 1) {
            if (node[i]) {
              curNode.location = ((node[i] || {}).value || "").toString();
            }
            i++;
          }
          return curNode;
        };
        return walk(entry);
      },
      isDate(obj) {
        return Object.prototype.toString.call(obj) === "[object Date]";
      },
      formatDate(value) {
        if (typeof value === "string") {
          value = new Date(value);
        }
        if (Object.prototype.toString(value) !== "[object Object]" || value.toString() === "Invalid Date") {
          return;
        }
        value = value.toISOString().substr(0, 10);
        value = value.split("-");
        value.reverse();
        let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        value[1] = months[Number(value[1]) - 1];
        return value.join("-");
      },
      formatDateTime(value) {
        if (!value) {
          return;
        }
        if (typeof value === "string") {
          value = new Date(value);
        }
        if (Object.prototype.toString(value) !== "[object Object]" || value.toString() === "Invalid Date") {
          return;
        }
        let dateStr = tools.formatDate(value).replace(/^0/, " ");
        let timeStr = value.toISOString().substr(11, 8);
        return `${dateStr} ${timeStr} +0000`;
      },
      formatFlag(flag) {
        switch (flag.toLowerCase()) {
          case "\\recent":
            return false;
          case "\\seen":
          case "\\answered":
          case "\\flagged":
          case "\\deleted":
          case "\\draft":
            return flag.toLowerCase().replace(/^\\./, (c) => c.toUpperCase());
        }
        return flag;
      },
      canUseFlag(mailbox, flag) {
        return !mailbox || !mailbox.permanentFlags || mailbox.permanentFlags.has("\\*") || mailbox.permanentFlags.has(flag);
      },
      expandRange(range) {
        return range.split(",").flatMap((entry) => {
          entry = entry.trim();
          let colon = entry.indexOf(":");
          if (colon < 0) {
            return Number(entry) || 0;
          }
          let first = Number(entry.substr(0, colon)) || 0;
          let second = Number(entry.substr(colon + 1)) || 0;
          if (first === second) {
            return first;
          }
          let list = [];
          if (first < second) {
            for (let i = first; i <= second; i++) {
              list.push(i);
            }
          } else {
            for (let i = first; i >= second; i--) {
              list.push(i);
            }
          }
          return list;
        });
      },
      getDecoder(charset) {
        charset = (charset || "ascii").toString().trim().toLowerCase();
        if (/^jis|^iso-?2022-?jp|^EUCJP/i.test(charset)) {
          return new JPDecoder(charset);
        }
        return iconv.decodeStream(charset);
      },
      packMessageRange(list) {
        if (!Array.isArray(list)) {
          list = [].concat(list || []);
        }
        if (!list.length) {
          return "";
        }
        list.sort((a, b) => a - b);
        let last = list[list.length - 1];
        let result = [[last]];
        for (let i = list.length - 2; i >= 0; i--) {
          if (list[i] === list[i + 1] - 1) {
            result[0].unshift(list[i]);
            continue;
          }
          result.unshift([list[i]]);
        }
        result = result.map((item) => {
          if (item.length === 1) {
            return item[0];
          }
          return item.shift() + ":" + item.pop();
        });
        return result.join(",");
      }
    };
    module.exports = tools;
  }
});

// ../node_modules/imapflow/lib/commands/id.js
var require_id = __commonJS({
  "../node_modules/imapflow/lib/commands/id.js"(exports, module) {
    "use strict";
    var { formatDateTime } = require_tools();
    module.exports = async (connection, clientInfo) => {
      if (!connection.capabilities.has("ID")) {
        return;
      }
      let response;
      try {
        let map = {};
        let formattedClientInfo = !clientInfo ? null : Object.keys(clientInfo).map((key) => [key, formatValue(key, clientInfo[key])]).filter((entry) => entry[1]).flatMap((entry) => entry);
        if (formattedClientInfo && !formattedClientInfo.length) {
          formattedClientInfo = null;
        }
        response = await connection.exec("ID", [formattedClientInfo], {
          untagged: {
            ID: async (untagged) => {
              let params = untagged.attributes && untagged.attributes[0];
              let key;
              (Array.isArray(params) ? params : [].concat(params || [])).forEach((val, i) => {
                if (i % 2 === 0) {
                  key = val.value;
                } else if (typeof key === "string" && typeof val.value === "string") {
                  map[key.toLowerCase().trim()] = val.value;
                }
              });
            }
          }
        });
        connection.serverInfo = map;
        response.next();
        return map;
      } catch (err) {
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
    function formatValue(key, value) {
      switch (key.toLowerCase()) {
        case "date":
          return formatDateTime(value);
        default:
          return (value || "").toString().replace(/\s+/g, " ");
      }
    }
  }
});

// ../node_modules/imapflow/lib/commands/capability.js
var require_capability = __commonJS({
  "../node_modules/imapflow/lib/commands/capability.js"(exports, module) {
    "use strict";
    module.exports = async (connection) => {
      if (connection.capabilities.size && !connection.expectCapabilityUpdate) {
        return connection.capabilities;
      }
      let response;
      try {
        response = await connection.exec("CAPABILITY");
        response.next();
        return connection.capabilities;
      } catch (err) {
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/namespace.js
var require_namespace = __commonJS({
  "../node_modules/imapflow/lib/commands/namespace.js"(exports, module) {
    "use strict";
    module.exports = async (connection) => {
      if (![connection.states.AUTHENTICATED, connection.states.SELECTED].includes(connection.state)) {
        return;
      }
      if (!connection.capabilities.has("NAMESPACE")) {
        let { prefix, delimiter } = await getListPrefix(connection);
        if (delimiter && prefix && prefix.charAt(prefix.length - 1) !== delimiter) {
          prefix += delimiter;
        }
        let map = {
          personal: [{ prefix: prefix || "", delimiter }],
          other: false,
          shared: false
        };
        connection.namespaces = map;
        connection.namespace = connection.namespaces.personal[0];
        return connection.namespace;
      }
      let response;
      try {
        let map = {};
        response = await connection.exec("NAMESPACE", false, {
          untagged: {
            NAMESPACE: async (untagged) => {
              if (!untagged.attributes || !untagged.attributes.length) {
                return;
              }
              map.personal = getNamsepaceInfo(untagged.attributes[0]);
              map.other = getNamsepaceInfo(untagged.attributes[1]);
              map.shared = getNamsepaceInfo(untagged.attributes[2]);
            }
          }
        });
        connection.namespaces = map;
        if (!connection.namespaces.personal[0]) {
          connection.namespaces.personal[0] = { prefix: "", delimiter: "." };
        }
        connection.namespaces.personal[0].prefix = connection.namespaces.personal[0].prefix || "";
        response.next();
        connection.namespace = connection.namespaces.personal[0];
        return connection.namespace;
      } catch (err) {
        connection.log.warn({ err, cid: connection.id });
        return {
          error: true,
          status: err.responseStatus,
          text: err.responseText
        };
      }
    };
    async function getListPrefix(connection) {
      let response;
      try {
        let map = {};
        response = await connection.exec("LIST", ["", ""], {
          untagged: {
            LIST: async (untagged) => {
              if (!untagged.attributes || !untagged.attributes.length) {
                return;
              }
              map.flags = new Set(untagged.attributes[0].map((entry) => entry.value));
              map.delimiter = untagged.attributes[1] && untagged.attributes[1].value;
              map.prefix = untagged.attributes[2] && untagged.attributes[2].value || "";
              if (map.delimiter && map.prefix.charAt(0) === map.delimiter) {
                map.prefix = map.prefix.slice(1);
              }
            }
          }
        });
        response.next();
        return map;
      } catch (err) {
        connection.log.warn({ err, cid: connection.id });
        return {};
      }
    }
    function getNamsepaceInfo(attribute) {
      if (!attribute || !attribute.length) {
        return false;
      }
      return attribute.filter((entry) => entry.length >= 2 && typeof entry[0].value === "string" && typeof entry[1].value === "string").map((entry) => {
        let prefix = entry[0].value;
        let delimiter = entry[1].value;
        if (delimiter && prefix && prefix.charAt(prefix.length - 1) !== delimiter) {
          prefix += delimiter;
        }
        return { prefix, delimiter };
      });
    }
  }
});

// ../node_modules/imapflow/lib/commands/login.js
var require_login = __commonJS({
  "../node_modules/imapflow/lib/commands/login.js"(exports, module) {
    "use strict";
    var { getStatusCode, getErrorText } = require_tools();
    module.exports = async (connection, username, password) => {
      if (connection.state !== connection.states.NOT_AUTHENTICATED) {
        return;
      }
      try {
        let response = await connection.exec("LOGIN", [
          { type: "STRING", value: username },
          { type: "STRING", value: password, sensitive: true }
        ]);
        response.next();
        connection.authCapabilities.set("LOGIN", true);
        return username;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.authenticationFailed = true;
        err.response = await getErrorText(err.response);
        throw err;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/logout.js
var require_logout = __commonJS({
  "../node_modules/imapflow/lib/commands/logout.js"(exports, module) {
    "use strict";
    module.exports = async (connection) => {
      if (connection.state === connection.states.LOGOUT) {
        return false;
      }
      if (connection.state === connection.states.NOT_AUTHENTICATED) {
        connection.state = connection.states.LOGOUT;
        connection.close();
        return false;
      }
      let response;
      try {
        response = await connection.exec("LOGOUT");
        return true;
      } catch (err) {
        if (err.code === "NoConnection") {
          return true;
        }
        connection.log.warn({ err, cid: connection.id });
        return false;
      } finally {
        connection.state = connection.states.LOGOUT;
        if (response && typeof response.next === "function") {
          response.next();
        }
        connection.close();
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/starttls.js
var require_starttls = __commonJS({
  "../node_modules/imapflow/lib/commands/starttls.js"(exports, module) {
    "use strict";
    module.exports = async (connection) => {
      if (!connection.capabilities.has("STARTTLS") || connection.secureConnection) {
        return false;
      }
      let response;
      try {
        response = await connection.exec("STARTTLS");
        response.next();
        return true;
      } catch (err) {
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/special-use.js
var require_special_use = __commonJS({
  "../node_modules/imapflow/lib/special-use.js"(exports, module) {
    "use strict";
    module.exports = {
      flags: ["\\All", "\\Archive", "\\Drafts", "\\Flagged", "\\Junk", "\\Sent", "\\Trash"],
      names: {
        "\\Sent": [
          "aika",
          "bidaliak",
          "bidalita",
          "dihantar",
          "e rometsweng",
          "e tindami",
          "elkldtt",
          "elkldttek",
          "elementos enviados",
          "lments envoys",
          "enviadas",
          "enviadas",
          "enviados",
          "enviats",
          "envoys",
          "ethunyelweyo",
          "expediate",
          "ezipuru",
          "gesendete",
          "gesendete elemente",
          "gestuur",
          "gnderilmi eler",
          "gndrilnlr",
          "iberilen",
          "inviati",
          "isistieji",
          "kuthunyelwe",
          "lasa",
          "lhetetyt",
          "messages envoys",
          "naipadala",
          "nalefa",
          "napadala",
          "nostts zias",
          "odeslan",
          "odeslan pota",
          "padala",
          "poslane",
          "poslano",
          "poslano",
          "poslan",
          "poslato",
          "saadetud",
          "saadetud kirjad",
          "saadetud ksused",
          "sendt",
          "sendt",
          "sent",
          "sent items",
          "sent messages",
          "snda poster",
          "snt",
          "terkirim",
          "ti fi ran",
          "t drguara",
          "verzonden",
          "vilivyotumwa",
          "wysane",
          " gi",
          "",
          "",
          "",
          "",
          "",
          " ",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          " ",
          "",
          " ",
          "",
          " ",
          "  ",
          "",
          "",
          "",
          " ",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          " ",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          " ",
          " "
        ],
        "\\Trash": [
          "articole terse",
          "bin",
          "borttagna objekt",
          "deleted",
          "deleted items",
          "deleted messages",
          "elementi eliminati",
          "elementos borrados",
          "elementos eliminados",
          "gelschte objekte",
          "gelschte elemente",
          "item dipadam",
          "itens apagados",
          "itens excludos",
          "kustutatud ksused",
          "mc  xa",
          "odstrann poloky",
          "odstrann pota",
          "pesan terhapus",
          "poistetut",
          "praht",
          "prgikast",
          "silinmi eler",
          "slettede beskeder",
          "slettede elementer",
          "trash",
          "trlt elemek",
          "trlt",
          "usunite wiadomoci",
          "verwijderde items",
          "vymazan sprvy",
          "lments supprims",
          "",
          "",
          "",
          " ",
          " ",
          "  ",
          "",
          "",
          "",
          ""
        ],
        "\\Junk": [
          "bulk mail",
          "correo no deseado",
          "courrier indsirable",
          "istenmeyen",
          "istenmeyen e-posta",
          "junk",
          "junk e-mail",
          "junk email",
          "junk-e-mail",
          "levlszemt",
          "nevyiadan pota",
          "nevydan pota",
          "no deseado",
          "posta indesiderata",
          "pourriel",
          "roskaposti",
          "rmpspost",
          "skrppost",
          "spam",
          "spam",
          "spamowanie",
          "sppelpost",
          "th rc",
          "wiadomoci-mieci",
          "",
          " ",
          " ",
          "",
          "",
          "",
          "",
          ""
        ],
        "\\Drafts": [
          "ba brouillon",
          "borrador",
          "borrador",
          "borradores",
          "bozze",
          "brouillons",
          "bn tho",
          "ciorne",
          "concepten",
          "draf",
          "draft",
          "drafts",
          "drg",
          "entwrfe",
          "esborranys",
          "garalamalar",
          "ihe edeturu",
          "iidrafti",
          "izinhlaka",
          "juodraiai",
          "kladd",
          "kladder",
          "koncepty",
          "koncepty",
          "konsep",
          "konsepte",
          "kopie robocze",
          "layihlr",
          "luonnokset",
          "melnraksti",
          "meralo",
          "mesazhe t padrguara",
          "mga draft",
          "mustandid",
          "nacrti",
          "nacrti",
          "osnutki",
          "piszkozatok",
          "rascunhos",
          "rasimu",
          "skice",
          "taslaklar",
          "tsararrun saonni",
          "utkast",
          "vakiraoka",
          "vzlatok",
          "zirriborroak",
          "wn kpam",
          "",
          "",
          "",
          "",
          "",
          " ",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          " ",
          "/",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          " ",
          "",
          "",
          " ",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          " "
        ],
        "\\Archive": ["archive"]
      },
      specialUse(hasSpecialUseExtension, folder) {
        let result;
        if (hasSpecialUseExtension) {
          result = {
            flag: module.exports.flags.find((flag) => folder.flags.has(flag)),
            source: "extension"
          };
        }
        if (!result || !result.flag) {
          let name = folder.name.toLowerCase().replace(/\u200e/g, "").trim();
          result = {
            flag: Object.keys(module.exports.names).find((flag) => module.exports.names[flag].includes(name)),
            source: "name"
          };
        }
        return result && result.flag ? result : { flag: null };
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/list.js
var require_list = __commonJS({
  "../node_modules/imapflow/lib/commands/list.js"(exports, module) {
    "use strict";
    var { decodePath, encodePath, normalizePath } = require_tools();
    var { specialUse } = require_special_use();
    module.exports = async (connection, reference, mailbox, options) => {
      options = options || {};
      const FLAG_SORT_ORDER = ["\\Inbox", "\\Flagged", "\\Sent", "\\Drafts", "\\All", "\\Archive", "\\Junk", "\\Trash"];
      const SOURCE_SORT_ORDER = ["user", "extension", "name"];
      let listCommand = connection.capabilities.has("XLIST") && !connection.capabilities.has("SPECIAL-USE") ? "XLIST" : "LIST";
      let response;
      try {
        let entries = [];
        let statusMap = /* @__PURE__ */ new Map();
        let returnArgs = [];
        let statusQueryAttributes = [];
        if (options.statusQuery) {
          Object.keys(options.statusQuery || {}).forEach((key) => {
            if (!options.statusQuery[key]) {
              return;
            }
            switch (key.toUpperCase()) {
              case "MESSAGES":
              case "RECENT":
              case "UIDNEXT":
              case "UIDVALIDITY":
              case "UNSEEN":
                statusQueryAttributes.push({ type: "ATOM", value: key.toUpperCase() });
                break;
              case "HIGHESTMODSEQ":
                if (connection.capabilities.has("CONDSTORE")) {
                  statusQueryAttributes.push({ type: "ATOM", value: key.toUpperCase() });
                }
                break;
            }
          });
        }
        if (listCommand === "LIST" && connection.capabilities.has("LIST-STATUS") && statusQueryAttributes.length) {
          returnArgs.push({ type: "ATOM", value: "STATUS" }, statusQueryAttributes);
          if (connection.capabilities.has("SPECIAL-USE")) {
            returnArgs.push({ type: "ATOM", value: "SPECIAL-USE" });
          }
        }
        let specialUseMatches = {};
        let addSpecialUseMatch = (entry, type, source) => {
          if (!specialUseMatches[type]) {
            specialUseMatches[type] = [];
          }
          specialUseMatches[type].push({ entry, source });
        };
        let specialUseHints = {};
        if (options.specialUseHints && typeof options.specialUseHints === "object") {
          for (let type of Object.keys(options.specialUseHints)) {
            if (["sent", "junk", "trash", "drafts", "archive"].includes(type) && options.specialUseHints[type] && typeof options.specialUseHints[type] === "string") {
              specialUseHints[normalizePath(connection, options.specialUseHints[type])] = `\\${type.replace(/^./, (c) => c.toUpperCase())}`;
            }
          }
        }
        let runList = async (reference2, mailbox2) => {
          const cmdArgs = [encodePath(connection, reference2), encodePath(connection, mailbox2)];
          if (returnArgs.length) {
            cmdArgs.push({ type: "ATOM", value: "RETURN" }, returnArgs);
          }
          response = await connection.exec(listCommand, cmdArgs, {
            untagged: {
              [listCommand]: async (untagged) => {
                if (!untagged.attributes || !untagged.attributes.length) {
                  return;
                }
                let entry = {
                  path: normalizePath(connection, decodePath(connection, untagged.attributes[2] && untagged.attributes[2].value || "")),
                  pathAsListed: untagged.attributes[2] && untagged.attributes[2].value || "",
                  flags: new Set(untagged.attributes[0].map((entry2) => entry2.value)),
                  delimiter: untagged.attributes[1] && untagged.attributes[1].value,
                  listed: true
                };
                if (specialUseHints[entry.path]) {
                  addSpecialUseMatch(entry, specialUseHints[entry.path], "user");
                }
                if (listCommand === "XLIST" && entry.flags.has("\\Inbox")) {
                  entry.flags.delete("\\Inbox");
                  if (entry.path !== "INBOX") {
                    addSpecialUseMatch(entry, "\\Inbox", "extension");
                  }
                }
                if (entry.path.toUpperCase() === "INBOX") {
                  addSpecialUseMatch(entry, "\\Inbox", "name");
                }
                if (entry.delimiter && entry.path.charAt(0) === entry.delimiter) {
                  entry.path = entry.path.slice(1);
                }
                entry.parentPath = entry.delimiter && entry.path ? entry.path.substr(0, entry.path.lastIndexOf(entry.delimiter)) : "";
                entry.parent = entry.delimiter ? entry.path.split(entry.delimiter) : [entry.path];
                entry.name = entry.parent.pop();
                let { flag: specialUseFlag, source: flagSource } = specialUse(
                  connection.capabilities.has("XLIST") || connection.capabilities.has("SPECIAL-USE"),
                  entry
                );
                if (specialUseFlag) {
                  addSpecialUseMatch(entry, specialUseFlag, flagSource);
                }
                entries.push(entry);
              },
              STATUS: async (untagged) => {
                let statusPath = normalizePath(connection, decodePath(connection, untagged.attributes[0] && untagged.attributes[0].value || ""));
                let statusList = untagged.attributes && Array.isArray(untagged.attributes[1]) ? untagged.attributes[1] : false;
                if (!statusList || !statusPath) {
                  return;
                }
                let key;
                let map = { path: statusPath };
                statusList.forEach((entry, i) => {
                  if (i % 2 === 0) {
                    key = entry && typeof entry.value === "string" ? entry.value : false;
                    return;
                  }
                  if (!key || !entry || typeof entry.value !== "string") {
                    return;
                  }
                  let value = false;
                  switch (key.toUpperCase()) {
                    case "MESSAGES":
                      key = "messages";
                      value = !isNaN(entry.value) ? Number(entry.value) : false;
                      break;
                    case "RECENT":
                      key = "recent";
                      value = !isNaN(entry.value) ? Number(entry.value) : false;
                      break;
                    case "UIDNEXT":
                      key = "uidNext";
                      value = !isNaN(entry.value) ? Number(entry.value) : false;
                      break;
                    case "UIDVALIDITY":
                      key = "uidValidity";
                      value = !isNaN(entry.value) ? BigInt(entry.value) : false;
                      break;
                    case "UNSEEN":
                      key = "unseen";
                      value = !isNaN(entry.value) ? Number(entry.value) : false;
                      break;
                    case "HIGHESTMODSEQ":
                      key = "highestModseq";
                      value = !isNaN(entry.value) ? BigInt(entry.value) : false;
                      break;
                  }
                  if (value === false) {
                    return;
                  }
                  map[key] = value;
                });
                statusMap.set(statusPath, map);
              }
            }
          });
          response.next();
        };
        let normalizedReference = normalizePath(connection, reference || "");
        await runList(normalizedReference, normalizePath(connection, mailbox || "", true));
        if (options.listOnly) {
          return entries;
        }
        if (normalizedReference && !specialUseMatches["\\Inbox"]) {
          await runList("", "INBOX");
        }
        if (options.statusQuery) {
          for (let entry of entries) {
            if (!entry.flags.has("\\Noselect") && !entry.flags.has("\\NonExistent")) {
              if (statusMap.has(entry.path)) {
                entry.status = statusMap.get(entry.path);
              } else if (!statusMap.size) {
                try {
                  entry.status = await connection.run("STATUS", entry.path, options.statusQuery);
                } catch (err) {
                  entry.status = { error: err };
                }
              }
            }
          }
        }
        response = await connection.exec(
          "LSUB",
          [encodePath(connection, normalizePath(connection, reference || "")), encodePath(connection, normalizePath(connection, mailbox || "", true))],
          {
            untagged: {
              LSUB: async (untagged) => {
                if (!untagged.attributes || !untagged.attributes.length) {
                  return;
                }
                let entry = {
                  path: normalizePath(connection, decodePath(connection, untagged.attributes[2] && untagged.attributes[2].value || "")),
                  pathAsListed: untagged.attributes[2] && untagged.attributes[2].value || "",
                  flags: new Set(untagged.attributes[0].map((entry2) => entry2.value)),
                  delimiter: untagged.attributes[1] && untagged.attributes[1].value,
                  subscribed: true
                };
                if (entry.path.toUpperCase() === "INBOX") {
                  addSpecialUseMatch(entry, "\\Inbox", "name");
                }
                if (entry.delimiter && entry.path.charAt(0) === entry.delimiter) {
                  entry.path = entry.path.slice(1);
                }
                entry.parentPath = entry.delimiter && entry.path ? entry.path.substr(0, entry.path.lastIndexOf(entry.delimiter)) : "";
                entry.parent = entry.delimiter ? entry.path.split(entry.delimiter) : [entry.path];
                entry.name = entry.parent.pop();
                let existing = entries.find((existing2) => existing2.path === entry.path);
                if (existing) {
                  existing.subscribed = true;
                  entry.flags.forEach((flag) => existing.flags.add(flag));
                } else {
                }
              }
            }
          }
        );
        response.next();
        for (let type of Object.keys(specialUseMatches)) {
          let sortedEntries = specialUseMatches[type].sort((a, b) => {
            let aSource = SOURCE_SORT_ORDER.indexOf(a.source);
            let bSource = SOURCE_SORT_ORDER.indexOf(b.source);
            if (aSource === bSource) {
              return a.entry.path.localeCompare(b.entry.path);
            }
            return aSource - bSource;
          });
          if (!sortedEntries[0].entry.specialUse) {
            sortedEntries[0].entry.specialUse = type;
            sortedEntries[0].entry.specialUseSource = sortedEntries[0].source;
          }
        }
        let inboxEntry = entries.find((entry) => entry.specialUse === "\\Inbox");
        if (inboxEntry && !inboxEntry.subscribed) {
          inboxEntry.subscribed = true;
        }
        return entries.sort((a, b) => {
          if (a.specialUse && !b.specialUse) {
            return -1;
          }
          if (!a.specialUse && b.specialUse) {
            return 1;
          }
          if (a.specialUse && b.specialUse) {
            return FLAG_SORT_ORDER.indexOf(a.specialUse) - FLAG_SORT_ORDER.indexOf(b.specialUse);
          }
          let aList = [].concat(a.parent).concat(a.name);
          let bList = [].concat(b.parent).concat(b.name);
          for (let i = 0; i < aList.length; i++) {
            let aPart = aList[i];
            let bPart = bList[i];
            if (aPart !== bPart) {
              return aPart.localeCompare(bPart || "");
            }
          }
          return a.path.localeCompare(b.path);
        });
      } catch (err) {
        connection.log.warn({ msg: "Failed to list folders", err, cid: connection.id });
        throw err;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/enable.js
var require_enable = __commonJS({
  "../node_modules/imapflow/lib/commands/enable.js"(exports, module) {
    "use strict";
    module.exports = async (connection, extensionList) => {
      if (!connection.capabilities.has("ENABLE") || connection.state !== connection.states.AUTHENTICATED) {
        return;
      }
      extensionList = extensionList.filter((extension) => connection.capabilities.has(extension.toUpperCase()));
      if (!extensionList.length) {
        return;
      }
      let response;
      try {
        let enabled = /* @__PURE__ */ new Set();
        response = await connection.exec(
          "ENABLE",
          extensionList.map((extension) => ({ type: "ATOM", value: extension.toUpperCase() })),
          {
            untagged: {
              ENABLED: async (untagged) => {
                if (!untagged.attributes || !untagged.attributes.length) {
                  return;
                }
                untagged.attributes.forEach((attr) => {
                  if (attr.value && typeof attr.value === "string") {
                    enabled.add(attr.value.toUpperCase().trim());
                  }
                });
              }
            }
          }
        );
        connection.enabled = enabled;
        response.next();
        return enabled;
      } catch (err) {
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/select.js
var require_select = __commonJS({
  "../node_modules/imapflow/lib/commands/select.js"(exports, module) {
    "use strict";
    var { encodePath, normalizePath, getStatusCode, getErrorText } = require_tools();
    module.exports = async (connection, path, options) => {
      var _a;
      if (![connection.states.AUTHENTICATED, connection.states.SELECTED].includes(connection.state)) {
        return;
      }
      options = options || {};
      path = normalizePath(connection, path);
      if (!connection.folders.has(path)) {
        let folders = await connection.run("LIST", "", path);
        if (!folders) {
          throw new Error("Failed to fetch folders");
        }
        folders.forEach((folder) => {
          connection.folders.set(folder.path, folder);
        });
      }
      let folderListData = connection.folders.has(path) ? connection.folders.get(path) : false;
      let response;
      try {
        let map = { path };
        if (folderListData) {
          ["delimiter", "specialUse", "subscribed", "listed"].forEach((key) => {
            if (folderListData[key]) {
              map[key] = folderListData[key];
            }
          });
        }
        let extraArgs = [];
        if (connection.enabled.has("QRESYNC") && options.changedSince && options.uidValidity) {
          extraArgs.push([
            { type: "ATOM", value: "QRESYNC" },
            [
              { type: "ATOM", value: (_a = options.uidValidity) == null ? void 0 : _a.toString() },
              { type: "ATOM", value: options.changedSince.toString() }
            ]
          ]);
          map.qresync = true;
        }
        let encodedPath = encodePath(connection, path);
        let selectCommand = {
          command: !options.readOnly ? "SELECT" : "EXAMINE",
          arguments: [{ type: encodedPath.indexOf("&") >= 0 ? "STRING" : "ATOM", value: encodedPath }].concat(extraArgs || [])
        };
        response = await connection.exec(selectCommand.command, selectCommand.arguments, {
          untagged: {
            OK: async (untagged) => {
              if (!untagged.attributes || !untagged.attributes.length) {
                return;
              }
              let section2 = !untagged.attributes[0].value && untagged.attributes[0].section;
              if (section2 && section2.length > 1 && section2[0].type === "ATOM" && typeof section2[0].value === "string") {
                let key = section2[0].value.toLowerCase();
                let value;
                if (typeof section2[1].value === "string") {
                  value = section2[1].value;
                } else if (Array.isArray(section2[1])) {
                  value = section2[1].map((entry) => typeof entry.value === "string" ? entry.value : false).filter((entry) => entry);
                }
                switch (key) {
                  case "highestmodseq":
                    key = "highestModseq";
                    if (/^[0-9]+$/.test(value)) {
                      value = BigInt(value);
                    }
                    break;
                  case "mailboxid":
                    key = "mailboxId";
                    if (Array.isArray(value) && value.length) {
                      value = value[0];
                    }
                    break;
                  case "permanentflags":
                    key = "permanentFlags";
                    value = new Set(value);
                    break;
                  case "uidnext":
                    key = "uidNext";
                    value = Number(value);
                    break;
                  case "uidvalidity":
                    key = "uidValidity";
                    if (/^[0-9]+$/.test(value)) {
                      value = BigInt(value);
                    }
                    break;
                }
                map[key] = value;
              }
              if (section2 && section2.length === 1 && section2[0].type === "ATOM" && typeof section2[0].value === "string") {
                let key = section2[0].value.toLowerCase();
                switch (key) {
                  case "nomodseq":
                    key = "noModseq";
                    map[key] = true;
                    break;
                }
              }
            },
            FLAGS: async (untagged) => {
              if (!untagged.attributes || !untagged.attributes.length && Array.isArray(untagged.attributes[0])) {
                return;
              }
              let flags = untagged.attributes[0].map((flag) => typeof flag.value === "string" ? flag.value : false).filter((flag) => flag);
              map.flags = new Set(flags);
            },
            EXISTS: async (untagged) => {
              let num = Number(untagged.command);
              if (isNaN(num)) {
                return false;
              }
              map.exists = num;
            },
            VANISHED: async (untagged) => {
              await connection.untaggedVanished(
                untagged,
                // mailbox is not yet open, so use a dummy mailbox object
                { path, uidNext: false, uidValidity: false }
              );
            },
            // we should only get an untagged FETCH for a SELECT/EXAMINE if QRESYNC was asked for
            FETCH: async (untagged) => {
              await connection.untaggedFetch(
                untagged,
                // mailbox is not yet open, so use a dummy mailbox object
                { path, uidNext: false, uidValidity: false }
              );
            }
          }
        });
        let section = !response.response.attributes[0].value && response.response.attributes[0].section;
        if (section && section.length && section[0].type === "ATOM" && typeof section[0].value === "string") {
          switch (section[0].value.toUpperCase()) {
            case "READ-ONLY":
              map.readOnly = true;
              break;
            case "READ-WRITE":
            default:
              map.readOnly = false;
              break;
          }
        }
        if (map.qresync && // UIDVALIDITY must be the same
        (options.uidValidity !== map.uidValidity || // HIGHESTMODSEQ response must be present
        !map.highestModseq || // NOMODSEQ is not allowed
        map.noModseq)) {
          map.qresync = false;
        }
        let currentMailbox = connection.mailbox;
        connection.mailbox = false;
        if (currentMailbox && currentMailbox.path !== path) {
          connection.emit("mailboxClose", currentMailbox);
        }
        connection.mailbox = map;
        connection.currentSelectCommand = selectCommand;
        connection.state = connection.states.SELECTED;
        if (!currentMailbox || currentMailbox.path !== path) {
          connection.emit("mailboxOpen", connection.mailbox);
        }
        response.next();
        return map;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        if (connection.state === connection.states.SELECTED) {
          let currentMailbox = connection.mailbox;
          connection.mailbox = false;
          connection.currentSelectCommand = false;
          connection.state = connection.states.AUTHENTICATED;
          if (currentMailbox) {
            connection.emit("mailboxClose", currentMailbox);
          }
        }
        connection.log.warn({ err, cid: connection.id });
        throw err;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/fetch.js
var require_fetch = __commonJS({
  "../node_modules/imapflow/lib/commands/fetch.js"(exports, module) {
    "use strict";
    var { formatMessageResponse } = require_tools();
    module.exports = async (connection, range, query, options) => {
      if (connection.state !== connection.states.SELECTED || !range) {
        return;
      }
      options = options || {};
      let mailbox = connection.mailbox;
      const commandKey = connection.capabilities.has("BINARY") && options.binary && !connection.disableBinary ? "BINARY" : "BODY";
      let retryCount = 0;
      const maxRetries = 4;
      const baseDelay = 1e3;
      while (retryCount < maxRetries) {
        let messages = {
          count: 0,
          list: []
        };
        let response;
        try {
          let attributes = [{ type: "SEQUENCE", value: (range || "*").toString() }];
          let queryStructure = [];
          let setBodyPeek = (attributes2, partial) => {
            let bodyPeek = {
              type: "ATOM",
              value: `${commandKey}.PEEK`,
              section: [],
              partial
            };
            if (Array.isArray(attributes2)) {
              attributes2.forEach((attribute) => {
                bodyPeek.section.push(attribute);
              });
            } else if (attributes2) {
              bodyPeek.section.push(attributes2);
            }
            queryStructure.push(bodyPeek);
          };
          ["all", "fast", "full", "uid", "flags", "bodyStructure", "envelope", "internalDate"].forEach((key) => {
            if (query[key]) {
              queryStructure.push({ type: "ATOM", value: key.toUpperCase() });
            }
          });
          if (query.size) {
            queryStructure.push({ type: "ATOM", value: "RFC822.SIZE" });
          }
          if (query.source) {
            let partial;
            if (typeof query.source === "object" && (query.source.start || query.source.maxLength)) {
              partial = [Number(query.source.start) || 0];
              if (query.source.maxLength && !isNaN(query.source.maxLength)) {
                partial.push(Number(query.source.maxLength));
              }
            }
            queryStructure.push({ type: "ATOM", value: `${commandKey}.PEEK`, section: [], partial });
          }
          if (connection.capabilities.has("OBJECTID")) {
            queryStructure.push({ type: "ATOM", value: "EMAILID" });
          } else if (connection.capabilities.has("X-GM-EXT-1")) {
            queryStructure.push({ type: "ATOM", value: "X-GM-MSGID" });
          }
          if (query.threadId) {
            if (connection.capabilities.has("OBJECTID")) {
              queryStructure.push({ type: "ATOM", value: "THREADID" });
            } else if (connection.capabilities.has("X-GM-EXT-1")) {
              queryStructure.push({ type: "ATOM", value: "X-GM-THRID" });
            }
          }
          if (query.labels) {
            if (connection.capabilities.has("X-GM-EXT-1")) {
              queryStructure.push({ type: "ATOM", value: "X-GM-LABELS" });
            }
          }
          if (connection.enabled.has("CONDSTORE") && !mailbox.noModseq) {
            queryStructure.push({ type: "ATOM", value: "MODSEQ" });
          }
          if (!query.uid) {
            queryStructure.push({ type: "ATOM", value: "UID" });
          }
          if (query.headers) {
            if (Array.isArray(query.headers)) {
              setBodyPeek([{ type: "ATOM", value: "HEADER.FIELDS" }, query.headers.map((header) => ({ type: "ATOM", value: header }))]);
            } else {
              setBodyPeek({ type: "ATOM", value: "HEADER" });
            }
          }
          if (query.bodyParts && query.bodyParts.length) {
            query.bodyParts.forEach((part) => {
              if (!part) {
                return;
              }
              let key;
              let partial;
              if (typeof part === "object") {
                if (!part.key || typeof part.key !== "string") {
                  return;
                }
                key = part.key.toUpperCase();
                if (part.start || part.maxLength) {
                  partial = [Number(part.start) || 0];
                  if (part.maxLength && !isNaN(part.maxLength)) {
                    partial.push(Number(part.maxLength));
                  }
                }
              } else if (typeof part === "string") {
                key = part.toUpperCase();
              } else {
                return;
              }
              setBodyPeek({ type: "ATOM", value: key }, partial);
            });
          }
          if (queryStructure.length === 1) {
            queryStructure = queryStructure.pop();
          }
          attributes.push(queryStructure);
          if (options.changedSince && connection.enabled.has("CONDSTORE") && !mailbox.noModseq) {
            let changedSinceArgs = [
              {
                type: "ATOM",
                value: "CHANGEDSINCE"
              },
              {
                type: "ATOM",
                value: options.changedSince.toString()
              }
            ];
            if (options.uid && connection.enabled.has("QRESYNC")) {
              changedSinceArgs.push({
                type: "ATOM",
                value: "VANISHED"
              });
            }
            attributes.push(changedSinceArgs);
          }
          response = await connection.exec(options.uid ? "UID FETCH" : "FETCH", attributes, {
            untagged: {
              FETCH: async (untagged) => {
                messages.count++;
                let formatted = await formatMessageResponse(untagged, mailbox);
                if (typeof options.onUntaggedFetch === "function") {
                  await new Promise((resolve, reject) => {
                    options.onUntaggedFetch(formatted, (err) => {
                      if (err) {
                        reject(err);
                      } else {
                        resolve();
                      }
                    });
                  });
                } else {
                  messages.list.push(formatted);
                }
              }
            }
          });
          response.next();
          return messages;
        } catch (err) {
          if (err.code === "ETHROTTLE") {
            const backoffDelay = Math.min(baseDelay * Math.pow(2, retryCount), 3e4);
            const delay = err.throttleReset && err.throttleReset > backoffDelay ? err.throttleReset : backoffDelay;
            connection.log.warn({
              msg: "Retrying throttled request with exponential backoff",
              cid: connection.id,
              code: err.code,
              response: err.responseText,
              throttleReset: err.throttleReset,
              retryCount,
              delayMs: delay
            });
            await new Promise((resolve) => setTimeout(resolve, delay));
            retryCount++;
            continue;
          }
          connection.log.warn({ err, cid: connection.id });
          throw err;
        }
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/create.js
var require_create = __commonJS({
  "../node_modules/imapflow/lib/commands/create.js"(exports, module) {
    "use strict";
    var { encodePath, normalizePath, getStatusCode, getErrorText } = require_tools();
    module.exports = async (connection, path) => {
      if (![connection.states.AUTHENTICATED, connection.states.SELECTED].includes(connection.state)) {
        return;
      }
      path = normalizePath(connection, path);
      let response;
      try {
        let map = {
          path
        };
        response = await connection.exec("CREATE", [{ type: "ATOM", value: encodePath(connection, path) }]);
        let section = response.response.attributes && response.response.attributes[0] && response.response.attributes[0].section && response.response.attributes[0].section.length ? response.response.attributes[0].section : false;
        if (section) {
          let key;
          section.forEach((attribute, i) => {
            if (i % 2 === 0) {
              key = attribute && typeof attribute.value === "string" ? attribute.value : false;
              return;
            }
            if (!key) {
              return;
            }
            let value;
            switch (key.toLowerCase()) {
              case "mailboxid":
                key = "mailboxId";
                value = Array.isArray(attribute) && attribute[0] && typeof attribute[0].value === "string" ? attribute[0].value : false;
                break;
            }
            if (key && value) {
              map[key] = value;
            }
          });
        }
        map.created = true;
        response.next();
        await connection.run("SUBSCRIBE", path);
        return map;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        switch (errorCode) {
          case "ALREADYEXISTS":
            return {
              path,
              created: false
            };
        }
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        connection.log.warn({ err, cid: connection.id });
        throw err;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/delete.js
var require_delete = __commonJS({
  "../node_modules/imapflow/lib/commands/delete.js"(exports, module) {
    "use strict";
    var { encodePath, normalizePath, getStatusCode, getErrorText } = require_tools();
    module.exports = async (connection, path) => {
      if (![connection.states.AUTHENTICATED, connection.states.SELECTED].includes(connection.state)) {
        return;
      }
      path = normalizePath(connection, path);
      if (connection.state === connection.states.SELECTED && connection.mailbox.path === path) {
        await connection.run("CLOSE");
      }
      let response;
      try {
        let map = {
          path
        };
        response = await connection.exec("DELETE", [{ type: "ATOM", value: encodePath(connection, path) }]);
        response.next();
        return map;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        connection.log.warn({ err, cid: connection.id });
        throw err;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/rename.js
var require_rename = __commonJS({
  "../node_modules/imapflow/lib/commands/rename.js"(exports, module) {
    "use strict";
    var { encodePath, normalizePath, getStatusCode, getErrorText } = require_tools();
    module.exports = async (connection, path, newPath) => {
      if (![connection.states.AUTHENTICATED, connection.states.SELECTED].includes(connection.state)) {
        return;
      }
      path = normalizePath(connection, path);
      newPath = normalizePath(connection, newPath);
      if (connection.state === connection.states.SELECTED && connection.mailbox.path === path) {
        await connection.run("CLOSE");
      }
      let response;
      try {
        let map = {
          path,
          newPath
        };
        response = await connection.exec("RENAME", [
          { type: "ATOM", value: encodePath(connection, path) },
          { type: "ATOM", value: encodePath(connection, newPath) }
        ]);
        response.next();
        return map;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        connection.log.warn({ err, cid: connection.id });
        throw err;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/close.js
var require_close = __commonJS({
  "../node_modules/imapflow/lib/commands/close.js"(exports, module) {
    "use strict";
    module.exports = async (connection) => {
      if (connection.state !== connection.states.SELECTED) {
        return;
      }
      let response;
      try {
        response = await connection.exec("CLOSE");
        response.next();
        let currentMailbox = connection.mailbox;
        connection.mailbox = false;
        connection.currentSelectCommand = false;
        connection.state = connection.states.AUTHENTICATED;
        if (currentMailbox) {
          connection.emit("mailboxClose", currentMailbox);
        }
        return true;
      } catch (err) {
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/subscribe.js
var require_subscribe = __commonJS({
  "../node_modules/imapflow/lib/commands/subscribe.js"(exports, module) {
    "use strict";
    var { encodePath, normalizePath, getStatusCode, getErrorText } = require_tools();
    module.exports = async (connection, path) => {
      if (![connection.states.AUTHENTICATED, connection.states.SELECTED].includes(connection.state)) {
        return;
      }
      path = normalizePath(connection, path);
      let response;
      try {
        response = await connection.exec("SUBSCRIBE", [{ type: "ATOM", value: encodePath(connection, path) }]);
        response.next();
        return true;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/unsubscribe.js
var require_unsubscribe = __commonJS({
  "../node_modules/imapflow/lib/commands/unsubscribe.js"(exports, module) {
    "use strict";
    var { encodePath, normalizePath, getStatusCode, getErrorText } = require_tools();
    module.exports = async (connection, path) => {
      if (![connection.states.AUTHENTICATED, connection.states.SELECTED].includes(connection.state)) {
        return;
      }
      path = normalizePath(connection, path);
      let response;
      try {
        response = await connection.exec("UNSUBSCRIBE", [{ type: "ATOM", value: encodePath(connection, path) }]);
        response.next();
        return true;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/store.js
var require_store = __commonJS({
  "../node_modules/imapflow/lib/commands/store.js"(exports, module) {
    "use strict";
    var { getStatusCode, formatFlag, canUseFlag, getErrorText } = require_tools();
    module.exports = async (connection, range, flags, options) => {
      if (connection.state !== connection.states.SELECTED || !range || options.useLabels && !connection.capabilities.has("X-GM-EXT-1")) {
        return false;
      }
      options = options || {};
      let operation;
      operation = "FLAGS";
      if (options.useLabels) {
        operation = "X-GM-LABELS";
      } else if (options.silent) {
        operation = `${operation}.SILENT`;
      }
      switch ((options.operation || "").toLowerCase()) {
        case "set":
          break;
        case "remove":
          operation = `-${operation}`;
          break;
        case "add":
        default:
          operation = `+${operation}`;
          break;
      }
      flags = (Array.isArray(flags) ? flags : [].concat(flags || [])).map((flag) => {
        flag = formatFlag(flag);
        if (!canUseFlag(connection.mailbox, flag) && operation !== "remove") {
          return false;
        }
        return flag;
      }).filter((flag) => flag);
      if (!flags.length && options.operation !== "set") {
        return false;
      }
      let attributes = [{ type: "SEQUENCE", value: range }, { type: "ATOM", value: operation }, flags.map((flag) => ({ type: "ATOM", value: flag }))];
      if (options.unchangedSince && connection.enabled.has("CONDSTORE") && !connection.mailbox.noModseq) {
        attributes.push([
          {
            type: "ATOM",
            value: "UNCHANGEDSINCE"
          },
          {
            type: "ATOM",
            value: options.unchangedSince.toString()
          }
        ]);
      }
      let response;
      try {
        response = await connection.exec(options.uid ? "UID STORE" : "STORE", attributes);
        response.next();
        return true;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/search-compiler.js
var require_search_compiler = __commonJS({
  "../node_modules/imapflow/lib/search-compiler.js"(exports, module) {
    "use strict";
    var { formatDate, formatFlag, canUseFlag, isDate } = require_tools();
    var setBoolOpt = (attributes, term, value) => {
      if (!value) {
        if (/^un/i.test(term)) {
          term = term.slice(2);
        } else {
          term = "UN" + term;
        }
      }
      attributes.push({ type: "ATOM", value: term.toUpperCase() });
    };
    var setOpt = (attributes, term, value, type) => {
      type = type || "ATOM";
      if (value === false || value === null) {
        attributes.push({ type, value: "NOT" });
      }
      attributes.push({ type, value: term.toUpperCase() });
      if (Array.isArray(value)) {
        value.forEach((entry) => attributes.push({ type, value: (entry || "").toString() }));
      } else {
        attributes.push({ type, value: value.toString() });
      }
    };
    var processDateField = (attributes, term, value) => {
      if (["BEFORE", "SENTBEFORE"].includes(term.toUpperCase()) && isDate(value) && value.toISOString().substring(11) !== "00:00:00.000Z") {
        value = new Date(value.getTime() + 24 * 3600 * 1e3);
      }
      let date = formatDate(value);
      if (!date) {
        return;
      }
      setOpt(attributes, term, date);
    };
    var UNICODE_PATTERN = /[^\x00-\x7F]/;
    var isUnicodeString = (str) => {
      if (!str || typeof str !== "string") {
        return false;
      }
      return UNICODE_PATTERN.test(str);
    };
    module.exports.searchCompiler = (connection, query) => {
      const attributes = [];
      let hasUnicode = false;
      const mailbox = connection.mailbox;
      const walk = (params) => {
        Object.keys(params || {}).forEach((term) => {
          switch (term.toUpperCase()) {
            case "SEQ":
              {
                let value = params[term];
                if (typeof value === "number") {
                  value = value.toString();
                }
                if (typeof value === "string" && /^\S+$/.test(value)) {
                  attributes.push({ type: "SEQUENCE", value });
                }
              }
              break;
            case "ANSWERED":
            case "DELETED":
            case "DRAFT":
            case "FLAGGED":
            case "SEEN":
            case "UNANSWERED":
            case "UNDELETED":
            case "UNDRAFT":
            case "UNFLAGGED":
            case "UNSEEN":
              setBoolOpt(attributes, term, !!params[term]);
              break;
            case "ALL":
            case "NEW":
            case "OLD":
            case "RECENT":
              if (params[term]) {
                setBoolOpt(attributes, term, true);
              }
              break;
            case "LARGER":
            case "SMALLER":
            case "MODSEQ":
              if (params[term]) {
                setOpt(attributes, term, params[term]);
              }
              break;
            case "BCC":
            case "BODY":
            case "CC":
            case "FROM":
            case "SUBJECT":
            case "TEXT":
            case "TO":
              if (isUnicodeString(params[term])) {
                hasUnicode = true;
              }
              if (params[term]) {
                setOpt(attributes, term, params[term]);
              }
              break;
            case "UID":
              if (params[term]) {
                setOpt(attributes, term, params[term], "SEQUENCE");
              }
              break;
            case "EMAILID":
              if (connection.capabilities.has("OBJECTID")) {
                setOpt(attributes, "EMAILID", params[term]);
              } else if (connection.capabilities.has("X-GM-EXT-1")) {
                setOpt(attributes, "X-GM-MSGID", params[term]);
              }
              break;
            case "THREADID":
              if (connection.capabilities.has("OBJECTID")) {
                setOpt(attributes, "THREADID", params[term]);
              } else if (connection.capabilities.has("X-GM-EXT-1")) {
                setOpt(attributes, "X-GM-THRID", params[term]);
              }
              break;
            case "GMRAW":
            case "GMAILRAW":
              if (connection.capabilities.has("X-GM-EXT-1")) {
                if (isUnicodeString(params[term])) {
                  hasUnicode = true;
                }
                setOpt(attributes, "X-GM-RAW", params[term]);
              } else {
                let error = new Error("Server does not support X-GM-EXT-1 extension required for X-GM-RAW");
                error.code = "MissingServerExtension";
                throw error;
              }
              break;
            case "BEFORE":
            case "SINCE":
              {
                if (connection.capabilities.has("WITHIN") && isDate(params[term])) {
                  const now = Date.now();
                  const withinSeconds = Math.round(Math.max(0, now - params[term].getTime()) / 1e3);
                  let withinKeyword;
                  switch (term.toUpperCase()) {
                    case "BEFORE":
                      withinKeyword = "OLDER";
                      break;
                    case "SINCE":
                      withinKeyword = "YOUNGER";
                      break;
                  }
                  setOpt(attributes, withinKeyword, withinSeconds.toString());
                  break;
                }
                processDateField(attributes, term, params[term]);
              }
              break;
            case "ON":
            case "SENTBEFORE":
            case "SENTON":
            case "SENTSINCE":
              processDateField(attributes, term, params[term]);
              break;
            case "KEYWORD":
            case "UNKEYWORD":
              {
                let flag = formatFlag(params[term]);
                if (canUseFlag(mailbox, flag) || mailbox.flags.has(flag)) {
                  setOpt(attributes, term, flag);
                }
              }
              break;
            case "HEADER":
              if (params[term] && typeof params[term] === "object") {
                Object.keys(params[term]).forEach((header) => {
                  let value = params[term][header];
                  if (value === true) {
                    value = "";
                  }
                  if (typeof value !== "string") {
                    return;
                  }
                  if (isUnicodeString(value)) {
                    hasUnicode = true;
                  }
                  setOpt(attributes, term, [header.toUpperCase().trim(), value]);
                });
              }
              break;
            case "NOT":
              {
                if (!params[term]) {
                  break;
                }
                if (typeof params[term] === "object") {
                  attributes.push({ type: "ATOM", value: "NOT" });
                  walk(params[term]);
                }
              }
              break;
            case "OR":
              {
                if (!params[term] || !Array.isArray(params[term]) || !params[term].length) {
                  break;
                }
                if (params[term].length === 1) {
                  if (typeof params[term][0] === "object" && params[term][0]) {
                    walk(params[term][0]);
                  }
                  break;
                }
                let genOrTree = (list) => {
                  let group = false;
                  let groups = [];
                  list.forEach((entry, i) => {
                    if (i % 2 === 0) {
                      group = [entry];
                    } else {
                      group.push(entry);
                      groups.push(group);
                      group = false;
                    }
                  });
                  if (group && group.length) {
                    while (group.length === 1 && Array.isArray(group[0])) {
                      group = group[0];
                    }
                    groups.push(group);
                  }
                  while (groups.length > 2) {
                    groups = genOrTree(groups);
                  }
                  while (groups.length === 1 && Array.isArray(groups[0])) {
                    groups = groups[0];
                  }
                  return groups;
                };
                let walkOrTree = (entry) => {
                  if (Array.isArray(entry)) {
                    if (entry.length > 1) {
                      attributes.push({ type: "ATOM", value: "OR" });
                    }
                    entry.forEach(walkOrTree);
                    return;
                  }
                  if (entry && typeof entry === "object") {
                    walk(entry);
                  }
                };
                walkOrTree(genOrTree(params[term]));
              }
              break;
          }
        });
      };
      walk(query);
      if (hasUnicode && !connection.enabled.has("UTF8=ACCEPT")) {
        attributes.unshift({ type: "ATOM", value: "UTF-8" });
        attributes.unshift({ type: "ATOM", value: "CHARSET" });
      }
      return attributes;
    };
  }
});

// ../node_modules/imapflow/lib/commands/search.js
var require_search = __commonJS({
  "../node_modules/imapflow/lib/commands/search.js"(exports, module) {
    "use strict";
    var { getStatusCode, getErrorText } = require_tools();
    var { searchCompiler } = require_search_compiler();
    module.exports = async (connection, query, options) => {
      if (connection.state !== connection.states.SELECTED) {
        return false;
      }
      options = options || {};
      let attributes;
      if (!query || query === true || typeof query === "object" && (!Object.keys(query).length || Object.keys(query).length === 1 && query.all)) {
        attributes = [{ type: "ATOM", value: "ALL" }];
      } else if (query && typeof query === "object") {
        attributes = searchCompiler(connection, query);
      } else {
        return false;
      }
      let results = /* @__PURE__ */ new Set();
      let response;
      try {
        response = await connection.exec(options.uid ? "UID SEARCH" : "SEARCH", attributes, {
          untagged: {
            SEARCH: async (untagged) => {
              if (untagged && untagged.attributes && untagged.attributes.length) {
                untagged.attributes.forEach((attribute) => {
                  if (attribute && attribute.value && typeof attribute.value === "string" && !isNaN(attribute.value)) {
                    results.add(Number(attribute.value));
                  }
                });
              }
            }
          }
        });
        response.next();
        return Array.from(results).sort((a, b) => a - b);
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/noop.js
var require_noop = __commonJS({
  "../node_modules/imapflow/lib/commands/noop.js"(exports, module) {
    "use strict";
    module.exports = async (connection) => {
      try {
        let response = await connection.exec("NOOP", false, { comment: "Requested by command" });
        response.next();
        return true;
      } catch (err) {
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/expunge.js
var require_expunge = __commonJS({
  "../node_modules/imapflow/lib/commands/expunge.js"(exports, module) {
    "use strict";
    var { getStatusCode, getErrorText } = require_tools();
    module.exports = async (connection, range, options) => {
      if (connection.state !== connection.states.SELECTED || !range) {
        return;
      }
      options = options || {};
      await connection.messageFlagsAdd(range, ["\\Deleted"], options);
      let byUid = options.uid && connection.capabilities.has("UIDPLUS");
      let command = byUid ? "UID EXPUNGE" : "EXPUNGE";
      let attributes = byUid ? [{ type: "SEQUENCE", value: range }] : false;
      let response;
      try {
        response = await connection.exec(command, attributes);
        let section = response.response.attributes && response.response.attributes[0] && response.response.attributes[0].section;
        let responseCode = section && section.length && section[0] && typeof section[0].value === "string" ? section[0].value : "";
        if (responseCode.toUpperCase() === "HIGHESTMODSEQ") {
          let highestModseq = section[1] && typeof section[1].value === "string" && !isNaN(section[1].value) ? BigInt(section[1].value) : false;
          if (highestModseq && (!connection.mailbox.highestModseq || highestModseq > connection.mailbox.highestModseq)) {
            connection.mailbox.highestModseq = highestModseq;
          }
        }
        response.next();
        return true;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/append.js
var require_append = __commonJS({
  "../node_modules/imapflow/lib/commands/append.js"(exports, module) {
    "use strict";
    var { getStatusCode, formatFlag, canUseFlag, formatDateTime, normalizePath, encodePath, comparePaths, getErrorText } = require_tools();
    module.exports = async (connection, destination, content, flags, idate) => {
      if (![connection.states.AUTHENTICATED, connection.states.SELECTED].includes(connection.state) || !destination) {
        return;
      }
      if (typeof content === "string") {
        content = Buffer.from(content);
      }
      if (connection.capabilities.has("APPENDLIMIT")) {
        let appendLimit = connection.capabilities.get("APPENDLIMIT");
        if (typeof appendLimit === "number" && appendLimit < content.length) {
          let err = new Error("Message content too big for APPENDLIMIT=" + appendLimit);
          err.serverResponseCode = "APPENDLIMIT";
          throw err;
        }
      }
      destination = normalizePath(connection, destination);
      let expectExists = comparePaths(connection, connection.mailbox.path, destination);
      flags = (Array.isArray(flags) ? flags : [].concat(flags || [])).map((flag) => flag && formatFlag(flag.toString())).filter((flag) => flag && canUseFlag(connection.mailbox, flag));
      let attributes = [{ type: "ATOM", value: encodePath(connection, destination) }];
      idate = idate ? formatDateTime(idate) : false;
      if (flags.length || idate) {
        attributes.push(flags.map((flag) => ({ type: "ATOM", value: flag })));
      }
      if (idate) {
        attributes.push({ type: "STRING", value: idate });
      }
      let isLiteral8 = false;
      if (connection.capabilities.has("BINARY") && !connection.disableBinary) {
        isLiteral8 = content.indexOf(Buffer.from([0])) >= 0;
      }
      attributes.push({ type: "LITERAL", value: content, isLiteral8 });
      let map = { destination };
      if (connection.mailbox && connection.mailbox.path) {
        map.path = connection.mailbox.path;
      }
      let response;
      try {
        response = await connection.exec("APPEND", attributes, {
          untagged: expectExists ? {
            EXISTS: async (untagged) => {
              map.seq = Number(untagged.command);
              if (expectExists) {
                let prevCount = connection.mailbox.exists;
                if (map.seq !== prevCount) {
                  connection.mailbox.exists = map.seq;
                  connection.emit("exists", {
                    path: connection.mailbox.path,
                    count: map.seq,
                    prevCount
                  });
                }
              }
            }
          } : false
        });
        let section = response.response.attributes && response.response.attributes[0] && response.response.attributes[0].section;
        if (section && section.length) {
          let responseCode = section[0] && typeof section[0].value === "string" ? section[0].value : "";
          switch (responseCode.toUpperCase()) {
            case "APPENDUID":
              {
                let uidValidity = section[1] && typeof section[1].value === "string" && !isNaN(section[1].value) ? BigInt(section[1].value) : false;
                let uid = section[2] && typeof section[2].value === "string" && !isNaN(section[2].value) ? Number(section[2].value) : false;
                if (uidValidity) {
                  map.uidValidity = uidValidity;
                }
                if (uid) {
                  map.uid = uid;
                }
              }
              break;
          }
        }
        response.next();
        if (expectExists && !map.seq) {
          try {
            response = await connection.exec("NOOP", false, {
              untagged: {
                EXISTS: async (untagged) => {
                  map.seq = Number(untagged.command);
                  if (expectExists) {
                    let prevCount = connection.mailbox.exists;
                    if (map.seq !== prevCount) {
                      connection.mailbox.exists = map.seq;
                      connection.emit("exists", {
                        path: connection.mailbox.path,
                        count: map.seq,
                        prevCount
                      });
                    }
                  }
                }
              },
              comment: "Sequence not found from APPEND output"
            });
            response.next();
          } catch (err) {
            connection.log.warn({ err, cid: connection.id });
          }
        }
        if (map.seq && !map.uid) {
          let list = await connection.search({ seq: map.seq }, { uid: true });
          if (list && list.length) {
            map.uid = list[0];
          }
        }
        return map;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        connection.log.warn({ err, cid: connection.id });
        throw err;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/status.js
var require_status = __commonJS({
  "../node_modules/imapflow/lib/commands/status.js"(exports, module) {
    "use strict";
    var { encodePath, normalizePath } = require_tools();
    module.exports = async (connection, path, query) => {
      if (![connection.states.AUTHENTICATED, connection.states.SELECTED].includes(connection.state) || !path) {
        return false;
      }
      path = normalizePath(connection, path);
      let encodedPath = encodePath(connection, path);
      let attributes = [{ type: encodedPath.indexOf("&") >= 0 ? "STRING" : "ATOM", value: encodedPath }];
      let queryAttributes = [];
      Object.keys(query || {}).forEach((key) => {
        if (!query[key]) {
          return;
        }
        switch (key.toUpperCase()) {
          case "MESSAGES":
          case "RECENT":
          case "UIDNEXT":
          case "UIDVALIDITY":
          case "UNSEEN":
            queryAttributes.push({ type: "ATOM", value: key.toUpperCase() });
            break;
          case "HIGHESTMODSEQ":
            if (connection.capabilities.has("CONDSTORE")) {
              queryAttributes.push({ type: "ATOM", value: key.toUpperCase() });
            }
            break;
        }
      });
      if (!queryAttributes.length) {
        return false;
      }
      attributes.push(queryAttributes);
      let response;
      try {
        let map = { path };
        response = await connection.exec("STATUS", attributes, {
          untagged: {
            STATUS: async (untagged) => {
              let updateCurrent = connection.state === connection.states.SELECTED && path === connection.mailbox.path;
              let list = untagged.attributes && Array.isArray(untagged.attributes[1]) ? untagged.attributes[1] : false;
              if (!list) {
                return;
              }
              let key;
              list.forEach((entry, i) => {
                if (i % 2 === 0) {
                  key = entry && typeof entry.value === "string" ? entry.value : false;
                  return;
                }
                if (!key || !entry || typeof entry.value !== "string") {
                  return;
                }
                let value = false;
                switch (key.toUpperCase()) {
                  case "MESSAGES":
                    key = "messages";
                    value = !isNaN(entry.value) ? Number(entry.value) : false;
                    if (updateCurrent) {
                      let prevCount = connection.mailbox.exists;
                      if (prevCount !== value) {
                        connection.mailbox.exists = value;
                        connection.emit("exists", {
                          path,
                          count: value,
                          prevCount
                        });
                      }
                    }
                    break;
                  case "RECENT":
                    key = "recent";
                    value = !isNaN(entry.value) ? Number(entry.value) : false;
                    break;
                  case "UIDNEXT":
                    key = "uidNext";
                    value = !isNaN(entry.value) ? Number(entry.value) : false;
                    if (updateCurrent) {
                      connection.mailbox.uidNext = value;
                    }
                    break;
                  case "UIDVALIDITY":
                    key = "uidValidity";
                    value = !isNaN(entry.value) ? BigInt(entry.value) : false;
                    break;
                  case "UNSEEN":
                    key = "unseen";
                    value = !isNaN(entry.value) ? Number(entry.value) : false;
                    break;
                  case "HIGHESTMODSEQ":
                    key = "highestModseq";
                    value = !isNaN(entry.value) ? BigInt(entry.value) : false;
                    if (updateCurrent) {
                      connection.mailbox.highestModseq = value;
                    }
                    break;
                }
                if (value === false) {
                  return;
                }
                map[key] = value;
              });
            }
          }
        });
        response.next();
        return map;
      } catch (err) {
        if (err.responseStatus === "NO") {
          let folders = await connection.run("LIST", "", path, { listOnly: true });
          if (folders && !folders.length) {
            let error = new Error(`Mailbox doesn't exist: ${path}`);
            error.code = "NotFound";
            error.response = err;
            throw error;
          }
        }
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/copy.js
var require_copy = __commonJS({
  "../node_modules/imapflow/lib/commands/copy.js"(exports, module) {
    "use strict";
    var { getStatusCode, normalizePath, encodePath, expandRange, getErrorText } = require_tools();
    module.exports = async (connection, range, destination, options) => {
      if (connection.state !== connection.states.SELECTED || !range || !destination) {
        return;
      }
      options = options || {};
      destination = normalizePath(connection, destination);
      let attributes = [
        { type: "SEQUENCE", value: range },
        { type: "ATOM", value: encodePath(connection, destination) }
      ];
      let response;
      try {
        response = await connection.exec(options.uid ? "UID COPY" : "COPY", attributes);
        response.next();
        let map = { path: connection.mailbox.path, destination };
        let section = response.response.attributes && response.response.attributes[0] && response.response.attributes[0].section;
        let responseCode = section && section.length && section[0] && typeof section[0].value === "string" ? section[0].value : "";
        switch (responseCode) {
          case "COPYUID":
            {
              let uidValidity = section[1] && typeof section[1].value === "string" && !isNaN(section[1].value) ? BigInt(section[1].value) : false;
              if (uidValidity) {
                map.uidValidity = uidValidity;
              }
              let sourceUids = section[2] && typeof section[2].value === "string" ? expandRange(section[2].value) : false;
              let destinationUids = section[3] && typeof section[3].value === "string" ? expandRange(section[3].value) : false;
              if (sourceUids && destinationUids && sourceUids.length === destinationUids.length) {
                map.uidMap = new Map(sourceUids.map((uid, i) => [uid, destinationUids[i]]));
              }
            }
            break;
        }
        return map;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/move.js
var require_move = __commonJS({
  "../node_modules/imapflow/lib/commands/move.js"(exports, module) {
    "use strict";
    var { getStatusCode, normalizePath, encodePath, expandRange, getErrorText } = require_tools();
    module.exports = async (connection, range, destination, options) => {
      if (connection.state !== connection.states.SELECTED || !range || !destination) {
        return;
      }
      options = options || {};
      destination = normalizePath(connection, destination);
      let attributes = [
        { type: "SEQUENCE", value: range },
        { type: "ATOM", value: encodePath(connection, destination) }
      ];
      let map = { path: connection.mailbox.path, destination };
      if (!connection.capabilities.has("MOVE")) {
        let result = await connection.messageCopy(range, destination, options);
        await connection.messageDelete(range, Object.assign({ silent: true }, options));
        return result;
      }
      let checkMoveInfo = (response2) => {
        let section = response2.attributes && response2.attributes[0] && response2.attributes[0].section;
        let responseCode = section && section.length && section[0] && typeof section[0].value === "string" ? section[0].value : "";
        switch (responseCode) {
          case "COPYUID":
            {
              let uidValidity = section[1] && typeof section[1].value === "string" && !isNaN(section[1].value) ? BigInt(section[1].value) : false;
              if (uidValidity) {
                map.uidValidity = uidValidity;
              }
              let sourceUids = section[2] && typeof section[2].value === "string" ? expandRange(section[2].value) : false;
              let destinationUids = section[3] && typeof section[3].value === "string" ? expandRange(section[3].value) : false;
              if (sourceUids && destinationUids && sourceUids.length === destinationUids.length) {
                map.uidMap = new Map(sourceUids.map((uid, i) => [uid, destinationUids[i]]));
              }
            }
            break;
        }
      };
      let response;
      try {
        response = await connection.exec(options.uid ? "UID MOVE" : "MOVE", attributes, {
          untagged: {
            OK: async (untagged) => {
              checkMoveInfo(untagged);
            }
          }
        });
        response.next();
        checkMoveInfo(response.response);
        return map;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/compress.js
var require_compress = __commonJS({
  "../node_modules/imapflow/lib/commands/compress.js"(exports, module) {
    "use strict";
    module.exports = async (connection) => {
      if (!connection.capabilities.has("COMPRESS=DEFLATE") || connection._inflate) {
        return false;
      }
      let response;
      try {
        response = await connection.exec("COMPRESS", [{ type: "ATOM", value: "DEFLATE" }]);
        response.next();
        return true;
      } catch (err) {
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/quota.js
var require_quota = __commonJS({
  "../node_modules/imapflow/lib/commands/quota.js"(exports, module) {
    "use strict";
    var { encodePath, getStatusCode, normalizePath, getErrorText } = require_tools();
    module.exports = async (connection, path) => {
      if (![connection.states.AUTHENTICATED, connection.states.SELECTED].includes(connection.state) || !path) {
        return;
      }
      if (!connection.capabilities.has("QUOTA")) {
        return false;
      }
      path = normalizePath(connection, path);
      let map = { path };
      let processQuotaResponse = (untagged) => {
        let attributes = untagged.attributes && untagged.attributes[1];
        if (!attributes || !attributes.length) {
          return false;
        }
        let key = false;
        attributes.forEach((attribute, i) => {
          if (i % 3 === 0) {
            key = attribute && typeof attribute.value === "string" ? attribute.value.toLowerCase() : false;
            return;
          }
          if (!key) {
            return;
          }
          let value = attribute && typeof attribute.value === "string" && !isNaN(attribute.value) ? Number(attribute.value) : false;
          if (value === false) {
            return;
          }
          if (i % 3 === 1) {
            if (!map[key]) {
              map[key] = {};
            }
            map[key].usage = value * (key === "storage" ? 1024 : 1);
          }
          if (i % 3 === 2) {
            if (!map[key]) {
              map[key] = {};
            }
            map[key].limit = value * (key === "storage" ? 1024 : 1);
            if (map[key].limit) {
              map[key].status = Math.round((map[key].usage || 0) / map[key].limit * 100) + "%";
            }
          }
        });
      };
      let quotaFound = false;
      let response;
      try {
        response = await connection.exec("GETQUOTAROOT", [{ type: "ATOM", value: encodePath(connection, path) }], {
          untagged: {
            QUOTAROOT: async (untagged) => {
              let quotaRoot = untagged.attributes && untagged.attributes[1] && typeof untagged.attributes[1].value === "string" ? untagged.attributes[1].value : false;
              if (quotaRoot) {
                map.quotaRoot = quotaRoot;
              }
            },
            QUOTA: async (untagged) => {
              quotaFound = true;
              processQuotaResponse(untagged);
            }
          }
        });
        response.next();
        if (map.quotaRoot && !quotaFound) {
          response = await connection.exec("GETQUOTA", [{ type: "ATOM", value: map.quotaRoot }], {
            untagged: {
              QUOTA: async (untagged) => {
                processQuotaResponse(untagged);
              }
            }
          });
        }
        return map;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.response = await getErrorText(err.response);
        connection.log.warn({ err, cid: connection.id });
        return false;
      }
    };
  }
});

// ../node_modules/imapflow/lib/commands/idle.js
var require_idle = __commonJS({
  "../node_modules/imapflow/lib/commands/idle.js"(exports, module) {
    "use strict";
    var NOOP_INTERVAL = 2 * 60 * 1e3;
    async function runIdle(connection) {
      var _a;
      let response;
      let preCheckWaitQueue = [];
      try {
        connection.idling = true;
        let doneRequested = false;
        let doneSent = false;
        let canEnd = false;
        let preCheck = async () => {
          var _a2;
          doneRequested = true;
          if (canEnd && !doneSent) {
            connection.log.debug({
              src: "c",
              msg: `DONE`,
              comment: `breaking IDLE`,
              lockId: (_a2 = connection.currentLock) == null ? void 0 : _a2.lockId,
              path: connection.mailbox && connection.mailbox.path
            });
            connection.write("DONE");
            doneSent = true;
            connection.idling = false;
            connection.preCheck = false;
            while (preCheckWaitQueue.length) {
              let { resolve } = preCheckWaitQueue.shift();
              resolve();
            }
          }
        };
        let connectionPreCheck = () => {
          var _a2;
          let handler = new Promise((resolve, reject) => {
            preCheckWaitQueue.push({ resolve, reject });
          });
          connection.log.trace({
            msg: "Requesting IDLE break",
            lockId: (_a2 = connection.currentLock) == null ? void 0 : _a2.lockId,
            path: connection.mailbox && connection.mailbox.path,
            queued: preCheckWaitQueue.length,
            doneRequested,
            canEnd,
            doneSent
          });
          preCheck().catch((err) => connection.log.warn({ err, cid: connection.id }));
          return handler;
        };
        connection.preCheck = connectionPreCheck;
        response = await connection.exec("IDLE", false, {
          onPlusTag: async () => {
            var _a2;
            connection.log.debug({ msg: `Initiated IDLE, waiting for server input`, lockId: (_a2 = connection.currentLock) == null ? void 0 : _a2.lockId, doneRequested });
            canEnd = true;
            if (doneRequested) {
              try {
                await preCheck();
              } catch (err) {
                connection.log.warn({ err, cid: connection.id });
              }
            }
          },
          onSend: () => {
          }
        });
        if (typeof connection.preCheck === "function" && connection.preCheck === connectionPreCheck) {
          connection.log.trace({
            msg: "Clearing pre-check function",
            lockId: (_a = connection.currentLock) == null ? void 0 : _a.lockId,
            path: connection.mailbox && connection.mailbox.path,
            queued: preCheckWaitQueue.length,
            doneRequested,
            canEnd,
            doneSent
          });
          connection.preCheck = false;
          while (preCheckWaitQueue.length) {
            let { resolve } = preCheckWaitQueue.shift();
            resolve();
          }
        }
        response.next();
        return;
      } catch (err) {
        connection.preCheck = false;
        connection.idling = false;
        connection.log.warn({ err, cid: connection.id });
        while (preCheckWaitQueue.length) {
          let { reject } = preCheckWaitQueue.shift();
          reject(err);
        }
        return false;
      }
    }
    module.exports = async (connection, maxIdleTime) => {
      if (connection.state !== connection.states.SELECTED) {
        return;
      }
      if (connection.capabilities.has("IDLE")) {
        let idleTimer2;
        let stillIdling = false;
        let runIdleLoop = async () => {
          if (maxIdleTime) {
            idleTimer2 = setTimeout(() => {
              if (connection.idling) {
                if (typeof connection.preCheck === "function") {
                  stillIdling = true;
                  connection.log.trace({ msg: "Max allowed IDLE time reached", cid: connection.id });
                  connection.preCheck().catch((err) => connection.log.warn({ err, cid: connection.id }));
                }
              }
            }, maxIdleTime);
          }
          let resp = await runIdle(connection);
          clearTimeout(idleTimer2);
          if (stillIdling) {
            stillIdling = false;
            return runIdleLoop();
          }
          return resp;
        };
        return runIdleLoop();
      }
      let idleTimer;
      return new Promise((resolve) => {
        if (!connection.currentSelectCommand) {
          return resolve();
        }
        connection.preCheck = async () => {
          connection.preCheck = false;
          clearTimeout(idleTimer);
          connection.log.debug({ src: "c", msg: `breaking NOOP loop` });
          connection.idling = false;
          resolve();
        };
        let selectCommand = connection.currentSelectCommand;
        let idleCheck = async () => {
          let response;
          switch (connection.missingIdleCommand) {
            case "SELECT":
              connection.log.debug({ src: "c", msg: `Running SELECT to detect changes in folder` });
              response = await connection.exec(selectCommand.command, selectCommand.arguments);
              break;
            case "STATUS":
              {
                let statusArgs = [selectCommand.arguments[0], []];
                for (let key of ["MESSAGES", "UIDNEXT", "UIDVALIDITY", "UNSEEN"]) {
                  statusArgs[1].push({ type: "ATOM", value: key.toUpperCase() });
                }
                connection.log.debug({ src: "c", msg: `Running STATUS to detect changes in folder` });
                response = await connection.exec("STATUS", statusArgs);
              }
              break;
            case "NOOP":
            default:
              response = await connection.exec("NOOP", false, { comment: "IDLE not supported" });
              break;
          }
          response.next();
        };
        let noopInterval = maxIdleTime ? Math.min(NOOP_INTERVAL, maxIdleTime) : NOOP_INTERVAL;
        let runLoop = () => {
          idleCheck().then(() => {
            clearTimeout(idleTimer);
            idleTimer = setTimeout(runLoop, noopInterval);
          }).catch((err) => {
            clearTimeout(idleTimer);
            connection.preCheck = false;
            connection.log.warn({ err, cid: connection.id });
            resolve();
          });
        };
        connection.log.debug({ src: "c", msg: `initiated NOOP loop` });
        connection.idling = true;
        runLoop();
      });
    };
  }
});

// ../node_modules/imapflow/lib/commands/authenticate.js
var require_authenticate = __commonJS({
  "../node_modules/imapflow/lib/commands/authenticate.js"(exports, module) {
    "use strict";
    var { getStatusCode, getErrorText } = require_tools();
    async function authOauth(connection, username, accessToken) {
      let oauthbearer;
      let command;
      let breaker;
      if (connection.capabilities.has("AUTH=OAUTHBEARER")) {
        oauthbearer = [`n,a=${username},`, `host=${connection.servername}`, `port=993`, `auth=Bearer ${accessToken}`, "", ""].join("");
        command = "OAUTHBEARER";
        breaker = "AQ==";
      } else if (connection.capabilities.has("AUTH=XOAUTH") || connection.capabilities.has("AUTH=XOAUTH2")) {
        oauthbearer = [`user=${username}`, `auth=Bearer ${accessToken}`, "", ""].join("");
        command = "XOAUTH2";
        breaker = "";
      }
      let errorResponse = false;
      try {
        let response = await connection.exec(
          "AUTHENTICATE",
          [
            { type: "ATOM", value: command },
            { type: "ATOM", value: Buffer.from(oauthbearer).toString("base64"), sensitive: true }
          ],
          {
            onPlusTag: async (resp) => {
              if (resp.attributes && resp.attributes[0] && resp.attributes[0].type === "TEXT") {
                try {
                  errorResponse = JSON.parse(Buffer.from(resp.attributes[0].value, "base64").toString());
                } catch (err) {
                  connection.log.debug({ errorResponse: resp.attributes[0].value, err });
                }
              }
              connection.log.debug({ src: "c", msg: breaker, comment: `Error response for ${command}` });
              connection.write(breaker);
            }
          }
        );
        response.next();
        connection.authCapabilities.set(`AUTH=${command}`, true);
        return username;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.authenticationFailed = true;
        err.response = await getErrorText(err.response);
        if (errorResponse) {
          err.oauthError = errorResponse;
        }
        throw err;
      }
    }
    async function authLogin(connection, username, password) {
      let errorResponse = false;
      try {
        let response = await connection.exec("AUTHENTICATE", [{ type: "ATOM", value: "LOGIN" }], {
          onPlusTag: async (resp) => {
            if (resp.attributes && resp.attributes[0] && resp.attributes[0].type === "TEXT") {
              let question = Buffer.from(resp.attributes[0].value, "base64").toString();
              switch (question.toLowerCase().replace(/[:\x00]*$/, "")) {
                case "username":
                case "user name": {
                  let encodedUsername = Buffer.from(username).toString("base64");
                  connection.log.debug({ src: "c", msg: encodedUsername, comment: `Encoded username for AUTH=LOGIN` });
                  connection.write(encodedUsername);
                  break;
                }
                case "password":
                  connection.log.debug({ src: "c", msg: "(* value hidden *)", comment: `Encoded password for AUTH=LOGIN` });
                  connection.write(Buffer.from(password).toString("base64"));
                  break;
                default: {
                  let error = new Error(`Unknown LOGIN question "${question}"`);
                  throw error;
                }
              }
            }
          }
        });
        response.next();
        connection.authCapabilities.set(`AUTH=LOGIN`, true);
        return username;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.authenticationFailed = true;
        err.response = await getErrorText(err.response);
        if (errorResponse) {
          err.oauthError = errorResponse;
        }
        throw err;
      }
    }
    async function authPlain(connection, username, password, authzid) {
      let errorResponse = false;
      try {
        let response = await connection.exec("AUTHENTICATE", [{ type: "ATOM", value: "PLAIN" }], {
          onPlusTag: async () => {
            let authzidValue = authzid || "";
            let encodedResponse = Buffer.from([authzidValue, username, password].join("\0")).toString("base64");
            let loggedResponse = Buffer.from([authzidValue, username, "(* value hidden *)"].join("\0")).toString("base64");
            connection.log.debug({ src: "c", msg: loggedResponse, comment: `Encoded response for AUTH=PLAIN${authzid ? " with authzid" : ""}` });
            connection.write(encodedResponse);
          }
        });
        response.next();
        connection.authCapabilities.set(`AUTH=PLAIN`, true);
        return authzid || username;
      } catch (err) {
        let errorCode = getStatusCode(err.response);
        if (errorCode) {
          err.serverResponseCode = errorCode;
        }
        err.authenticationFailed = true;
        err.response = await getErrorText(err.response);
        if (errorResponse) {
          err.oauthError = errorResponse;
        }
        throw err;
      }
    }
    module.exports = async (connection, username, { accessToken, password, loginMethod, authzid }) => {
      if (connection.state !== connection.states.NOT_AUTHENTICATED) {
        return;
      }
      if (accessToken) {
        if (connection.capabilities.has("AUTH=OAUTHBEARER") || connection.capabilities.has("AUTH=XOAUTH") || connection.capabilities.has("AUTH=XOAUTH2")) {
          return await authOauth(connection, username, accessToken);
        }
      }
      if (password) {
        if (!loginMethod && connection.capabilities.has("AUTH=PLAIN") || loginMethod === "AUTH=PLAIN") {
          return await authPlain(connection, username, password, authzid);
        }
        if (!loginMethod && connection.capabilities.has("AUTH=LOGIN") || loginMethod === "AUTH=LOGIN") {
          return await authLogin(connection, username, password);
        }
      }
      throw new Error("Unsupported authentication mechanism");
    };
  }
});

// ../node_modules/imapflow/lib/imap-commands.js
var require_imap_commands = __commonJS({
  "../node_modules/imapflow/lib/imap-commands.js"(exports, module) {
    "use strict";
    module.exports = /* @__PURE__ */ new Map([
      ["ID", require_id()],
      ["CAPABILITY", require_capability()],
      ["NAMESPACE", require_namespace()],
      ["LOGIN", require_login()],
      ["LOGOUT", require_logout()],
      ["STARTTLS", require_starttls()],
      ["LIST", require_list()],
      ["ENABLE", require_enable()],
      ["SELECT", require_select()],
      ["FETCH", require_fetch()],
      ["CREATE", require_create()],
      ["DELETE", require_delete()],
      ["RENAME", require_rename()],
      ["CLOSE", require_close()],
      ["SUBSCRIBE", require_subscribe()],
      ["UNSUBSCRIBE", require_unsubscribe()],
      ["STORE", require_store()],
      ["SEARCH", require_search()],
      ["NOOP", require_noop()],
      ["EXPUNGE", require_expunge()],
      ["APPEND", require_append()],
      ["STATUS", require_status()],
      ["COPY", require_copy()],
      ["MOVE", require_move()],
      ["COMPRESS", require_compress()],
      ["QUOTA", require_quota()],
      ["IDLE", require_idle()],
      ["AUTHENTICATE", require_authenticate()]
    ]);
  }
});

// ../node_modules/imapflow/lib/imap-flow.js
var require_imap_flow = __commonJS({
  "../node_modules/imapflow/lib/imap-flow.js"(exports, module) {
    var tls = require_tls();
    var net = require_net();
    var crypto = require_crypto();
    var { EventEmitter } = require_events();
    var logger = require_logger();
    var libmime = require_libmime();
    var zlib = require_zlib();
    var { Headers } = require_mailsplit();
    var { LimitedPassthrough } = require_limited_passthrough();
    var { ImapStream } = require_imap_stream();
    var { parser, compiler } = require_imap_handler();
    var packageInfo = require_package();
    var libqp = require_libqp();
    var libbase64 = require_libbase64();
    var FlowedDecoder = require_flowed_decoder();
    var { PassThrough } = require_stream();
    var { proxyConnection } = require_proxy_connection();
    var {
      comparePaths,
      updateCapabilities,
      getFolderTree,
      formatMessageResponse,
      getDecoder,
      packMessageRange,
      normalizePath,
      expandRange,
      AuthenticationFailure,
      getColorFlags
    } = require_tools();
    var imapCommands = require_imap_commands();
    var CONNECT_TIMEOUT = 90 * 1e3;
    var GREETING_TIMEOUT = 16 * 1e3;
    var UPGRADE_TIMEOUT = 10 * 1e3;
    var SOCKET_TIMEOUT = 5 * 60 * 1e3;
    var states = {
      NOT_AUTHENTICATED: 1,
      AUTHENTICATED: 2,
      SELECTED: 3,
      LOGOUT: 4
    };
    var ImapFlow = class extends EventEmitter {
      /**
       * IMAP connection options
       *
       * @property {String} host
       *     Hostname of the IMAP server.
       *
       * @property {Number} port
       *     Port number for the IMAP server.
       *
       * @property {Boolean} [secure=false]
       *     If `true`, establishes the connection directly over TLS (commonly on port 993).
       *     If `false`, a plain (unencrypted) connection is used first and, if possible, the connection is upgraded to STARTTLS.
       *
       * @property {Boolean} [doSTARTTLS=undefined]
       *     Determines whether to upgrade the connection to TLS via STARTTLS:
       *       - **true**: Start unencrypted and upgrade to TLS using STARTTLS before authentication.
       *         The connection fails if the server does not support STARTTLS or the upgrade fails.
       *         Note that `secure=true` combined with `doSTARTTLS=true` is invalid.
       *       - **false**: Never use STARTTLS, even if the server advertises support.
       *         This is useful if the server has a broken TLS setup.
       *         Combined with `secure=false`, this results in a fully unencrypted connection.
       *         Make sure you warn users about the security risks.
       *       - **undefined** (default): If `secure=false` (default), attempt to upgrade to TLS via STARTTLS before authentication if the server supports it. If not supported, continue unencrypted. This may expose the connection to a downgrade attack.
       *
       * @property {String} [servername]
       *     Server name for SNI or when using an IP address as `host`.
       *
       * @property {Boolean} [disableCompression=false]
       *     If `true`, the client does not attempt to use the COMPRESS=DEFLATE extension.
       *
       * @property {Object} auth
       *     Authentication options. Authentication occurs automatically during {@link connect}.
       *
       * @property {String} auth.user
       *     Username for authentication.
       *
       * @property {String} [auth.pass]
       *     Password for regular authentication.
       *
       * @property {String} [auth.accessToken]
       *     OAuth2 access token, if using OAuth2 authentication.
       *
       * @property {String} [auth.loginMethod]
       *     Optional login method for password-based authentication (e.g., "LOGIN", "AUTH=LOGIN", or "AUTH=PLAIN").
       *     If not set, ImapFlow chooses based on available mechanisms.
       *
       * @property {String} [auth.authzid]
       *     Authorization identity for SASL PLAIN authentication (used for admin impersonation/delegation).
       *     When set, authenticates as `auth.user` but authorizes as `auth.authzid`.
       *     This is typically used in mail systems like Zimbra for admin users to access other users' mailboxes.
       *     Only works with AUTH=PLAIN mechanism.
       *
       * @property {IdInfoObject} [clientInfo]
       *     Client identification info sent to the server (via the ID command).
       *
       * @property {Boolean} [disableAutoIdle=false]
       *     If `true`, do not start IDLE automatically. Useful when only specific operations are needed.
       *
       * @property {Object} [tls]
       *     Additional TLS options. For details, see [Node.js TLS connect](https://nodejs.org/api/tls.html#tls_tls_connect_options_callback).
       *
       * @property {Boolean} [tls.rejectUnauthorized=true]
       *     If `false`, allows self-signed or expired certificates.
       *
       * @property {String} [tls.minVersion='TLSv1.2']
       *     Minimum accepted TLS version (e.g., `'TLSv1.2'`).
       *
       * @property {Number} [tls.minDHSize=1024]
       *     Minimum size (in bits) of the DH parameter for TLS connections.
       *
       * @property {Object|Boolean} [logger]
       *     Custom logger instance with `debug(obj)`, `info(obj)`, `warn(obj)`, and `error(obj)` methods.
       *     If `false`, logging is disabled. If not provided, ImapFlow logs to console in [pino format](https://getpino.io/).
       *
       * @property {Boolean} [logRaw=false]
       *     If `true`, logs all raw data (read and written) in base64 encoding. You can pipe such logs to [eerawlog](https://github.com/postalsys/eerawlog) command for readable output.
       *
       * @property {Boolean} [emitLogs=false]
       *     If `true`, emits `'log'` events with the same data passed to the logger.
       *
       * @property {Boolean} [verifyOnly=false]
       *     If `true`, disconnects after successful authentication without performing other actions.
       *
       * @property {String} [proxy]
       *     Proxy URL. Supports HTTP CONNECT (`http://`, `https://`) and SOCKS (`socks://`, `socks4://`, `socks5://`).
       *
       * @property {Boolean} [qresync=false]
       *     If `true`, enables QRESYNC support so that EXPUNGE notifications include `uid` instead of `seq`.
       *
       * @property {Number} [maxIdleTime]
       *     If set, breaks and restarts IDLE every `maxIdleTime` milliseconds.
       *
       * @property {String} [missingIdleCommand="NOOP"]
       *     Command to use if the server does not support IDLE.
       *
       * @property {Boolean} [disableBinary=false]
       *     If `true`, ignores the BINARY extension for FETCH and APPEND operations.
       *
       * @property {Boolean} [disableAutoEnable=false]
       *     If `true`, do not automatically enable supported IMAP extensions.
       *
       * @property {Number} [connectionTimeout=90000]
       *     Maximum time (in milliseconds) to wait for the connection to establish. Defaults to 90 seconds.
       *
       * @property {Number} [greetingTimeout=16000]
       *     Maximum time (in milliseconds) to wait for the server greeting after a connection is established. Defaults to 16 seconds.
       *
       * @property {Number} [socketTimeout=300000]
       *     Maximum period of inactivity (in milliseconds) before terminating the connection. Defaults to 5 minutes.
       */
      constructor(options) {
        super({ captureRejections: true });
        this.options = options || {};
        this.id = this.options.id || this.getRandomId();
        this.clientInfo = Object.assign(
          {
            name: packageInfo.name,
            version: packageInfo.version,
            vendor: "Postal Systems",
            "support-url": "https://github.com/postalsys/imapflow/issues"
          },
          this.options.clientInfo || {}
        );
        for (let key of Object.keys(this.clientInfo)) {
          if (typeof this.clientInfo[key] === "string") {
            this.clientInfo[key] = this.clientInfo[key].normalize("NFD").replace(new RegExp("\\p{Diacritic}", "gu"), "");
          }
        }
        this.serverInfo = null;
        this.log = this.getLogger();
        this.secureConnection = !!this.options.secure;
        this.port = Number(this.options.port) || (this.secureConnection ? 993 : 110);
        this.host = this.options.host || "localhost";
        this.servername = this.options.servername ? this.options.servername : !net.isIP(this.host) ? this.host : false;
        if (typeof this.options.secure === "undefined" && this.port === 993) {
          this.secureConnection = true;
        }
        this.logRaw = this.options.logRaw;
        this.streamer = new ImapStream({
          logger: this.log,
          cid: this.id,
          logRaw: this.logRaw,
          secureConnection: this.secureConnection
        });
        this.reading = false;
        this.socket = false;
        this.writeSocket = false;
        this.isClosed = false;
        this.states = states;
        this.state = this.states.NOT_AUTHENTICATED;
        this.lockCounter = 0;
        this.currentLock = false;
        this.tagCounter = 0;
        this.requestTagMap = /* @__PURE__ */ new Map();
        this.requestQueue = [];
        this.currentRequest = false;
        this.writeBytesCounter = 0;
        this.commandParts = [];
        this.capabilities = /* @__PURE__ */ new Map();
        this.authCapabilities = /* @__PURE__ */ new Map();
        this.rawCapabilities = null;
        this.expectCapabilityUpdate = false;
        this.enabled = /* @__PURE__ */ new Set();
        this.usable = false;
        this.authenticated = false;
        this.mailbox = false;
        this.currentSelectCommand = false;
        this.idling = false;
        this.emitLogs = !!this.options.emitLogs;
        this.lo = 0;
        this.untaggedHandlers = {};
        this.sectionHandlers = {};
        this.commands = imapCommands;
        this.folders = /* @__PURE__ */ new Map();
        this.currentLock = false;
        this.locks = [];
        this.idRequested = false;
        this.maxIdleTime = this.options.maxIdleTime || false;
        this.missingIdleCommand = (this.options.missingIdleCommand || "").toString().toUpperCase().trim() || "NOOP";
        this.disableBinary = !!this.options.disableBinary;
        this.streamer.on("error", (err) => {
          if (["Z_BUF_ERROR", "ECONNRESET", "EPIPE", "ETIMEDOUT", "EHOSTUNREACH"].includes(err.code)) {
            this.closeAfter();
            return;
          }
          this.log.error({ err, cid: this.id });
          this.emitError(err);
        });
        this._connectCalled = false;
      }
      emitError(err) {
        if (!err) {
          return;
        }
        err._connId = err._connId || this.id;
        this.closeAfter();
        this.emit("error", err);
      }
      getRandomId() {
        let rid = BigInt("0x" + crypto.randomBytes(13).toString("hex")).toString(36);
        if (rid.length < 20) {
          rid = "0".repeat(20 - rid.length) + rid;
        } else if (rid.length > 20) {
          rid = rid.substr(0, 20);
        }
        return rid;
      }
      write(chunk) {
        if (!this.socket || this.socket.destroyed) {
          const error = new Error("Socket is already closed");
          error.code = "NoConnection";
          throw error;
        }
        if (this.state === this.states.LOGOUT) {
          const error = new Error("Can not send data after logged out");
          error.code = "StateLogout";
          throw error;
        }
        if (this.writeSocket.destroyed) {
          this.log.error({ msg: "Write socket destroyed", cid: this.id });
          this.close();
          return;
        }
        let addLineBreak = !this.commandParts.length;
        if (typeof chunk === "string") {
          if (addLineBreak) {
            chunk += "\r\n";
          }
          chunk = Buffer.from(chunk, "binary");
        } else if (Buffer.isBuffer(chunk)) {
          if (addLineBreak) {
            chunk = Buffer.concat([chunk, Buffer.from("\r\n")]);
          }
        } else {
          return false;
        }
        if (this.logRaw) {
          this.log.trace({
            src: "c",
            msg: "write to socket",
            data: chunk.toString("base64"),
            compress: !!this._deflate,
            secure: !!this.secureConnection,
            cid: this.id
          });
        }
        this.writeBytesCounter += chunk.length;
        this.writeSocket.write(chunk);
      }
      stats(reset) {
        let result = {
          sent: this.writeBytesCounter || 0,
          received: this.streamer && this.streamer.readBytesCounter || 0
        };
        if (reset) {
          this.writeBytesCounter = 0;
          if (this.streamer) {
            this.streamer.readBytesCounter = 0;
          }
        }
        return result;
      }
      async send(data) {
        if (this.state === this.states.LOGOUT) {
          if (data.tag) {
            let request = this.requestTagMap.get(data.tag);
            if (request) {
              this.requestTagMap.delete(request.tag);
              const error = new Error("Connection not available");
              error.code = "NoConnection";
              request.reject(error);
            }
          }
          return;
        }
        let compiled = await compiler(data, {
          asArray: true,
          literalMinus: this.capabilities.has("LITERAL-") || this.capabilities.has("LITERAL+")
        });
        this.commandParts = compiled;
        let logCompiled = await compiler(data, {
          isLogging: true
        });
        let options = data.options || {};
        this.log.debug({ src: "c", msg: logCompiled.toString(), cid: this.id, comment: options.comment });
        this.write(this.commandParts.shift());
        if (typeof options.onSend === "function") {
          options.onSend();
        }
      }
      async trySend() {
        if (this.currentRequest || !this.requestQueue.length) {
          return;
        }
        this.currentRequest = this.requestQueue.shift();
        await this.send({
          tag: this.currentRequest.tag,
          command: this.currentRequest.command,
          attributes: this.currentRequest.attributes,
          options: this.currentRequest.options
        });
      }
      async exec(command, attributes, options) {
        if (this.state === this.states.LOGOUT || this.isClosed) {
          const error = new Error("Connection not available");
          error.code = "NoConnection";
          throw error;
        }
        if (!this.socket || this.socket.destroyed) {
          let error = new Error("Connection closed");
          error.code = "EConnectionClosed";
          throw error;
        }
        let tag = (++this.tagCounter).toString(16).toUpperCase();
        options = options || {};
        return new Promise((resolve, reject) => {
          this.requestTagMap.set(tag, { command, attributes, options, resolve, reject });
          this.requestQueue.push({ tag, command, attributes, options });
          this.trySend().catch((err) => {
            this.requestTagMap.delete(tag);
            reject(err);
          });
        });
      }
      getUntaggedHandler(command, attributes) {
        if (/^[0-9]+$/.test(command)) {
          let type = attributes && attributes.length && typeof attributes[0].value === "string" ? attributes[0].value.toUpperCase() : false;
          if (type) {
            command = type;
          }
        }
        command = command.toUpperCase().trim();
        if (this.currentRequest && this.currentRequest.options && this.currentRequest.options.untagged && this.currentRequest.options.untagged[command]) {
          return this.currentRequest.options.untagged[command];
        }
        if (this.untaggedHandlers[command]) {
          return this.untaggedHandlers[command];
        }
      }
      getSectionHandler(key) {
        if (this.sectionHandlers[key]) {
          return this.sectionHandlers[key];
        }
      }
      async reader() {
        let data;
        let processedCount = 0;
        while ((data = this.streamer.read()) !== null) {
          let parsed;
          try {
            parsed = await parser(data.payload, { literals: data.literals });
            if (parsed.tag && !["*", "+"].includes(parsed.tag) && parsed.command) {
              let payload = { response: parsed.command };
              if (parsed.attributes && parsed.attributes[0] && parsed.attributes[0].section && parsed.attributes[0].section[0] && parsed.attributes[0].section[0].type === "ATOM") {
                payload.code = parsed.attributes[0].section[0].value;
              }
              this.emit("response", payload);
            }
          } catch (err) {
            this.log.error({ src: "s", msg: data.payload.toString(), err, cid: this.id });
            data.next();
            continue;
          }
          let logCompiled = await compiler(parsed, {
            isLogging: true
          });
          if (/^\d+$/.test(parsed.command) && parsed.attributes && parsed.attributes[0] && parsed.attributes[0].value === "FETCH") {
            this.log.trace({ src: "s", msg: logCompiled.toString(), cid: this.id, nullBytesRemoved: parsed.nullBytesRemoved });
          } else {
            this.log.debug({ src: "s", msg: logCompiled.toString(), cid: this.id, nullBytesRemoved: parsed.nullBytesRemoved });
          }
          if (parsed.tag === "+" && this.currentRequest && this.currentRequest.options && typeof this.currentRequest.options.onPlusTag === "function") {
            await this.currentRequest.options.onPlusTag(parsed);
            data.next();
            continue;
          }
          if (parsed.tag === "+" && this.commandParts.length) {
            let content = this.commandParts.shift();
            this.write(content);
            this.log.debug({ src: "c", msg: `(* ${content.length}B continuation *)`, cid: this.id });
            data.next();
            continue;
          }
          let section = parsed.attributes && parsed.attributes.length && parsed.attributes[0] && !parsed.attributes[0].value && parsed.attributes[0].section;
          if (section && section.length && section[0].type === "ATOM" && typeof section[0].value === "string") {
            let sectionHandler = this.getSectionHandler(section[0].value.toUpperCase().trim());
            if (sectionHandler) {
              await sectionHandler(section.slice(1));
            }
          }
          if (parsed.tag === "*" && parsed.command) {
            let untaggedHandler = this.getUntaggedHandler(parsed.command, parsed.attributes);
            if (untaggedHandler) {
              try {
                await untaggedHandler(parsed);
              } catch (err) {
                this.log.warn({ err, cid: this.id });
                data.next();
                continue;
              }
            }
          }
          if (this.requestTagMap.has(parsed.tag)) {
            let request = this.requestTagMap.get(parsed.tag);
            this.requestTagMap.delete(parsed.tag);
            if (this.currentRequest && this.currentRequest.tag === parsed.tag) {
              this.currentRequest = false;
              await this.trySend();
            }
            switch (parsed.command.toUpperCase()) {
              case "OK":
              case "BYE":
                await new Promise((resolve) => request.resolve({ response: parsed, next: resolve }));
                break;
              case "NO":
              case "BAD": {
                let txt = parsed.attributes && parsed.attributes.filter((val) => val.type === "TEXT").map((val) => val.value.trim()).join(" ");
                let err = new Error("Command failed");
                err.response = parsed;
                err.responseStatus = parsed.command.toUpperCase();
                try {
                  err.executedCommand = parsed.tag + (await compiler(request, {
                    isLogging: true
                  })).toString();
                } catch {
                }
                if (txt) {
                  err.responseText = txt;
                  if (err.responseStatus === "NO" && txt.includes("Some of the requested messages no longer exist")) {
                    this.log.warn({ msg: "Partial FETCH response", cid: this.id, err });
                    await new Promise((resolve) => request.resolve({ response: parsed, next: resolve }));
                    break;
                  }
                  let throttleDelay = false;
                  if (/Request is throttled/i.test(txt) && /Backoff Time/i.test(txt)) {
                    let throttlingMatch = txt.match(/Backoff Time[:=\s]+(\d+)/i);
                    if (throttlingMatch && throttlingMatch[1] && !isNaN(throttlingMatch[1])) {
                      throttleDelay = Number(throttlingMatch[1]);
                    }
                  }
                  if (throttleDelay) {
                    err.code = "ETHROTTLE";
                    err.throttleReset = throttleDelay;
                    let delayResponse = throttleDelay;
                    if (delayResponse > 5 * 60 * 1e3) {
                      delayResponse = 5 * 60 * 1e3;
                    }
                    this.log.warn({ msg: "Throttling detected", cid: this.id, throttleDelay, delayResponse, err });
                    await new Promise((r) => setTimeout(r, delayResponse));
                  }
                }
                request.reject(err);
                break;
              }
              default: {
                let err = new Error("Invalid server response");
                err.code = "InvalidResponse";
                err.response = parsed;
                request.reject(err);
                break;
              }
            }
          }
          data.next();
          processedCount++;
          if (processedCount % 10 === 0) {
            await new Promise((resolve) => setImmediate(resolve));
          }
        }
      }
      setEventHandlers() {
        this.socketReadable = () => {
          if (!this.reading) {
            this.reading = true;
            this.reader().catch((err) => this.log.error({ err, cid: this.id })).finally(() => {
              this.reading = false;
            });
          }
        };
        this.streamer.on("readable", this.socketReadable);
      }
      setSocketHandlers() {
        this.clearSocketHandlers();
        this._socketError = this._socketError || ((err) => {
          this.log.error({ err, cid: this.id });
          this.emitError(err);
        });
        this._socketClose = this._socketClose || (() => this.close());
        this._socketEnd = this._socketEnd || (() => this.close());
        this._socketTimeout = this._socketTimeout || (() => {
          const err = new Error("Socket timeout");
          err.code = "ETIMEOUT";
          if (this.idling) {
            if (!this.usable || !this.socket || this.socket.destroyed) {
              this.emitError(err);
              return;
            }
            this.run("NOOP").then(() => this.idle()).catch(this._socketError);
          } else {
            this.log.debug({ msg: "Socket timeout", cid: this.id });
            this.emitError(err);
          }
        });
        this.socket.once("error", this._socketError);
        this.socket.once("close", this._socketClose);
        this.socket.once("end", this._socketEnd);
        this.socket.on("tlsClientError", this._socketError);
        this.socket.on("timeout", this._socketTimeout);
        if (this.writeSocket && this.writeSocket !== this.socket) {
          this.writeSocket.on("error", this._socketError);
        }
      }
      clearSocketHandlers() {
        if (!this.socket) {
          return;
        }
        if (this._socketError) {
          this.socket.removeListener("error", this._socketError);
          this.socket.removeListener("tlsClientError", this._socketError);
          if (this.writeSocket && this.writeSocket !== this.socket) {
            this.writeSocket.removeListener("error", this._socketError);
          }
        }
        if (this._socketTimeout) {
          this.socket.removeListener("timeout", this._socketTimeout);
        }
        if (this._socketClose) {
          this.socket.removeListener("close", this._socketClose);
        }
        if (this._socketEnd) {
          this.socket.removeListener("end", this._socketEnd);
        }
      }
      async startSession() {
        await this.run("CAPABILITY");
        if (this.capabilities.has("ID")) {
          this.idRequested = await this.run("ID", this.clientInfo);
        }
        await this.upgradeToSTARTTLS();
        await this.authenticate();
        if ((!this.idRequested || Object.keys(this.idRequested).length < 2) && this.capabilities.has("ID")) {
          this.idRequested = await this.run("ID", this.clientInfo);
        }
        let nsResponse = await this.run("NAMESPACE");
        if (nsResponse && nsResponse.error && nsResponse.status === "BAD" && /User is authenticated but not connected/i.test(nsResponse.text)) {
          this.authenticated = false;
          let err = new AuthenticationFailure("Authentication failed");
          err.response = nsResponse.text;
          throw err;
        }
        if (this.options.verifyOnly) {
          if (this.options.includeMailboxes) {
            this._mailboxList = await this.list();
          }
          return await this.logout();
        }
        if (!this.options.disableCompression) {
          await this.compress();
        }
        if (!this.options.disableAutoEnable) {
          await this.run("ENABLE", ["CONDSTORE", "UTF8=ACCEPT"].concat(this.options.qresync ? "QRESYNC" : []));
        }
        this.usable = true;
      }
      async compress() {
        if (!await this.run("COMPRESS")) {
          return;
        }
        this._deflate = zlib.createDeflateRaw({
          windowBits: 15,
          level: zlib.constants.Z_DEFAULT_COMPRESSION,
          // Use default compression level (6)
          memLevel: 8,
          // Memory usage level (8 is default)
          strategy: zlib.constants.Z_DEFAULT_STRATEGY,
          chunkSize: 16 * 1024
          // Process in 16KB chunks to prevent CPU blocking
        });
        this._inflate = zlib.createInflateRaw({
          chunkSize: 16 * 1024
          // Process in 16KB chunks to prevent CPU blocking
        });
        this.socket.unpipe(this.streamer);
        this.streamer.compress = true;
        this.socket.pipe(this._inflate).pipe(this.streamer);
        this._inflate.on("error", (err) => {
          this.streamer.emit("error", err);
        });
        this.writeSocket = new PassThrough({
          highWaterMark: 64 * 1024
          // 64KB buffer limit to prevent excessive memory usage
        });
        this.writeSocket.destroySoon = () => {
          try {
            if (this.socket) {
              this.socket.destroy();
            }
            this.writeSocket.end();
          } catch (err) {
            this.log.error({ err, info: "Failed to destroy PassThrough socket", cid: this.id });
            throw err;
          }
        };
        Object.defineProperty(this.writeSocket, "destroyed", {
          get: () => !this.socket || this.socket.destroyed
        });
        let reading = false;
        let processedChunks = 0;
        let readNext = async () => {
          try {
            reading = true;
            processedChunks = 0;
            let chunk;
            while ((chunk = this.writeSocket.read()) !== null) {
              if (this._deflate && this._deflate.write(chunk) === false) {
                return this._deflate.once("drain", readNext);
              }
              processedChunks++;
              if (processedChunks % 100 === 0) {
                await new Promise((resolve) => setImmediate(resolve));
              }
            }
            if (this._deflate) {
              this._deflate.flush();
            }
            reading = false;
          } catch (ex) {
            this.emitError(ex);
          }
        };
        this.writeSocket.on("readable", () => {
          if (!reading) {
            readNext();
          }
        });
        this.writeSocket.on("error", (err) => {
          this.socket.emit("error", err);
        });
        this._deflate.pipe(this.socket);
        this._deflate.on("error", (err) => {
          this.socket.emit("error", err);
        });
      }
      _failSTARTTLS() {
        if (this.options.doSTARTTLS === true) {
          let err = new Error("Server does not support STARTTLS");
          err.tlsFailed = true;
          throw err;
        } else {
          return false;
        }
      }
      /**
       * Tries to upgrade the connection to TLS using STARTTLS.
       * @throws if STARTTLS is required, but not possible.
       * @returns {boolean} true, if the connection is now protected by TLS, either direct TLS or STARTTLS.
       */
      async upgradeToSTARTTLS() {
        if (this.options.doSTARTTLS === true && this.options.secure === true) {
          throw new Error("Misconfiguration: Cannot set both secure=true for TLS and doSTARTTLS=true for STARTTLS.");
        }
        if (this.secureConnection) {
          return true;
        }
        if (this.options.doSTARTTLS === false) {
          return false;
        }
        if (!this.capabilities.has("STARTTLS")) {
          return this._failSTARTTLS();
        }
        this.expectCapabilityUpdate = true;
        let canUpgrade = await this.run("STARTTLS");
        if (!canUpgrade) {
          return this._failSTARTTLS();
        }
        this.socket.unpipe(this.streamer);
        let upgraded = await new Promise((resolve, reject) => {
          let socketPlain = this.socket;
          let opts = Object.assign(
            {
              socket: this.socket,
              servername: this.servername,
              port: this.port
            },
            this.options.tls || {}
          );
          this.clearSocketHandlers();
          socketPlain.once("error", (err) => {
            clearTimeout(this.connectTimeout);
            clearTimeout(this.upgradeTimeout);
            if (!this.upgrading) {
              return;
            }
            this.closeAfter();
            this.upgrading = false;
            err.tlsFailed = true;
            reject(err);
          });
          this.upgradeTimeout = setTimeout(() => {
            if (!this.upgrading) {
              return;
            }
            this.closeAfter();
            let err = new Error("Failed to upgrade connection in required time");
            err.tlsFailed = true;
            err.code = "UPGRADE_TIMEOUT";
            reject(err);
          }, UPGRADE_TIMEOUT);
          this.upgrading = true;
          this.socket = tls.connect(opts, () => {
            try {
              clearTimeout(this.upgradeTimeout);
              if (this.isClosed) {
                return this.close();
              }
              this.secureConnection = true;
              this.upgrading = false;
              this.streamer.secureConnection = true;
              this.socket.pipe(this.streamer);
              this.tls = typeof this.socket.getCipher === "function" ? this.socket.getCipher() : false;
              if (this.tls) {
                this.tls.authorized = this.socket.authorized;
                this.log.info({
                  src: "tls",
                  msg: "Established TLS session",
                  cid: this.id,
                  authorized: this.tls.authorized,
                  algo: this.tls.standardName || this.tls.name,
                  version: this.tls.version
                });
              }
              return resolve(true);
            } catch (ex) {
              this.emitError(ex);
            }
          });
          this.writeSocket = this.socket;
          this.setSocketHandlers();
        });
        if (upgraded && this.expectCapabilityUpdate) {
          await this.run("CAPABILITY");
        }
        return upgraded;
      }
      async setAuthenticationState() {
        this.state = this.states.AUTHENTICATED;
        this.authenticated = true;
        if (this.expectCapabilityUpdate) {
          await this.run("CAPABILITY");
        }
      }
      async authenticate() {
        if (this.state === this.states.LOGOUT) {
          throw new AuthenticationFailure("Already logged out");
        }
        if (this.state !== this.states.NOT_AUTHENTICATED) {
          return true;
        }
        if (!this.options.auth) {
          throw new AuthenticationFailure("Please configure the login");
        }
        this.expectCapabilityUpdate = true;
        let loginMethod = (this.options.auth.loginMethod || "").toString().trim().toUpperCase();
        if (!loginMethod && /\\|\//.test(this.options.auth.user)) {
          loginMethod = "LOGIN";
        }
        if (this.options.auth.accessToken) {
          this.authenticated = await this.run("AUTHENTICATE", this.options.auth.user, { accessToken: this.options.auth.accessToken });
        } else if (this.options.auth.pass) {
          if ((this.capabilities.has("AUTH=LOGIN") || this.capabilities.has("AUTH=PLAIN")) && loginMethod !== "LOGIN") {
            this.authenticated = await this.run("AUTHENTICATE", this.options.auth.user, {
              password: this.options.auth.pass,
              loginMethod,
              authzid: this.options.auth.authzid
            });
          } else {
            if (this.capabilities.has("LOGINDISABLED")) {
              throw new AuthenticationFailure("Login is disabled");
            }
            this.authenticated = await this.run("LOGIN", this.options.auth.user, this.options.auth.pass);
          }
        } else {
          throw new AuthenticationFailure("No password configured");
        }
        if (this.authenticated) {
          this.log.info({
            src: "auth",
            msg: "User authenticated",
            cid: this.id,
            user: this.options.auth.user
          });
          await this.setAuthenticationState();
          return true;
        }
        throw new AuthenticationFailure("No matching authentication method");
      }
      async initialOK(message) {
        this.greeting = (message.attributes || []).filter((entry) => entry.type === "TEXT").map((entry) => entry.value).filter((entry) => entry).join("");
        clearTimeout(this.greetingTimeout);
        this.untaggedHandlers.OK = null;
        this.untaggedHandlers.PREAUTH = null;
        if (this.isClosed) {
          return;
        }
        this.startSession().then(() => {
          if (typeof this.initialResolve === "function") {
            let resolve = this.initialResolve;
            this.initialResolve = false;
            this.initialReject = false;
            return resolve();
          }
        }).catch((err) => {
          this.log.error({ err, cid: this.id });
          if (typeof this.initialReject === "function") {
            clearTimeout(this.greetingTimeout);
            let reject = this.initialReject;
            this.initialResolve = false;
            this.initialReject = false;
            return reject(err);
          }
          this.emitError(err);
        });
      }
      async initialPREAUTH() {
        clearTimeout(this.greetingTimeout);
        this.untaggedHandlers.OK = null;
        this.untaggedHandlers.PREAUTH = null;
        if (this.isClosed) {
          return;
        }
        this.state = this.states.AUTHENTICATED;
        this.startSession().then(() => {
          if (typeof this.initialResolve === "function") {
            let resolve = this.initialResolve;
            this.initialResolve = false;
            this.initialReject = false;
            return resolve();
          }
        }).catch((err) => {
          this.log.error({ err, cid: this.id });
          if (typeof this.initialReject === "function") {
            clearTimeout(this.greetingTimeout);
            let reject = this.initialReject;
            this.initialResolve = false;
            this.initialReject = false;
            return reject(err);
          }
          this.closeAfter();
        });
      }
      async serverBye() {
        this.untaggedHandlers.BYE = null;
        this.state = this.states.LOGOUT;
      }
      async sectionCapability(section) {
        this.rawCapabilities = section;
        this.capabilities = updateCapabilities(section);
        if (this.capabilities) {
          for (let [capa] of this.capabilities) {
            if (/^AUTH=/i.test(capa) && !this.authCapabilities.has(capa.toUpperCase())) {
              this.authCapabilities.set(capa.toUpperCase(), false);
            }
          }
        }
        if (this.expectCapabilityUpdate) {
          this.expectCapabilityUpdate = false;
        }
      }
      async untaggedCapability(untagged) {
        this.rawCapabilities = untagged.attributes;
        this.capabilities = updateCapabilities(untagged.attributes);
        if (this.capabilities) {
          for (let [capa] of this.capabilities) {
            if (/^AUTH=/i.test(capa) && !this.authCapabilities.has(capa.toUpperCase())) {
              this.authCapabilities.set(capa.toUpperCase(), false);
            }
          }
        }
        if (this.expectCapabilityUpdate) {
          this.expectCapabilityUpdate = false;
        }
      }
      async untaggedExists(untagged) {
        if (!this.mailbox) {
          return;
        }
        if (!untagged || !untagged.command || isNaN(untagged.command)) {
          return;
        }
        let count = Number(untagged.command);
        if (count === this.mailbox.exists) {
          return;
        }
        let prevCount = this.mailbox.exists;
        this.mailbox.exists = count;
        this.emit("exists", {
          path: this.mailbox.path,
          count,
          prevCount
        });
      }
      async untaggedExpunge(untagged) {
        if (!this.mailbox) {
          return;
        }
        if (!untagged || !untagged.command || isNaN(untagged.command)) {
          return;
        }
        let seq = Number(untagged.command);
        if (seq && seq <= this.mailbox.exists) {
          this.mailbox.exists--;
          let payload = {
            path: this.mailbox.path,
            seq,
            vanished: false
          };
          if (typeof this.options.expungeHandler === "function") {
            try {
              await this.options.expungeHandler(payload);
            } catch (err) {
              this.log.error({ msg: "Failed to notify expunge event", payload, error: err, cid: this.id });
            }
          } else {
            this.emit("expunge", payload);
          }
        }
      }
      async untaggedVanished(untagged, mailbox) {
        mailbox = mailbox || this.mailbox;
        if (!mailbox) {
          return;
        }
        let tags = [];
        let uids = false;
        if (untagged.attributes.length > 1 && Array.isArray(untagged.attributes[0])) {
          tags = untagged.attributes[0].map((entry) => typeof entry.value === "string" ? entry.value.toUpperCase() : false).filter((value) => value);
          untagged.attributes.shift();
        }
        if (untagged.attributes[0] && typeof untagged.attributes[0].value === "string") {
          uids = untagged.attributes[0].value;
        }
        let uidList = expandRange(uids);
        for (let uid of uidList) {
          let payload = {
            path: mailbox.path,
            uid,
            vanished: true,
            earlier: tags.includes("EARLIER")
          };
          if (typeof this.options.expungeHandler === "function") {
            try {
              await this.options.expungeHandler(payload);
            } catch (err) {
              this.log.error({ msg: "Failed to notify expunge event", payload, error: err, cid: this.id });
            }
          } else {
            this.emit("expunge", payload);
          }
        }
      }
      async untaggedFetch(untagged, mailbox) {
        mailbox = mailbox || this.mailbox;
        if (!mailbox) {
          return;
        }
        let message = await formatMessageResponse(untagged, mailbox);
        if (message.flags) {
          let updateEvent = {
            path: mailbox.path,
            seq: message.seq
          };
          if (message.uid) {
            updateEvent.uid = message.uid;
          }
          if (message.modseq) {
            updateEvent.modseq = message.modseq;
          }
          updateEvent.flags = message.flags;
          if (message.flagColor) {
            updateEvent.flagColor = message.flagColor;
          }
          this.emit("flags", updateEvent);
        }
      }
      async ensureSelectedMailbox(path) {
        if (!path) {
          return false;
        }
        if (!this.mailbox && path || this.mailbox && path && !comparePaths(this, this.mailbox.path, path)) {
          return await this.mailboxOpen(path);
        }
        return true;
      }
      async resolveRange(range, options) {
        if (typeof range === "number" || typeof range === "bigint") {
          range = range.toString();
        }
        if (range === "*") {
          if (!this.mailbox.exists) {
            return false;
          }
          range = this.mailbox.exists.toString();
          options.uid = false;
        }
        if (range && typeof range === "object" && !Array.isArray(range)) {
          if (range.all && Object.keys(range).length === 1) {
            range = "1:*";
          } else if (range.uid && Object.keys(range).length === 1) {
            range = range.uid;
            options.uid = true;
          } else {
            options.uid = true;
            range = await this.run("SEARCH", range, options);
            if (range && range.length) {
              range = packMessageRange(range);
            }
          }
        }
        if (Array.isArray(range)) {
          range = range.join(",");
        }
        if (!range) {
          return false;
        }
        return range;
      }
      autoidle() {
        clearTimeout(this.idleStartTimer);
        if (this.options.disableAutoIdle || this.state !== this.states.SELECTED) {
          return;
        }
        this.idleStartTimer = setTimeout(() => {
          this.idle().catch((err) => this.log.warn({ err, cid: this.id }));
        }, 15 * 1e3);
      }
      // PUBLIC API METHODS
      /**
       * Initiates a connection against IMAP server. Throws if anything goes wrong. This is something you have to call before you can run any IMAP commands
       *
       * @returns {Promise<void>}
       * @throws Will throw an error if connection or authentication fails
       * @example
       * let client = new ImapFlow({...});
       * await client.connect();
       */
      async connect() {
        if (this._connectCalled) {
          throw new Error("Can not re-use ImapFlow instance");
        }
        this._connectCalled = true;
        let connector = this.secureConnection ? tls : net;
        let opts = Object.assign(
          {
            host: this.host,
            servername: this.servername,
            port: this.port
          },
          this.options.tls || {}
        );
        this.untaggedHandlers.OK = (...args) => this.initialOK(...args);
        this.untaggedHandlers.BYE = (...args) => this.serverBye(...args);
        this.untaggedHandlers.PREAUTH = (...args) => this.initialPREAUTH(...args);
        this.untaggedHandlers.CAPABILITY = (...args) => this.untaggedCapability(...args);
        this.sectionHandlers.CAPABILITY = (...args) => this.sectionCapability(...args);
        this.untaggedHandlers.EXISTS = (...args) => this.untaggedExists(...args);
        this.untaggedHandlers.EXPUNGE = (...args) => this.untaggedExpunge(...args);
        this.untaggedHandlers.FETCH = (untagged) => this.untaggedFetch(untagged);
        this.untaggedHandlers.VANISHED = (untagged) => this.untaggedVanished(untagged);
        let socket = false;
        if (this.options.proxy) {
          try {
            socket = await proxyConnection(this.log, this.options.proxy, this.host, this.port);
            if (!socket) {
              throw new Error("Failed to setup proxy connection");
            }
          } catch (err) {
            let error = new Error("Failed to setup proxy connection");
            error.code = err.code || "ProxyError";
            error._err = err;
            this.log.error({ error, cid: this.id });
            throw error;
          }
        }
        await new Promise((resolve, reject) => {
          this.connectTimeout = setTimeout(() => {
            let err = new Error("Failed to establish connection in required time");
            err.code = "CONNECT_TIMEOUT";
            err.details = {
              connectionTimeout: this.options.connectionTimeout || CONNECT_TIMEOUT
            };
            this.log.error({ err, cid: this.id });
            this.closeAfter();
            reject(err);
          }, this.options.connectionTimeout || CONNECT_TIMEOUT);
          let onConnect = () => {
            try {
              clearTimeout(this.connectTimeout);
              this.socket.setKeepAlive(true, 5 * 1e3);
              this.socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
              this.greetingTimeout = setTimeout(() => {
                let err = new Error(
                  `Failed to receive greeting from server in required time${!this.secureConnection ? ". Maybe should use TLS?" : ""}`
                );
                err.code = "GREETING_TIMEOUT";
                err.details = {
                  greetingTimeout: this.options.greetingTimeout || GREETING_TIMEOUT
                };
                this.log.error({ err, cid: this.id });
                this.closeAfter();
                reject(err);
              }, this.options.greetingTimeout || GREETING_TIMEOUT);
              this.tls = typeof this.socket.getCipher === "function" ? this.socket.getCipher() : false;
              let logInfo = {
                src: "connection",
                msg: `Established ${this.tls ? "secure " : ""}TCP connection`,
                cid: this.id,
                secure: !!this.tls,
                host: this.host,
                servername: this.servername,
                port: this.socket.remotePort,
                address: this.socket.remoteAddress,
                localAddress: this.socket.localAddress,
                localPort: this.socket.localPort
              };
              if (this.tls) {
                logInfo.authorized = this.tls.authorized = this.socket.authorized;
                logInfo.algo = this.tls.standardName || this.tls.name;
                logInfo.version = this.tls.version;
              }
              this.log.info(logInfo);
              this.setSocketHandlers();
              this.socket.pipe(this.streamer);
              this.initialResolve = resolve;
              this.initialReject = reject;
            } catch (ex) {
              reject(ex);
            }
          };
          if (socket) {
            if (this.secureConnection) {
              opts.socket = socket;
              this.socket = connector.connect(opts, onConnect);
            } else {
              this.socket = socket;
              setImmediate(onConnect);
            }
          } else {
            this.socket = connector.connect(opts, onConnect);
          }
          this.writeSocket = this.socket;
          this.socket.on("error", (err) => {
            clearTimeout(this.connectTimeout);
            clearTimeout(this.greetingTimeout);
            this.closeAfter();
            this.log.error({ err, cid: this.id });
            reject(err);
          });
          this.setEventHandlers();
        });
      }
      /**
       * Graceful connection close by sending logout command to server. TCP connection is closed once command is finished.
       *
       * @return {Promise<void>}
       * @example
       * let client = new ImapFlow({...});
       * await client.connect();
       * ...
       * await client.logout();
       */
      async logout() {
        return await this.run("LOGOUT");
      }
      /**
       * Close the TCP connection.
       * Unlike `close()`, return immediately from this function, allowing the
       * caller function to proceed, and run `close()` function afterwards.
       */
      closeAfter() {
        setImmediate(() => this.close());
      }
      /**
       * Closes TCP connection without notifying the server.
       *
       * @example
       * let client = new ImapFlow({...});
       * await client.connect();
       * ...
       * client.close();
       */
      close() {
        try {
          clearTimeout(this.idleStartTimer);
          clearTimeout(this.upgradeTimeout);
          clearTimeout(this.connectTimeout);
          clearTimeout(this.greetingTimeout);
          this.usable = false;
          this.idling = false;
          if (typeof this.initialReject === "function" && !this.options.verifyOnly) {
            clearTimeout(this.greetingTimeout);
            let reject = this.initialReject;
            this.initialResolve = false;
            this.initialReject = false;
            let err = new Error("Unexpected close");
            err.code = `ClosedAfterConnect${this.secureConnection ? "TLS" : "Text"}`;
            setImmediate(() => reject(err));
          }
          if (typeof this.preCheck === "function") {
            this.preCheck().catch((err) => this.log.warn({ err, cid: this.id }));
          }
          if (this.currentRequest && this.requestTagMap.has(this.currentRequest.tag)) {
            let request = this.requestTagMap.get(this.currentRequest.tag);
            if (request) {
              this.requestTagMap.delete(request.tag);
              const error = new Error("Connection not available");
              error.code = "NoConnection";
              request.reject(error);
            }
            this.currentRequest = false;
          }
          while (this.requestQueue.length) {
            let req = this.requestQueue.shift();
            if (req && this.requestTagMap.has(req.tag)) {
              let request = this.requestTagMap.get(req.tag);
              if (request) {
                this.requestTagMap.delete(request.tag);
                const error = new Error("Connection not available");
                error.code = "NoConnection";
                request.reject(error);
              }
            }
          }
          if (this._inflate) {
            try {
              this._inflate.unpipe();
              this._inflate.destroy();
              this._inflate = null;
            } catch (err) {
              this.log.error({ err, info: "Failed to destroy inflate stream", cid: this.id });
            }
          }
          if (this._deflate) {
            try {
              this._deflate.unpipe();
              this._deflate.destroy();
              this._deflate = null;
            } catch (err) {
              this.log.error({ err, info: "Failed to destroy deflate stream", cid: this.id });
            }
          }
          this.state = this.states.LOGOUT;
          if (this.isClosed) {
            return;
          }
          if (this.socket && !this.socket.destroyed && this.writeSocket !== this.socket) {
            try {
              this.socket.destroy();
            } catch (err) {
              this.log.error({ err, cid: this.id });
            }
          }
          this.isClosed = true;
          if (this.writeSocket && !this.writeSocket.destroyed) {
            try {
              this.writeSocket.destroy();
            } catch (err) {
              this.log.error({ err, cid: this.id });
            }
          }
          if (this.socket && !this.socket.destroyed && this.writeSocket !== this.socket) {
            try {
              this.socket.destroy();
            } catch (err) {
              this.log.error({ err, cid: this.id });
            }
          }
          this.log.trace({ msg: "Connection closed", cid: this.id });
          this.emit("close");
        } catch (ex) {
          this.log.error(ex);
        }
      }
      /**
       * @typedef {Object} QuotaResponse
       * @global
       * @property {String} path=INBOX mailbox path this quota applies to
       * @property {Object} [storage] Storage quota if provided by server
       * @property {Number} [storage.used] used storage in bytes
       * @property {Number} [storage.limit] total storage available
       * @property {Object} [messages] Message count quota if provided by server
       * @property {Number} [messages.used] stored messages
       * @property {Number} [messages.limit] maximum messages allowed
       */
      /**
       * Returns current quota
       *
       * @param {String} [path] Optional mailbox path if you want to check quota for specific folder
       * @returns {Promise<QuotaResponse|Boolean>} Quota information or `false` if QUTOA extension is not supported or requested path does not exist
       *
       * @example
       * let quota = await client.getQuota();
       * console.log(quota.storage.used, quota.storage.available)
       */
      async getQuota(path) {
        path = path || "INBOX";
        return await this.run("QUOTA", path);
      }
      /**
       * @typedef {Object} ListResponse
       * @global
       * @property {String} path mailbox path (unicode string)
       * @property {String} pathAsListed mailbox path as listed in the LIST/LSUB response
       * @property {String} name mailbox name (last part of path after delimiter)
       * @property {String} delimiter mailbox path delimiter, usually "." or "/"
       * @property {String[]} parent An array of parent folder names. All names are in unicode
       * @property {String} parentPath Same as `parent`, but as a complete string path (unicode string)
       * @property {Set<string>} flags a set of flags for this mailbox
       * @property {String} specialUse one of special-use flags (if applicable): "\All", "\Archive", "\Drafts", "\Flagged", "\Junk", "\Sent", "\Trash". Additionally INBOX has non-standard "\Inbox" flag set
       * @property {Boolean} listed `true` if mailbox was found from the output of LIST command
       * @property {Boolean} subscribed `true` if mailbox was found from the output of LSUB command
       * @property {StatusObject} [status] If `statusQuery` was used, then this value includes the status response
       */
      /**
       * @typedef {Object} ListOptions
       * @global
       * @property {Object} [statusQuery] request status items for every listed entry
       * @property {Boolean} [statusQuery.messages] if `true` request count of messages
       * @property {Boolean} [statusQuery.recent] if `true` request count of messages with \\Recent tag
       * @property {Boolean} [statusQuery.uidNext] if `true` request predicted next UID
       * @property {Boolean} [statusQuery.uidValidity] if `true` request mailbox `UIDVALIDITY` value
       * @property {Boolean} [statusQuery.unseen] if `true` request count of unseen messages
       * @property {Boolean} [statusQuery.highestModseq] if `true` request last known modseq value
       * @property {Object} [specialUseHints] set specific paths as special use folders, this would override special use flags provided from the server
       * @property {String} [specialUseHints.sent] Path to "Sent Mail" folder
       * @property {String} [specialUseHints.trash] Path to "Trash" folder
       * @property {String} [specialUseHints.junk] Path to "Junk Mail" folder
       * @property {String} [specialUseHints.drafts] Path to "Drafts" folder
       */
      /**
       * Lists available mailboxes as an Array
       *
       * @param {ListOptions} [options] defines additional listing options
       * @returns {Promise<ListResponse[]>} An array of ListResponse objects
       *
       * @example
       * let list = await client.list();
       * list.forEach(mailbox=>console.log(mailbox.path));
       */
      async list(options) {
        options = options || {};
        let folders = await this.run("LIST", "", "*", options);
        this.folders = new Map(folders.map((folder) => [folder.path, folder]));
        return folders;
      }
      /**
       * @typedef {Object} ListTreeResponse
       * @global
       * @property {Boolean} root If `true` then this is root node without any additional properties besides *folders*
       * @property {String} path mailbox path
       * @property {String} name mailbox name (last part of path after delimiter)
       * @property {String} delimiter mailbox path delimiter, usually "." or "/"
       * @property {String[]} flags list of flags for this mailbox
       * @property {String} specialUse one of special-use flags (if applicable): "\All", "\Archive", "\Drafts", "\Flagged", "\Junk", "\Sent", "\Trash". Additionally INBOX has non-standard "\Inbox" flag set
       * @property {Boolean} listed `true` if mailbox was found from the output of LIST command
       * @property {Boolean} subscribed `true` if mailbox was found from the output of LSUB command
       * @property {Boolean} disabled If `true` then this mailbox can not be selected in the UI
       * @property {ListTreeResponse[]} folders An array of subfolders
       */
      /**
       * Lists available mailboxes as a tree structured object
       *
       * @param {ListOptions} [options] defines additional listing options
       * @returns {Promise<ListTreeResponse>} Tree structured object
       *
       * @example
       * let tree = await client.listTree();
       * tree.folders.forEach(mailbox=>console.log(mailbox.path));
       */
      async listTree(options) {
        options = options || {};
        let folders = await this.run("LIST", "", "*", options);
        this.folders = new Map(folders.map((folder) => [folder.path, folder]));
        return getFolderTree(folders);
      }
      /**
       * Performs a no-op call against server
       * @returns {Promise<void>}
       */
      async noop() {
        await this.run("NOOP");
      }
      /**
       * @typedef {Object} MailboxCreateResponse
       * @global
       * @property {String} path full mailbox path
       * @property {String} [mailboxId] unique mailbox ID if server supports `OBJECTID` extension (currently Yahoo and some others)
       * @property {Boolean} created If `true` then mailbox was created otherwise it already existed
       */
      /**
       * Creates a new mailbox folder and sets up subscription for the created mailbox. Throws on error.
       *
       * @param {string|array} path Full mailbox path. Unicode is allowed. If value is an array then it is joined using current delimiter symbols. Namespace prefix is added automatically if required.
       * @returns {Promise<MailboxCreateResponse>} Mailbox info
       * @throws Will throw an error if mailbox can not be created
       *
       * @example
       * let info = await client.mailboxCreate(['parent', 'child']);
       * console.log(info.path);
       * // "INBOX.parent.child" // assumes "INBOX." as namespace prefix and "." as delimiter
       */
      async mailboxCreate(path) {
        return await this.run("CREATE", path);
      }
      /**
       * @typedef {Object} MailboxRenameResponse
       * @global
       * @property {String} path full mailbox path that was renamed
       * @property {String} newPath new full mailbox path
       */
      /**
       * Renames a mailbox. Throws on error.
       *
       * @param {string|array} path  Path for the mailbox to rename. Unicode is allowed. If value is an array then it is joined using current delimiter symbols. Namespace prefix is added automatically if required.
       * @param {string|array} newPath New path for the mailbox
       * @returns {Promise<MailboxRenameResponse>} Mailbox info
       * @throws Will throw an error if mailbox does not exist or can not be renamed
       *
       * @example
       * let info = await client.mailboxRename('parent.child', 'Important stuff ');
       * console.log(info.newPath);
       * // "INBOX.Important stuff " // assumes "INBOX." as namespace prefix
       */
      async mailboxRename(path, newPath) {
        return await this.run("RENAME", path, newPath);
      }
      /**
       * @typedef {Object} MailboxDeleteResponse
       * @global
       * @property {String} path full mailbox path that was deleted
       */
      /**
       * Deletes a mailbox. Throws on error.
       *
       * @param {string|array} path Path for the mailbox to delete. Unicode is allowed. If value is an array then it is joined using current delimiter symbols. Namespace prefix is added automatically if required.
       * @returns {Promise<MailboxDeleteResponse>} Mailbox info
       * @throws Will throw an error if mailbox does not exist or can not be deleted
       *
       * @example
       * let info = await client.mailboxDelete('Important stuff ');
       * console.log(info.path);
       * // "INBOX.Important stuff " // assumes "INBOX." as namespace prefix
       */
      async mailboxDelete(path) {
        return await this.run("DELETE", path);
      }
      /**
       * Subscribes to a mailbox
       *
       * @param {string|array} path Path for the mailbox to subscribe to. Unicode is allowed. If value is an array then it is joined using current delimiter symbols. Namespace prefix is added automatically if required.
       * @returns {Promise<Boolean>} `true` if subscription operation succeeded, `false` otherwise
       *
       * @example
       * await client.mailboxSubscribe('Important stuff ');
       */
      async mailboxSubscribe(path) {
        return await this.run("SUBSCRIBE", path);
      }
      /**
       * Unsubscribes from a mailbox
       *
       * @param {string|array} path **Path for the mailbox** to unsubscribe from. Unicode is allowed. If value is an array then it is joined using current delimiter symbols. Namespace prefix is added automatically if required.
       * @returns {Promise<Boolean>} `true` if unsubscription operation succeeded, `false` otherwise
       *
       * @example
       * await client.mailboxUnsubscribe('Important stuff ');
       */
      async mailboxUnsubscribe(path) {
        return await this.run("UNSUBSCRIBE", path);
      }
      /**
       * Opens a mailbox to access messages. You can perform message operations only against an opened mailbox.
       * Using {@link module:imapflow~ImapFlow#getMailboxLock|getMailboxLock()} instead of `mailboxOpen()` is preferred. Both do the same thing
       * but next `getMailboxLock()` call is not executed until previous one is released.
       *
       * @param {string|array} path **Path for the mailbox** to open
       * @param {Object} [options] optional options
       * @param {Boolean} [options.readOnly=false] If `true` then opens mailbox in read-only mode. You can still try to perform write operations but these would probably fail.
       * @returns {Promise<MailboxObject>} Mailbox info
       * @throws Will throw an error if mailbox does not exist or can not be opened
       *
       * @example
       * let mailbox = await client.mailboxOpen('Important stuff ');
       * console.log(mailbox.exists);
       * // 125
       */
      async mailboxOpen(path, options) {
        return await this.run("SELECT", path, options);
      }
      /**
       * Closes a previously opened mailbox
       *
       * @returns {Promise<Boolean>} Did the operation succeed or not
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * await client.mailboxClose();
       */
      async mailboxClose() {
        return await this.run("CLOSE");
      }
      /**
       * @typedef {Object} StatusObject
       * @global
       * @property {String} path full mailbox path that was checked
       * @property {Number} [messages] Count of messages
       * @property {Number} [recent] Count of messages with \\Recent tag
       * @property {Number} [uidNext] Predicted next UID
       * @property {BigInt} [uidValidity] Mailbox `UIDVALIDITY` value
       * @property {Number} [unseen] Count of unseen messages
       * @property {BigInt} [highestModseq] Last known modseq value (if CONDSTORE extension is enabled)
       */
      /**
       * Requests the status of the indicated mailbox. Only requested status values will be returned.
       *
       * @param {String} path mailbox path to check for (unicode string)
       * @param {Object} query defines requested status items
       * @param {Boolean} query.messages if `true` request count of messages
       * @param {Boolean} query.recent if `true` request count of messages with \\Recent tag
       * @param {Boolean} query.uidNext if `true` request predicted next UID
       * @param {Boolean} query.uidValidity if `true` request mailbox `UIDVALIDITY` value
       * @param {Boolean} query.unseen if `true` request count of unseen messages
       * @param {Boolean} query.highestModseq if `true` request last known modseq value
       * @returns {Promise<StatusObject>} status of the indicated mailbox
       *
       * @example
       * let status = await client.status('INBOX', {unseen: true});
       * console.log(status.unseen);
       * // 123
       */
      async status(path, query) {
        return await this.run("STATUS", path, query);
      }
      /**
       * Starts listening for new or deleted messages from the currently opened mailbox. Only required if {@link ImapFlow#disableAutoIdle} is set to `true`
       * otherwise IDLE is started by default on connection inactivity. NB! If `idle()` is called manually then it does not
       * return until IDLE is finished which means you would have to call some other command out of scope.
       *
       * @returns {Promise<Boolean>} Did the operation succeed or not
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       *
       * await client.idle();
       */
      async idle() {
        if (!this.idling) {
          return await this.run("IDLE", this.maxIdleTime);
        }
      }
      /**
       * Sequence range string. Separate different values with commas, number ranges with colons and use \\* as the placeholder for the newest message in mailbox
       * @typedef {String} SequenceString
       * @global
       * @example
       * "1:*" // for all messages
       * "1,2,3" // for messages 1, 2 and 3
       * "1,2,4:6" // for messages 1,2,4,5,6
       * "*" // for the newest message
       */
      /**
       * IMAP search query options. By default all conditions must match. In case of `or` query term at least one condition must match.
       * @typedef {Object} SearchObject
       * @global
       * @property {SequenceString} [seq] message ordering sequence range
       * @property {Boolean} [answered] Messages with (value is `true`) or without (value is `false`) \\Answered flag
       * @property {Boolean} [deleted] Messages with (value is `true`) or without (value is `false`) \\Deleted flag
       * @property {Boolean} [draft] Messages with (value is `true`) or without (value is `false`) \\Draft flag
       * @property {Boolean} [flagged] Messages with (value is `true`) or without (value is `false`) \\Flagged flag
       * @property {Boolean} [seen] Messages with (value is `true`) or without (value is `false`) \\Seen flag
       * @property {Boolean} [all] If `true` matches all messages
       * @property {Boolean} [new] If `true` matches messages that have the \\Recent flag set but not the \\Seen flag
       * @property {Boolean} [old] If `true` matches messages that do not have the \\Recent flag set
       * @property {Boolean} [recent] If `true` matches messages that have the \\Recent flag set
       * @property {String} [from] Matches From: address field
       * @property {String} [to] Matches To: address field
       * @property {String} [cc] Matches Cc: address field
       * @property {String} [bcc] Matches Bcc: address field
       * @property {String} [body] Matches message body
       * @property {String} [subject] Matches message subject
       * @property {Number} [larger] Matches messages larger than value
       * @property {Number} [smaller] Matches messages smaller than value
       * @property {SequenceString} [uid] UID sequence range
       * @property {BigInt} [modseq] Matches messages with modseq higher than value
       * @property {String} [emailId] unique email ID. Only used if server supports `OBJECTID` or `X-GM-EXT-1` extensions
       * @property {String} [threadId] unique thread ID. Only used if server supports `OBJECTID` or `X-GM-EXT-1` extensions
       * @property {Date|string} [before] Matches messages received before date
       * @property {Date|string} [on] Matches messages received on date (ignores time)
       * @property {Date|string} [since] Matches messages received after date
       * @property {Date|string} [sentBefore] Matches messages sent before date
       * @property {Date|string} [sentOn] Matches messages sent on date (ignores time)
       * @property {Date|string} [sentSince] Matches messages sent after date
       * @property {String} [keyword] Matches messages that have the custom flag set
       * @property {String} [unKeyword] Matches messages that do not have the custom flag set
       * @property {Object.<string, Boolean|String>} [header] Matches messages with header key set if value is `true` (**NB!** not supported by all servers) or messages where header partially matches a string value
       * @property {SearchObject} [not] A {@link SearchObject} object. It must not match.
       * @property {SearchObject[]} [or] An array of 2 or more {@link SearchObject} objects. At least one of these must match
       */
      /**
       * Sets flags for a message or message range
       *
       * @param {SequenceString | Number[] | SearchObject} range Range to filter the messages
       * @param {string[]} Array of flags to set. Only flags that are permitted to set are used, other flags are ignored
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID {@link SequenceString} instead of sequence numbers
       * @param {BigInt} [options.unchangedSince] If set then only messages with a lower or equal `modseq` value are updated. Ignored if server does not support `CONDSTORE` extension.
       * @param {Boolean} [options.useLabels=false] If true then update Gmail labels instead of message flags
       * @returns {Promise<Boolean>} Did the operation succeed or not
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * // mark all unseen messages as seen (and remove other flags)
       * await client.messageFlagsSet({seen: false}, ['\Seen]);
       */
      async messageFlagsSet(range, flags, options) {
        options = options || {};
        range = await this.resolveRange(range, options);
        if (!range) {
          return false;
        }
        let queryOpts = Object.assign(
          {
            operation: "set"
          },
          options
        );
        return await this.run("STORE", range, flags, queryOpts);
      }
      /**
       * Adds flags for a message or message range
       *
       * @param {SequenceString | Number[] | SearchObject} range Range to filter the messages
       * @param {string[]} Array of flags to set. Only flags that are permitted to set are used, other flags are ignored
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID {@link SequenceString} instead of sequence numbers
       * @param {BigInt} [options.unchangedSince] If set then only messages with a lower or equal `modseq` value are updated. Ignored if server does not support `CONDSTORE` extension.
       * @param {Boolean} [options.useLabels=false] If true then update Gmail labels instead of message flags
       * @returns {Promise<Boolean>} Did the operation succeed or not
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * // mark all unseen messages as seen (and keep other flags as is)
       * await client.messageFlagsAdd({seen: false}, ['\Seen]);
       */
      async messageFlagsAdd(range, flags, options) {
        options = options || {};
        range = await this.resolveRange(range, options);
        if (!range) {
          return false;
        }
        let queryOpts = Object.assign(
          {
            operation: "add"
          },
          options
        );
        return await this.run("STORE", range, flags, queryOpts);
      }
      /**
       * Remove specific flags from a message or message range
       *
       * @param {SequenceString | Number[] | SearchObject} range Range to filter the messages
       * @param {string[]} Array of flags to remove. Only flags that are permitted to set are used, other flags are ignored
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID {@link SequenceString} instead of sequence numbers
       * @param {BigInt} [options.unchangedSince] If set then only messages with a lower or equal `modseq` value are updated. Ignored if server does not support `CONDSTORE` extension.
       * @param {Boolean} [options.useLabels=false] If true then update Gmail labels instead of message flags
       * @returns {Promise<Boolean>} Did the operation succeed or not
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * // mark all seen messages as unseen by removing \\Seen flag
       * await client.messageFlagsRemove({seen: true}, ['\Seen]);
       */
      async messageFlagsRemove(range, flags, options) {
        options = options || {};
        range = await this.resolveRange(range, options);
        if (!range) {
          return false;
        }
        let queryOpts = Object.assign(
          {
            operation: "remove"
          },
          options
        );
        return await this.run("STORE", range, flags, queryOpts);
      }
      /**
       * Sets a colored flag for an email. Only supported by mail clients like Apple Mail
       *
       * @param {SequenceString | Number[] | SearchObject} range Range to filter the messages
       * @param {string} The color to set. One of 'red', 'orange', 'yellow', 'green', 'blue', 'purple', and 'grey'
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID {@link SequenceString} instead of sequence numbers
       * @param {BigInt} [options.unchangedSince] If set then only messages with a lower or equal `modseq` value are updated. Ignored if server does not support `CONDSTORE` extension.
       * @returns {Promise<Boolean>} Did the operation succeed or not
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * // add a purple flag for all emails
       * await client.setFlagColor('1:*', 'Purple');
       */
      async setFlagColor(range, color, options) {
        options = options || {};
        range = await this.resolveRange(range, options);
        if (!range) {
          return false;
        }
        let flagChanges = getColorFlags(color);
        if (!flagChanges) {
          return false;
        }
        let addResults;
        let removeResults;
        if (flagChanges.add && flagChanges.add.length) {
          let queryOpts = Object.assign(
            {
              operation: "add"
            },
            options,
            {
              useLabels: false,
              // override if set
              // prevent triggering a premature Flags change notification
              silent: flagChanges.remove && flagChanges.remove.length
            }
          );
          addResults = await this.run("STORE", range, flagChanges.add, queryOpts);
        }
        if (flagChanges.remove && flagChanges.remove.length) {
          let queryOpts = Object.assign(
            {
              operation: "remove"
            },
            options,
            { useLabels: false }
            // override if set
          );
          removeResults = await this.run("STORE", range, flagChanges.remove, queryOpts);
        }
        return addResults || removeResults || false;
      }
      /**
       * Delete messages from the currently opened mailbox. Method does not indicate info about deleted messages,
       * instead you should be using {@link ImapFlow#expunge} event for this
       *
       * @param {SequenceString | Number[] | SearchObject} range Range to filter the messages
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID {@link SequenceString} instead of sequence numbers
       * @returns {Promise<Boolean>} Did the operation succeed or not
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * // delete all seen messages
       * await client.messageDelete({seen: true});
       */
      async messageDelete(range, options) {
        options = options || {};
        range = await this.resolveRange(range, options);
        if (!range) {
          return false;
        }
        return await this.run("EXPUNGE", range, options);
      }
      /**
       * @typedef {Object} AppendResponseObject
       * @global
       * @property {String} destination full mailbox path where the message was uploaded to
       * @property {BigInt} [uidValidity] mailbox `UIDVALIDITY` if server has `UIDPLUS` extension enabled
       * @property {Number} [uid] UID of the uploaded message if server has `UIDPLUS` extension enabled
       * @property {Number} [seq] sequence number of the uploaded message if path is currently selected mailbox
       */
      /**
       * Appends a new message to a mailbox
       *
       * @param {String} path Mailbox path to upload the message to (unicode string)
       * @param {string|Buffer} content RFC822 formatted email message
       * @param {string[]} [flags] an array of flags to be set for the uploaded message
       * @param {Date|string} [idate=now] internal date to be set for the message
       * @returns {Promise<AppendResponseObject>} info about uploaded message
       *
       * @example
       * await client.append('INBOX', rawMessageBuffer, ['\\Seen'], new Date(2000, 1, 1));
       */
      async append(path, content, flags, idate) {
        let response = await this.run("APPEND", path, content, flags, idate);
        if (!response) {
          return false;
        }
        return response;
      }
      /**
       * @typedef {Object} CopyResponseObject
       * @global
       * @property {String} path path of source mailbox
       * @property {String} destination path of destination mailbox
       * @property {BigInt} [uidValidity] destination mailbox `UIDVALIDITY` if server has `UIDPLUS` extension enabled
       * @property {Map<number, number>} [uidMap] Map of UID values (if server has `UIDPLUS` extension enabled) where key is UID in source mailbox and value is the UID for the same message in destination mailbox
       */
      /**
       * Copies messages from current mailbox to destination mailbox
       *
       * @param {SequenceString | Number[] | SearchObject} range Range of messages to copy
       * @param {String} destination Mailbox path to copy the messages to
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID {@link SequenceString} instead of sequence numbers
       * @returns {Promise<CopyResponseObject>} info about copies messages
       *
       * @example
       * await client.mailboxOpen('INBOX');
       * // copy all messages to a mailbox called "Backup" (must exist)
       * let result = await client.messageCopy('1:*', 'Backup');
       * console.log('Copied %s messages', result.uidMap.size);
       */
      async messageCopy(range, destination, options) {
        options = options || {};
        range = await this.resolveRange(range, options);
        if (!range) {
          return false;
        }
        return await this.run("COPY", range, destination, options);
      }
      /**
       * Moves messages from current mailbox to destination mailbox
       *
       * @param {SequenceString | Number[] | SearchObject} range Range of messages to move
       * @param {String} destination Mailbox path to move the messages to
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID {@link SequenceString} instead of sequence numbers
       * @returns {Promise<CopyResponseObject>} info about moved messages
       *
       * @example
       * await client.mailboxOpen('INBOX');
       * // move all messages to a mailbox called "Trash" (must exist)
       * let result = await client.messageMove('1:*', 'Trash');
       * console.log('Moved %s messages', result.uidMap.size);
       */
      async messageMove(range, destination, options) {
        options = options || {};
        range = await this.resolveRange(range, options);
        if (!range) {
          return false;
        }
        return await this.run("MOVE", range, destination, options);
      }
      /**
       * Search messages from the currently opened mailbox
       *
       * @param {SearchObject} query Query to filter the messages
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then returns UID numbers instead of sequence numbers
       * @returns {Promise<Number[]>} An array of sequence or UID numbers
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * // find all unseen messages
       * let list = await client.search({seen: false});
       * // use OR modifier (array of 2 or more search queries)
       * let list = await client.search({
       *   seen: false,
       *   or: [
       *     {flagged: true},
       *     {from: 'andris'},
       *     {subject: 'test'}
       *   ]});
       */
      async search(query, options) {
        if (!this.mailbox) {
          return;
        }
        let response = await this.run("SEARCH", query, options);
        if (!response) {
          return false;
        }
        return response;
      }
      /**
       * @typedef {Object} FetchQueryObject
       * @global
       * @property {Boolean} [uid] if `true` then include UID in the response
       * @property {Boolean} [flags] if `true` then include flags Set in the response. Also adds `flagColor` to the response if the message is flagged.
       * @property {Boolean} [bodyStructure] if `true` then include parsed BODYSTRUCTURE object in the response
       * @property {Boolean} [envelope] if `true` then include parsed ENVELOPE object in the response
       * @property {Boolean} [internalDate] if `true` then include internal date value in the response
       * @property {Boolean} [size] if `true` then include message size in the response
       * @property {boolean | Object} [source] if `true` then include full message in the response
       * @property {Number} [source.start] include full message in the response starting from *start* byte
       * @property {Number} [source.maxLength] include full message in the response, up to *maxLength* bytes
       * @property {String} [threadId] if `true` then include thread ID in the response (only if server supports either `OBJECTID` or `X-GM-EXT-1` extensions)
       * @property {Boolean} [labels] if `true` then include GMail labels in the response (only if server supports `X-GM-EXT-1` extension)
       * @property {boolean | string[]} [headers] if `true` then includes full headers of the message in the response. If the value is an array of header keys then includes only headers listed in the array
       * @property {string[]} [bodyParts] An array of BODYPART identifiers to include in the response
       */
      /**
       * Parsed email address entry
       *
       * @typedef {Object} MessageAddressObject
       * @global
       * @property {String} [name] name of the address object (unicode)
       * @property {String} [address] email address
       */
      /**
       * Parsed IMAP ENVELOPE object
       *
       * @typedef {Object} MessageEnvelopeObject
       * @global
       * @property {Date} [date] header date
       * @property {String} [subject] message subject (unicode)
       * @property {String} [messageId] Message ID of the message
       * @property {String} [inReplyTo] Message ID from In-Reply-To header
       * @property {MessageAddressObject[]} [from] Array of addresses from the From: header
       * @property {MessageAddressObject[]} [sender] Array of addresses from the Sender: header
       * @property {MessageAddressObject[]} [replyTo] Array of addresses from the Reply-To: header
       * @property {MessageAddressObject[]} [to] Array of addresses from the To: header
       * @property {MessageAddressObject[]} [cc] Array of addresses from the Cc: header
       * @property {MessageAddressObject[]} [bcc] Array of addresses from the Bcc: header
       */
      /**
       * Parsed IMAP BODYSTRUCTURE object
       *
       * @typedef {Object} MessageStructureObject
       * @global
       * @property {String} part Body part number. This value can be used to later fetch the contents of this part of the message
       * @property {String} type Content-Type of this node
       * @property {Object} [parameters] Additional parameters for Content-Type, eg "charset"
       * @property {String} [id] Content-ID
       * @property {String} [encoding] Transfer encoding
       * @property {Number} [size] Expected size of the node
       * @property {MessageEnvelopeObject} [envelope] message envelope of embedded RFC822 message
       * @property {String} [disposition] Content disposition
       * @property {Object} [dispositionParameters] Additional parameters for Content-Disposition
       * @property {MessageStructureObject[]} childNodes An array of child nodes if this is a multipart node. Not present for normal nodes
       */
      /**
       * Fetched message data
       *
       * @typedef {Object} FetchMessageObject
       * @global
       * @property {Number} seq message sequence number. Always included in the response
       * @property {Number} uid message UID number. Always included in the response
       * @property {Buffer} [source] message source for the requested byte range
       * @property {BigInt} [modseq] message Modseq number. Always included if the server supports CONDSTORE extension
       * @property {String} [emailId] unique email ID. Always included if server supports `OBJECTID` or `X-GM-EXT-1` extensions
       * @property {String} [threadid] unique thread ID. Only present if server supports `OBJECTID` or `X-GM-EXT-1` extension
       * @property {Set<string>} [labels] a Set of labels. Only present if server supports `X-GM-EXT-1` extension
       * @property {Number} [size] message size
       * @property {Set<string>} [flags] a set of message flags
       * @property {String} [flagColor] flag color like "red", or "yellow". This value is derived from the `flags` Set and it uses the same color rules as Apple Mail
       * @property {MessageEnvelopeObject} [envelope] message envelope
       * @property {MessageStructureObject} [bodyStructure] message body structure
       * @property {Date} [internalDate] message internal date
       * @property {Map<string, Buffer>} [bodyParts] a Map of message body parts where key is requested part identifier and value is a Buffer
       * @property {Buffer} [headers] Requested header lines as Buffer
       */
      /**
       * Fetch messages from the currently opened mailbox
       *
       * @param {SequenceString | Number[] | SearchObject} range Range of messages to fetch
       * @param {FetchQueryObject} query Fetch query
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID numbers instead of sequence numbers for `range`
       * @param {BigInt} [options.changedSince] If set then only messages with a higher modseq value are returned. Ignored if server does not support `CONDSTORE` extension.
       * @param {Boolean} [options.binary=false] If `true` then requests a binary response if the server supports this
       * @yields {Promise<FetchMessageObject>} Message data object
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * // fetch UID for all messages in a mailbox
       * for await (let msg of client.fetch('1:*', {uid: true})){
       *     console.log(msg.uid);
       *     // NB! You can not run any IMAP commands in this loop
       *     // otherwise you will end up in a deadloop
       * }
       */
      async *fetch(range, query, options) {
        options = options || {};
        if (!this.mailbox) {
          return;
        }
        range = await this.resolveRange(range, options);
        if (!range) {
          return false;
        }
        let finished = false;
        let push = false;
        let rowQueue = [];
        let getNext = () => new Promise((resolve, reject) => {
          let check = () => {
            if (rowQueue.length) {
              let entry = rowQueue.shift();
              if (entry.err) {
                return reject(entry.err);
              } else {
                return resolve(entry.value);
              }
            }
            if (finished) {
              return resolve(null);
            }
            push = () => {
              push = false;
              check();
            };
          };
          check();
        });
        this.run("FETCH", range, query, {
          uid: !!options.uid,
          binary: options.binary,
          changedSince: options.changedSince,
          onUntaggedFetch: (untagged, next) => {
            rowQueue.push({
              value: {
                response: untagged,
                next
              }
            });
            if (typeof push === "function") {
              push();
            }
          }
        }).then(() => {
          finished = true;
          if (typeof push === "function") {
            push();
          }
        }).catch((err) => {
          rowQueue.push({ err });
          if (typeof push === "function") {
            push();
          }
        });
        let res;
        while (res = await getNext()) {
          if (this.isClosed || !this.socket || this.socket.destroyed) {
            let error = new Error("Connection closed");
            error.code = "EConnectionClosed";
            throw error;
          }
          if (res !== null) {
            yield res.response;
            res.next();
          }
        }
        if (!finished) {
          let error = new Error("FETCH did not finish");
          error.code = "ENotFinished";
          throw error;
        }
      }
      /**
       * Fetch messages from the currently opened mailbox.
       *
       * This method will fetch all messages before resolving the promise, unlike .fetch(), which
       * is an async generator. Do not use large ranges like 1:*, as this might exhaust all available
       * memory if the mailbox contains a large number of emails.
       * @param {SequenceString | Number[] | SearchObject} range Range of messages to fetch
       * @param {FetchQueryObject} query Fetch query
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID numbers instead of sequence numbers for `range`
       * @param {BigInt} [options.changedSince] If set then only messages with a higher modseq value are returned. Ignored if server does not support `CONDSTORE` extension.
       * @param {Boolean} [options.binary=false] If `true` then requests a binary response if the server supports this
       * @returns {Promise<FetchMessageObject[]>} Array of Message data object
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * // fetch UID for all messages in a mailbox
       * const messages = await client.fetchAll('1:*', {uid: true});
       * for (let msg of messages){
       *     console.log(msg.uid);
       * }
       */
      async fetchAll(range, query, options) {
        const results = [];
        const generator = this.fetch(range, query, options);
        for await (const message of generator) {
          results.push(message);
        }
        return results;
      }
      /**
       * Fetch a single message from the currently opened mailbox
       *
       * @param {SequenceString} seq Single UID or sequence number of the message to fetch for
       * @param {FetchQueryObject} query Fetch query
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID number instead of sequence number for `seq`
       * @param {Boolean} [options.binary=false] If `true` then requests a binary response if the server supports this
       * @returns {Promise<FetchMessageObject>} Message data object
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * // fetch UID for the last email in the selected mailbox
       * let lastMsg = await client.fetchOne('*', {uid: true})
       * console.log(lastMsg.uid);
       */
      async fetchOne(seq, query, options) {
        if (!this.mailbox) {
          return;
        }
        if (seq === "*") {
          if (!this.mailbox.exists) {
            return false;
          }
          seq = this.mailbox.exists.toString();
          options = Object.assign({}, options || {}, { uid: false });
        }
        let response = await this.run("FETCH", (seq || "").toString(), query, options);
        if (!response || !response.list || !response.list.length) {
          return false;
        }
        return response.list[0];
      }
      /**
       * @typedef {Object} DownloadObject
       * @global
       * @property {Object} meta content metadata
       * @property {number} meta.expectedSize The fetch response size
       * @property {String} meta.contentType Content-Type of the streamed file. If part was not set then this value is "message/rfc822"
       * @property {String} [meta.charset] Charset of the body part. Text parts are automatically converted to UTF-8, attachments are kept as is
       * @property {String} [meta.disposition] Content-Disposition of the streamed file
       * @property {String} [meta.filename] Filename of the streamed body part
       * @property {ReadableStream} content Streamed content
       */
      /**
       * Download either full rfc822 formatted message or a specific bodystructure part as a Stream.
       * Bodystructure parts are decoded so the resulting stream is a binary file. Text content
       * is automatically converted to UTF-8 charset.
       *
       * @param {SequenceString} range UID or sequence number for the message to fetch
       * @param {String} [part] If not set then downloads entire rfc822 formatted message, otherwise downloads specific bodystructure part
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID number instead of sequence number for `range`
       * @param {number} [options.maxBytes] If set then limits download size to specified bytes
       * @param {number} [options.chunkSize=65536] How large content parts to ask from the server
       * @returns {Promise<DownloadObject>} Download data object
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * // download body part nr '1.2' from latest message
       * let {meta, content} = await client.download('*', '1.2');
       * content.pipe(fs.createWriteStream(meta.filename));
       */
      async download(range, part, options) {
        if (!this.mailbox) {
          return {};
        }
        options = Object.assign(
          {
            chunkSize: 64 * 1024,
            maxBytes: Infinity
          },
          options || {}
        );
        let hasMore = true;
        let processed = 0;
        let chunkSize = Number(options.chunkSize) || 64 * 1024;
        let maxBytes = Number(options.maxBytes) || Infinity;
        let uid = false;
        if (part === "1") {
          let response2 = await this.fetchOne(range, { uid: true, bodyStructure: true }, options);
          if (!response2) {
            return { response: false, chunk: false };
          }
          if (!uid && response2.uid) {
            uid = response2.uid;
            range = uid;
            options.uid = true;
          }
          if (!response2.bodyStructure.childNodes) {
            part = "TEXT";
          }
        }
        let getNextPart = async (query) => {
          query = query || {};
          let mimeKey;
          if (!part) {
            query.source = {
              start: processed,
              maxLength: chunkSize
            };
          } else {
            part = part.toString().toLowerCase().trim();
            if (!query.bodyParts) {
              query.bodyParts = [];
            }
            if (query.size) {
              if (/^[\d.]+$/.test(part)) {
                mimeKey = part + ".mime";
                query.bodyParts.push(mimeKey);
              } else if (part === "text") {
                mimeKey = "header";
                query.bodyParts.push(mimeKey);
              }
            }
            query.bodyParts.push({
              key: part,
              start: processed,
              maxLength: chunkSize
            });
          }
          let response2 = await this.fetchOne(range, query, options);
          if (!response2) {
            return { response: false, chunk: false };
          }
          if (!uid && response2.uid) {
            uid = response2.uid;
            range = uid;
            options.uid = true;
          }
          let chunk2 = !part ? response2.source : response2.bodyParts && response2.bodyParts.get(part);
          if (!chunk2) {
            return {};
          }
          processed += chunk2.length;
          hasMore = chunk2.length >= chunkSize;
          let result = { chunk: chunk2 };
          if (query.size) {
            result.response = response2;
          }
          if (query.bodyParts) {
            if (mimeKey === "header") {
              result.mime = response2.headers;
            } else {
              result.mime = response2.bodyParts.get(mimeKey);
            }
          }
          return result;
        };
        let { response, chunk, mime } = await getNextPart({
          size: true,
          uid: true
        });
        if (!response || !chunk) {
          return {};
        }
        let meta = {
          expectedSize: response.size
        };
        if (!part) {
          meta.contentType = "message/rfc822";
        } else if (mime) {
          let headers = new Headers(mime);
          let contentType = libmime.parseHeaderValue(headers.getFirst("Content-Type"));
          let transferEncoding = libmime.parseHeaderValue(headers.getFirst("Content-Transfer-Encoding"));
          let disposition = libmime.parseHeaderValue(headers.getFirst("Content-Disposition"));
          if (contentType.value.toLowerCase().trim()) {
            meta.contentType = contentType.value.toLowerCase().trim();
          }
          if (contentType.params.charset) {
            meta.charset = contentType.params.charset.toLowerCase().trim();
          }
          if (transferEncoding.value) {
            meta.encoding = transferEncoding.value.replace(/\(.*\)/g, "").toLowerCase().trim();
          }
          if (disposition.value) {
            meta.disposition = disposition.value.toLowerCase().trim() || false;
            try {
              meta.disposition = libmime.decodeWords(meta.disposition);
            } catch {
            }
          }
          if (contentType.params.format && contentType.params.format.toLowerCase().trim() === "flowed") {
            meta.flowed = true;
            if (contentType.params.delsp && contentType.params.delsp.toLowerCase().trim() === "yes") {
              meta.delSp = true;
            }
          }
          let filename = disposition.params.filename || contentType.params.name || false;
          if (filename) {
            try {
              filename = libmime.decodeWords(filename);
            } catch {
            }
            meta.filename = filename;
          }
        }
        let stream;
        let output;
        let fetchAborted = false;
        switch (meta.encoding) {
          case "base64":
            output = stream = new libbase64.Decoder();
            break;
          case "quoted-printable":
            output = stream = new libqp.Decoder();
            break;
          default:
            output = stream = new PassThrough();
        }
        let isTextNode = ["text/html", "text/plain", "text/x-amp-html"].includes(meta.contentType) || part === "1" && !meta.contentType;
        if ((!meta.disposition || meta.disposition === "inline") && isTextNode) {
          if (meta.flowed) {
            let flowDecoder = new FlowedDecoder({
              delSp: meta.delSp
            });
            output.on("error", (err) => {
              flowDecoder.emit("error", err);
            });
            output = output.pipe(flowDecoder);
          }
          if (meta.charset && !["ascii", "usascii", "utf8"].includes(meta.charset.toLowerCase().replace(/[^a-z0-9]+/g, ""))) {
            try {
              let decoder = getDecoder(meta.charset);
              output.on("error", (err) => {
                decoder.emit("error", err);
              });
              output = output.pipe(decoder);
              meta.charset = "utf-8";
            } catch {
            }
          }
        }
        let limiter = new LimitedPassthrough({ maxBytes });
        output.on("error", (err) => {
          limiter.emit("error", err);
        });
        output = output.pipe(limiter);
        const cleanup = () => {
          fetchAborted = true;
          if (stream && !stream.destroyed) {
            stream.destroy();
          }
        };
        output.once("error", cleanup);
        output.once("close", cleanup);
        let writeChunk = (chunk2) => {
          if (limiter.limited || fetchAborted || stream.destroyed) {
            return true;
          }
          return stream.write(chunk2);
        };
        let fetchAllParts = async () => {
          while (hasMore && !limiter.limited && !fetchAborted) {
            let { chunk: chunk2 } = await getNextPart();
            if (!chunk2 || fetchAborted) {
              break;
            }
            if (writeChunk(chunk2) === false) {
              try {
                await new Promise((resolve, reject) => {
                  let resolved = false;
                  const finish = (err) => {
                    if (resolved) return;
                    resolved = true;
                    stream.removeAllListeners("drain");
                    stream.removeAllListeners("error");
                    stream.removeAllListeners("close");
                    if (err) {
                      reject(err);
                    } else {
                      resolve();
                    }
                  };
                  stream.once("drain", () => finish());
                  stream.once("error", (err) => finish(err));
                  stream.once("close", () => finish());
                });
              } catch (err) {
                if (!fetchAborted) {
                  throw err;
                }
              }
              if (fetchAborted) {
                break;
              }
            }
          }
        };
        setImmediate(() => {
          let writeResult;
          try {
            writeResult = writeChunk(chunk);
          } catch (err) {
            stream.emit("error", err);
            if (!fetchAborted && stream && !stream.destroyed) {
              stream.end();
            }
            return;
          }
          if (!writeResult) {
            stream.once("drain", () => {
              if (!fetchAborted) {
                fetchAllParts().catch((err) => {
                  if (!fetchAborted && stream && !stream.destroyed) {
                    stream.emit("error", err);
                  }
                }).finally(() => {
                  if (!fetchAborted && stream && !stream.destroyed) {
                    stream.end();
                  }
                });
              }
            });
          } else {
            fetchAllParts().catch((err) => {
              if (!fetchAborted && stream && !stream.destroyed) {
                stream.emit("error", err);
              }
            }).finally(() => {
              if (!fetchAborted && stream && !stream.destroyed) {
                stream.end();
              }
            });
          }
        });
        return {
          meta,
          content: output
        };
      }
      /**
       * Fetch multiple attachments as Buffer values
       *
       * @param {SequenceString} range UID or sequence number for the message to fetch
       * @param {String} parts A list of bodystructure parts
       * @param {Object} [options]
       * @param {Boolean} [options.uid] If `true` then uses UID number instead of sequence number for `range`
       * @returns {Promise<Object>} Download data object
       *
       * @example
       * let mailbox = await client.mailboxOpen('INBOX');
       * // download body parts '2', and '3' from all messages in the selected mailbox
       * let response = await client.downloadMany('*', ['2', '3']);
       * process.stdout.write(response[2].content)
       * process.stdout.write(response[3].content)
       */
      async downloadMany(range, parts, options) {
        if (!this.mailbox) {
          return {};
        }
        options = Object.assign(
          {
            chunkSize: 64 * 1024,
            maxBytes: Infinity
          },
          options || {}
        );
        let query = { bodyParts: [] };
        for (let part of parts) {
          query.bodyParts.push(part + ".mime");
          query.bodyParts.push(part);
        }
        let response = await this.fetchOne(range, query, options);
        if (!response || !response.bodyParts) {
          return { response: false };
        }
        let data = {};
        for (let [part, content] of response.bodyParts) {
          let keyParts = part.split(".mime");
          if (keyParts.length === 1) {
            let key = keyParts[0];
            if (!data[key]) {
              data[key] = { content };
            } else {
              data[key].content = content;
            }
          } else if (keyParts.length === 2) {
            let key = keyParts[0];
            if (!data[key]) {
              data[key] = {};
            }
            if (!data[key].meta) {
              data[key].meta = {};
            }
            let headers = new Headers(content);
            let contentType = libmime.parseHeaderValue(headers.getFirst("Content-Type"));
            let transferEncoding = libmime.parseHeaderValue(headers.getFirst("Content-Transfer-Encoding"));
            let disposition = libmime.parseHeaderValue(headers.getFirst("Content-Disposition"));
            if (contentType.value.toLowerCase().trim()) {
              data[key].meta.contentType = contentType.value.toLowerCase().trim();
            }
            if (contentType.params.charset) {
              data[key].meta.charset = contentType.params.charset.toLowerCase().trim();
            }
            if (transferEncoding.value) {
              data[key].meta.encoding = transferEncoding.value.replace(/\(.*\)/g, "").toLowerCase().trim();
            }
            if (disposition.value) {
              data[key].meta.disposition = disposition.value.toLowerCase().trim() || false;
              try {
                data[key].meta.disposition = libmime.decodeWords(data[key].meta.disposition);
              } catch {
              }
            }
            if (contentType.params.format && contentType.params.format.toLowerCase().trim() === "flowed") {
              data[key].meta.flowed = true;
              if (contentType.params.delsp && contentType.params.delsp.toLowerCase().trim() === "yes") {
                data[key].meta.delSp = true;
              }
            }
            let filename = disposition.params.filename || contentType.params.name || false;
            if (filename) {
              try {
                filename = libmime.decodeWords(filename);
              } catch {
              }
              data[key].meta.filename = filename;
            }
          }
        }
        for (let part of Object.keys(data)) {
          let meta = data[part].meta;
          switch (meta.encoding) {
            case "base64":
              data[part].content = data[part].content ? libbase64.decode(data[part].content.toString()) : null;
              break;
            case "quoted-printable":
              data[part].content = data[part].content ? libqp.decode(data[part].content.toString()) : null;
              break;
            default:
          }
        }
        return data;
      }
      async run(command, ...args) {
        command = command.toUpperCase();
        if (!this.commands.has(command)) {
          return false;
        }
        if (!this.socket || this.socket.destroyed) {
          const error = new Error("Connection not available");
          error.code = "NoConnection";
          throw error;
        }
        clearTimeout(this.idleStartTimer);
        if (typeof this.preCheck === "function") {
          await this.preCheck();
        }
        let handler = this.commands.get(command);
        let result = await handler(this, ...args);
        if (command !== "IDLE") {
          this.autoidle();
        }
        return result;
      }
      async processLocks() {
        var _a, _b;
        const wasProcessing = this.processingLock;
        if (wasProcessing) {
          this.log.trace({
            msg: "Mailbox locking queued",
            path: this.mailbox && this.mailbox.path,
            pending: this.locks.length,
            idling: this.idling,
            activeLock: this.currentLock ? {
              lockId: this.currentLock.lockId,
              ...((_a = this.currentLock.options) == null ? void 0 : _a.description) && { description: (_b = this.currentLock.options) == null ? void 0 : _b.description }
            } : null
          });
          return;
        }
        this.processingLock = true;
        try {
          let processedCount = 0;
          while (this.locks.length > 0) {
            if (!this.locks.length) {
              this.log.trace({
                msg: "Mailbox locking queue processed",
                idling: this.idling
              });
              return;
            }
            processedCount++;
            if (processedCount % 5 === 0) {
              await new Promise((resolve2) => setImmediate(resolve2));
            }
            const release = () => {
              if (this.currentLock) {
                this.log.trace({
                  msg: "Mailbox lock released",
                  lockId: this.currentLock.lockId,
                  path: this.mailbox && this.mailbox.path,
                  pending: this.locks.length,
                  idling: this.idling
                });
                this.currentLock = false;
              }
              setImmediate(() => {
                this.processLocks().catch((err) => this.log.error({ err, cid: this.id }));
              });
            };
            const lock = this.locks.shift();
            const { resolve, reject, path, options, lockId } = lock;
            if (!this.usable || !this.socket || this.socket.destroyed) {
              this.log.trace({ msg: "Failed to acquire mailbox lock", path, lockId, idling: this.idling });
              let error = new Error("Connection not available");
              error.code = "NoConnection";
              reject(error);
              continue;
            }
            if (this.mailbox && this.mailbox.path === path && !!this.mailbox.readOnly === !!options.readOnly) {
              this.log.trace({
                msg: "Mailbox lock acquired [existing]",
                path,
                lockId,
                idling: this.idling,
                ...options.description && { description: options.description }
              });
              this.currentLock = lock;
              resolve({ path, release });
              break;
            } else {
              try {
                await this.mailboxOpen(path, options);
                this.log.trace({
                  msg: "Mailbox lock acquired [selected]",
                  path,
                  lockId,
                  idling: this.idling,
                  ...options.description && { description: options.description }
                });
                this.currentLock = lock;
                resolve({ path, release });
                break;
              } catch (err) {
                if (err.responseStatus === "NO") {
                  try {
                    let folders = await this.run("LIST", "", path, { listOnly: true });
                    if (!folders || !folders.length) {
                      err.mailboxMissing = true;
                    }
                  } catch (E) {
                    this.log.trace({ msg: "Failed to verify failed mailbox", path, err: E });
                  }
                }
                this.log.trace({
                  msg: "Failed to acquire mailbox lock",
                  path,
                  lockId,
                  idling: this.idling,
                  ...options.description && { description: options.description },
                  err
                });
                reject(err);
              }
            }
          }
        } finally {
          this.processingLock = false;
          if (this.locks.length && !this.currentLock) {
            setImmediate(() => {
              this.processLocks().catch((err) => this.log.error({ err, cid: this.id }));
            });
          }
        }
      }
      /**
       * Opens a mailbox if not already open and returns a lock. Next call to `getMailboxLock()` is queued
       * until previous lock is released. This is suggested over {@link module:imapflow~ImapFlow#mailboxOpen|mailboxOpen()} as
       * `getMailboxLock()` gives you a weak transaction while `mailboxOpen()` has no guarantees whatsoever that another
       * mailbox is opened while you try to call multiple fetch or store commands.
       *
       * @param {string|array} path **Path for the mailbox** to open
       * @param {Object} [options] optional options
       * @param {Boolean} [options.readOnly=false] If `true` then opens mailbox in read-only mode. You can still try to perform write operations but these would probably fail.
       * @returns {Promise<MailboxLockObject>} Mailbox lock
       * @throws Will throw an error if mailbox does not exist or can not be opened
       *
       * @example
       * let lock = await client.getMailboxLock('INBOX');
       * try {
       *   // do something in the mailbox
       * } finally {
       *   // use finally{} to make sure lock is released even if exception occurs
       *   lock.release();
       * }
       */
      async getMailboxLock(path, options) {
        var _a, _b;
        options = options || {};
        path = normalizePath(this, path);
        let lockId = ++this.lockCounter;
        this.log.trace({
          msg: "Requesting lock",
          path,
          lockId,
          ...options.description && { description: options.description },
          activeLock: this.currentLock ? {
            lockId: this.currentLock.lockId,
            ...((_a = this.currentLock.options) == null ? void 0 : _a.description) && { description: (_b = this.currentLock.options) == null ? void 0 : _b.description }
          } : null
        });
        return await new Promise((resolve, reject) => {
          this.locks.push({ resolve, reject, path, options, lockId });
          this.processLocks().catch((err) => reject(err));
        });
      }
      getLogger() {
        let mainLogger = this.options.logger && typeof this.options.logger === "object" ? this.options.logger : logger.child({
          component: "imap-connection",
          cid: this.id
        });
        let synteticLogger = {};
        let levels = ["trace", "debug", "info", "warn", "error", "fatal"];
        for (let level of levels) {
          synteticLogger[level] = (...args) => {
            if (this.options.logger !== false) {
              if (logger)
                if (typeof mainLogger[level] !== "function") {
                  if (level === "fatal" || level === "error") {
                    console.log(JSON.stringify(...args));
                  }
                } else {
                  mainLogger[level](...args);
                }
            }
            if (this.emitLogs && args && args[0] && typeof args[0] === "object") {
              let logEntry = Object.assign({ level, t: Date.now(), cid: this.id, lo: ++this.lo }, args[0]);
              if (logEntry.err && typeof logEntry.err === "object") {
                let err = logEntry.err;
                logEntry.err = {
                  stack: err.stack
                };
                Object.keys(err).forEach((key) => {
                  logEntry.err[key] = err[key];
                });
              }
              this.emit("log", logEntry);
            }
          };
        }
        return synteticLogger;
      }
      unbind() {
        this.socket.unpipe(this.streamer);
        if (this._inflate) {
          this._inflate.unpipe(this.streamer);
        }
        this.socket.removeListener("error", this._socketError);
        this.socket.removeListener("close", this._socketClose);
        this.socket.removeListener("end", this._socketEnd);
        this.socket.removeListener("tlsClientError", this._socketError);
        this.socket.removeListener("timeout", this._socketTimeout);
        return {
          readSocket: this._inflate || this.socket,
          writeSocket: this.writeSocket || this.socket
        };
      }
    };
    /**
     * Current module version as a static class property
     * @property {String} version Module version
     * @static
     */
    __publicField(ImapFlow, "version", packageInfo.version);
    module.exports.ImapFlow = ImapFlow;
  }
});
export default require_imap_flow();
//# sourceMappingURL=imapflow.js.map
